// Driver for 47_sparse_la_spmv for Kokkos
// #include <Kokkos_Core.hpp>
// 
// struct COOElement {
//    size_t row, column;
//    double value;
// };
// 
// /* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,
//    and A is a sparse matrix stored in COO format.
//    x and y are length N and A is M x N.
//    Use Kokkos to parallelize. Assume Kokkos has already been initialized.
//    Example:
// 
//    input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]
//    output: y=[2, 3]
// */
// void spmv(double alpha, Kokkos::View<const COOElement*> const& A, Kokkos::View<const double*> const& x, double beta, Kokkos::View<double *> &y, size_t M, size_t N) {

#include <algorithm>
#include <numeric>
#include <random>
#include <vector>

#include "kokkos-includes.hpp"
#include "utilities.hpp"
#include "generated-code.hpp"   // code generated by LLM
#include "baseline.hpp"

struct Context {
    Kokkos::View<COOElement*> A;
    Kokkos::View<double*> x, y;
    Kokkos::View<const COOElement*> AConst;
    Kokkos::View<const double*> xConst;
    std::vector<COOElement> AHost;
    std::vector<double> xHost, yHost;
    double alpha, beta;
    size_t M, N;
};

void reset(Context *ctx) {
    ctx->alpha = (rand() / (double) RAND_MAX) * 2.0 - 1.0;
    ctx->beta = (rand() / (double) RAND_MAX) * 2.0 - 1.0;

    fillRand(ctx->xHost, -1.0, 1.0);
    fillRand(ctx->yHost, -1.0, 1.0);
    copyVectorToView(ctx->xHost, ctx->x);
    copyVectorToView(ctx->yHost, ctx->y);

    for (size_t i = 0; i < ctx->AHost.size(); i += 1) {
        ctx->AHost[i] = {rand() % ctx->M, rand() % ctx->N, (rand() / (double) RAND_MAX) * 2.0 - 1.0};
    }
    std::sort(ctx->AHost.begin(), ctx->AHost.end(), [](COOElement const& a, COOElement const& b) {
        return (a.row == b.row) ? (a.column < b.column) : (a.row < b.row);
    });

    for (size_t i = 0; i < ctx->AHost.size(); i += 1) {
        ctx->A(i) = ctx->AHost[i];
    }
    ctx->AConst = ctx->A;
    ctx->xConst = ctx->x;
}

Context *init() {
    Context *ctx = new Context();

    ctx->M = DRIVER_PROBLEM_SIZE;
    ctx->N = DRIVER_PROBLEM_SIZE;
    const size_t nVals = ctx->M * ctx->N * SPARSE_LA_SPARSITY;

    ctx->AHost.resize(nVals);
    ctx->xHost.resize(ctx->N);
    ctx->yHost.resize(ctx->M);

    ctx->A = Kokkos::View<COOElement*>("A", nVals);
    ctx->x = Kokkos::View<double*>("x", ctx->N);
    ctx->y = Kokkos::View<double*>("y", ctx->M);

    reset(ctx);
    return ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    spmv(ctx->alpha, ctx->AConst, ctx->xConst, ctx->beta, ctx->y, ctx->M, ctx->N);
}

void NO_OPTIMIZE best(Context *ctx) {
    correctSpmv(ctx->alpha, ctx->AHost, ctx->xHost, ctx->beta, ctx->yHost, ctx->M, ctx->N);
}

bool validate(Context *ctx) {
    const size_t TEST_SIZE = 1024;
    const size_t nVals = TEST_SIZE * TEST_SIZE * SPARSE_LA_SPARSITY;

    Kokkos::View<COOElement*> A("A", nVals);
    Kokkos::View<double*> x("x", TEST_SIZE);
    Kokkos::View<double*> y("y", TEST_SIZE);

    std::vector<COOElement> AHost(nVals);
    std::vector<double> xHost(TEST_SIZE);
    std::vector<double> yHost(TEST_SIZE), test(TEST_SIZE);

    const size_t numTries = MAX_VALIDATION_ATTEMPTS;
    for (int trialIter = 0; trialIter < numTries; trialIter += 1) {
        // set up input
        double alpha = (rand() / (double) RAND_MAX) * 2.0 - 1.0;
        double beta = (rand() / (double) RAND_MAX) * 2.0 - 1.0;
        fillRand(xHost, -1.0, 1.0);
        fillRand(yHost, -1.0, 1.0);
        copyVectorToView(xHost, x);
        copyVectorToView(yHost, y);

        for (size_t i = 0; i < AHost.size(); i += 1) {
            AHost[i] = {rand() % TEST_SIZE, rand() % TEST_SIZE, (rand() / (double) RAND_MAX) * 2.0 - 1.0};
        }
        std::sort(AHost.begin(), AHost.end(), [](COOElement const& a, COOElement const& b) {
            return (a.row == b.row) ? (a.column < b.column) : (a.row < b.row);
        });

        for (size_t i = 0; i < AHost.size(); i += 1) {
            A(i) = AHost[i];
        }
        Kokkos::View<const double*> xConst = x;
        Kokkos::View<const COOElement*> AConst = A;

        // compute correct result
        correctSpmv(alpha, AHost, xHost, beta, yHost, TEST_SIZE, TEST_SIZE);

        // compute test result
        spmv(alpha, AConst, xConst, beta, y, TEST_SIZE, TEST_SIZE);

        // copy out
        copyViewToVector(y, test);
        
        if (!fequal(yHost, test, 1e-4)) {
            return false;
        }
    }

    return true;
}

void destroy(Context *ctx) {
    delete ctx;
}
