// Driver for 02_dense_la_gemm for Kokkos
// #include <Kokkos_Core.hpp>
// 
// /* Multiply the matrix A by the matrix B. Store the results in the matrix C.
//    A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.
//    Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.
//    Example:
// 
//    input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]
//    output: C=[[9, 5], [4, 2]]
// */
// void gemm(Kokkos::View<const double**> &A, Kokkos::View<const double**> &B, Kokkos::View<double**> &C, size_t M, size_t K, size_t N) {

#include <algorithm>
#include <numeric>
#include <random>
#include <vector>

#include <Kokkos_Core.hpp>
#include <Kokkos_Sort.hpp>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    Kokkos::View<double**> A, B, C;
    size_t M, K, N;
    std::vector<double> A_host, B_host, C_host;
};

void reset(Context *ctx) {
    fillRand(ctx->A_host, -1.0, 1.0);
    fillRand(ctx->B_host, -1.0, 1.0);
    std::fill(ctx->C_host.begin(), ctx->C_host.end(), 0.0);

    for (size_t i = 0; i < ctx->M; i += 1) {
        for (size_t j = 0; j < ctx->K; j += 1) {
            ctx->A_host(i, j) = ctx->A_host[i * ctx->K + j];
        }
    }

    for (size_t i = 0; i < ctx->K; i += 1) {
        for (size_t j = 0; j < ctx->N; j += 1) {
            ctx->B_host(i, j) = ctx->B_host[i * ctx->N + j];
        }
    }

    for (size_t i = 0; i < ctx->M; i += 1) {
        for (size_t j = 0; j < ctx->N; j += 1) {
            ctx->C_host(i, j) = ctx->C_host[i * ctx->N + j];
        }
    }
}

Context *init() {
    Context *ctx = new Context();

    ctx->M = 1 << 10;
    ctx->K = 1 << 9;
    ctx->N = 1 << 10;

    ctx->A_host.resize(ctx->M * ctx->K);
    ctx->B_host.resize(ctx->K * ctx->N);
    ctx->C_host.resize(ctx->M * ctx->N);

    ctx->A = Kokkos::View<double**>("A", ctx->M, ctx->K);
    ctx->B = Kokkos::View<double**>("B", ctx->K, ctx->N);
    ctx->C = Kokkos::View<double**>("C", ctx->M, ctx->N);

    reset(ctx);
    return ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    gemm(ctx->A, ctx->B, ctx->C, ctx->M, ctx->K, ctx->N);
}

void NO_OPTIMIZE best(Context *ctx) {
    correctGemm(ctx->A_host, ctx->B_host, ctx->C_host, ctx->M, ctx->K, ctx->N);
}

bool validate(Context *ctx) {
    const size_t TEST_SIZE = 1024;

    std::vector<double> A_host(TEST_SIZE * TEST_SIZE), B_host(TEST_SIZE * TEST_SIZE), correct(TEST_SIZE * TEST_SIZE), test(TEST_SIZE * TEST_SIZE);
    Kokkos::View<double**> A("A", TEST_SIZE, TEST_SIZE);
    Kokkos::View<double**> B("B", TEST_SIZE, TEST_SIZE);
    Kokkos::View<double**> C("C", TEST_SIZE, TEST_SIZE);

    const size_t numTries = MAX_VALIDATION_ATTEMPTS;
    for (int trialIter = 0; trialIter < numTries; trialIter += 1) {
        // set up input
        fillRand(A_host, -1.0, 1.0);
        fillRand(B_host, -1.0, 1.0);
        std::fill(correct.begin(), correct.end(), 0.0);

        for (size_t i = 0; i < TEST_SIZE; i += 1) {
            for (size_t j = 0; j < TEST_SIZE; j += 1) {
                A(i, j) = A_host[i * TEST_SIZE + j];
                B(i, j) = B_host[i * TEST_SIZE + j];
                C(i, j) = 0.0;
            }
        }

        // compute correct result
        correctGemm(A_host, B_host, correct, TEST_SIZE, TEST_SIZE, TEST_SIZE);

        // compute test result
        gemm(A, B, C, TEST_SIZE, TEST_SIZE, TEST_SIZE);

        // copy test result back to host
        for (size_t i = 0; i < TEST_SIZE; i += 1) {
            for (size_t j = 0; j < TEST_SIZE; j += 1) {
                test[i * TEST_SIZE + j] = C(i, j);
            }
        }
        
        if (!fequal(correct, test, 1e-4)) {
            return false;
        }
    }

    return true;
}

void destroy(Context *ctx) {
    delete ctx;
}
