prompt,name,problem_type,language,parallelism_model,temperature,top_p,do_sample,max_new_tokens,prompted,generated_output,did_build,is_source_valid,best_sequential_runtime,output_idx,run_idx,did_run,is_valid,runtime,num_threads,num_procs
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026043652,0,0.0,True,False,1.001e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<size_t> result(""result"", 1);\n  Kokkos::parallel_for(""findFirstEven"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)), KOKKOS_LAMBDA(const int i) {\n    if (x(i) % 2 == 0) {\n      result(0) = i;\n      return;\n    }\n  });\n  Kokkos::fence();\n  return result(0);\n}",False,True,,1,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026052912,2,0.0,True,False,1.485e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026046179,3,0.0,True,False,7.82e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026061179,4,0.0,True,False,8.7e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026061077,5,0.0,True,False,8.3e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026047602,6,0.0,True,False,9.52e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026048243,7,0.0,True,False,1.132e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026058473,8,0.0,True,False,8.21e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026040297,9,0.0,True,False,8.11e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026048383,10,0.0,True,False,1.022e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026044486,11,0.0,True,False,9.01e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<size_t> result(""result"", 1);\n  Kokkos::parallel_for(\n      ""findFirstEven"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.size()),\n      KOKKOS_LAMBDA(const int i) {\n        if (x(i) % 2 == 0) {\n          result(0) = i;\n          return;\n        }\n      });\n  Kokkos::fence();\n  return result(0);\n}",False,True,,12,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026044314,13,0.0,True,False,8.81e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026060927,14,0.0,True,False,1.002e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026035209,15,0.0,True,False,1.022e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026056338,16,0.0,True,False,1.942e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026031884,17,0.0,True,False,1.382e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026059491,18,0.0,True,False,9.41e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the first even number in the vector x.\n   Use Kokkos to parallelize the search. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(Kokkos::View<const int*> const& x) {",38_search_find_the_first_even_number,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0026050436,19,0.0,True,False,9.21e-08,1.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n},False,True,,0,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t i = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},False,True,,1,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n},False,True,,2,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t i = 0;\n  #pragma omp parallel for\n  for (i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      break;\n    }\n  }\n  return i;\n},False,True,,3,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n  #pragma omp parallel for reduction(min: result)\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,4,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,0.0,True,True,0.00130091246683,1.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,1.0,True,True,0.00080280590337,2.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,2.0,True,True,0.00042229115497,4.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,3.0,True,True,0.00022991653532,8.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,4.0,True,True,0.00023951327894,16.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,5.0,True,True,0.00033765810076,32.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (i < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025964854285,5,6.0,True,True,0.00048968987539,64.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,6,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n  return index;\n},False,True,,7,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,8,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t i = 0;\n  #pragma omp parallel for\n  for (size_t j = 0; j < x.size(); j++) {\n    if (x[j] % 2 == 0) {\n      i = j;\n      break;\n    }\n  }\n  return i;\n},False,True,,9,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,10,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n  #pragma omp parallel for reduction(min: result)\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,11,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,12,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,0.0,True,True,0.00130282819737,1.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,1.0,True,True,0.00080758670811,2.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,2.0,True,True,0.00042960292194,4.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,3.0,True,True,0.00023294840939,8.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,4.0,True,True,0.00023172474466,16.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,5.0,True,True,0.00036411578767,32.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965720415,13,6.0,True,True,0.00051059229299,64.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n},False,True,,14,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,15,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,0.0,True,True,0.00130370270927,1.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,1.0,True,True,0.00081788722891,2.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,2.0,True,True,0.00042807403952,4.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,3.0,True,True,0.00022930740379,8.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,4.0,True,True,0.00023231082596,16.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,5.0,True,True,0.00036618879531,32.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      #pragma omp critical\n      {\n        if (i < result) {\n          result = i;\n        }\n      }\n    }\n  }\n  return result;\n},True,True,0.00025965450332,16,6.0,True,True,0.00050633740611,64.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t i = 0;\n  #pragma omp parallel for\n  for (i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      break;\n    }\n  }\n  return i;\n},False,True,,17,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n},False,True,,18,,,,,,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    size_t i = 0;\n    #pragma omp parallel for\n    for (i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (x[i] < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025973960292,19,0.0,True,True,0.00130038450006,1.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    size_t i = 0;\n    #pragma omp parallel for\n    for (i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (x[i] < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025973960292,19,1.0,True,True,0.00081340286415,2.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    size_t i = 0;\n    #pragma omp parallel for\n    for (i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (x[i] < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025973960292,19,2.0,True,True,0.00042356371414,4.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    size_t i = 0;\n    #pragma omp parallel for\n    for (i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (x[i] < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025973960292,19,3.0,True,True,0.00023122287821,8.0,
"#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = x.size();\n    size_t i = 0;\n    #pragma omp parallel for\n    for (i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            #pragma omp critical\n            {\n                if (x[i] < result) {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n},True,True,0.00025973960292,19,4.0,True,False,0.00025715462398,16.0,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002606765,0,0.0,True,True,0.0002746619,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.000259937,1,0.0,True,True,0.0002757148,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002601113,2,0.0,True,True,0.0002768379,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002599209,3,0.0,True,True,0.0002744362,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002600643,4,0.0,True,True,0.0002744464,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.000260115,5,0.0,True,True,0.0002755164,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002599008,6,0.0,True,True,0.0002747869,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002597798,7,0.0,True,True,0.0002767598,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002597436,8,0.0,True,True,0.000274272,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002598488,9,0.0,True,True,0.0002754952,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002605784,10,0.0,True,True,0.000274828,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002598596,11,0.0,True,True,0.0002765051,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002598667,12,0.0,True,True,0.000274347,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002597084,13,0.0,True,True,0.0002745676,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002606643,14,0.0,True,True,0.000275359,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002601113,15,0.0,True,True,0.0002753622,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002601004,16,0.0,True,True,0.0002745093,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n},True,True,0.0002601445,17,0.0,True,True,0.0002743158,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002596316,18,0.0,True,True,0.0002754132,,
"/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n    return x.size();\n},True,True,0.0002601756,19,0.0,True,True,0.0002743984,,
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // number of even numbers in the vector\n    int even_count = 0;\n\n    // number of even numbers in the vector on the previous rank\n    int even_count_prev = 0;\n\n    // number of even numbers in the vector on the next rank\n    int even_count_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_prev_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_prev_next_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_next_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_next_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_next_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev_prev_prev = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev_prev_next = 0;\n\n    // number of even numbers in the vector on the current rank\n    int even_count_curr_next_prev_next_next = 0;\n\n    // number of even numbers in the vector on the current",False,True,,0,,,,,,
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the offset of the first even number in the vector on each rank\n  int offset_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        offset_local++;\n      }\n    }\n  }\n\n  // calculate the offset of the first even number in the vector\n  int offset = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        offset++;\n      }\n    }\n  }\n\n  // calculate the number of even numbers in the vector on rank 0\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the offset of the first even number in the vector on rank 0\n  int offset_global = 0;\n  MPI_Reduce(&offset_local, &offset_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the index of the first even number in the vector on rank 0\n  if (rank == 0) {\n    result = offset_global + even_count_global;\n  }\n\n  return result;\n}",True,True,0.0002601891,1,0.0,True,False,0.0013001122,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,0.0,True,True,0.0002763393,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,1.0,True,True,0.00026044445,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,2.0,True,True,0.0011836104,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,3.0,True,True,0.00078111255,,8.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,4.0,True,True,0.00031129285625,,16.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,5.0,True,True,0.0001084018,,32.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,6.0,True,True,8.949525937e-05,,64.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_local = n / world_size;\n\n  // get the start and end index of the local vector\n  int start = n_local * world_rank;\n  int end = start + n_local;\n\n  // find the first even number in the local vector\n  int first_even = -1;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      first_even = i;\n      break;\n    }\n  }\n\n  // find the first even number in the local vector\n  int first_even_global;\n  MPI_Reduce(&first_even, &first_even_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  return first_even_global;\n}",True,True,0.000259691,2,7.0,True,False,6.264384453e-05,,128.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        start_local++;\n      }\n    }\n  }\n\n  // calculate the starting index of the even numbers on each rank\n  int start_global = 0;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers on each rank\n  int start = 0;\n  if (rank == 0) {\n    start = 0;\n  } else {\n    start = start_global;\n  }\n\n  // calculate the ending index of the even numbers on each rank\n  int end_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        end_local++;\n      }\n    }\n  }\n\n  // calculate the ending index of the even numbers on each rank\n  int end_global = 0;\n  MPI_Reduce(&end_local, &end_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the ending index of the even numbers on each rank\n  int end = 0;\n  if (rank == 0) {\n    end = even_count;\n  } else {\n    end = end_global;\n  }\n\n  // find the index of the first even number on each rank\n  int index_local = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      index_local = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number on each rank\n  int index_global = 0;\n  MPI_Reduce(&index_local, &index_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  // find the index of the first even number on each rank\n  int index = 0;\n  if (rank == 0) {\n    index = index_global;\n  }\n\n  return index;\n}",True,True,0.0002597302,3,0.0,True,True,0.0021211251,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        start_local++;\n      }\n    }\n  }\n\n  // calculate the starting index of the even numbers on each rank\n  int start_global = 0;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers on each rank\n  int start = 0;\n  if (rank == 0) {\n    start = 0;\n  } else {\n    start = start_global;\n  }\n\n  // calculate the ending index of the even numbers on each rank\n  int end_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (int j = 0; j < x.size(); j++) {\n      if (x[j] % 2 == 0) {\n        end_local++;\n      }\n    }\n  }\n\n  // calculate the ending index of the even numbers on each rank\n  int end_global = 0;\n  MPI_Reduce(&end_local, &end_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the ending index of the even numbers on each rank\n  int end = 0;\n  if (rank == 0) {\n    end = even_count;\n  } else {\n    end = end_global;\n  }\n\n  // find the index of the first even number on each rank\n  int index_local = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      index_local = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number on each rank\n  int index_global = 0;\n  MPI_Reduce(&index_local, &index_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  // find the index of the first even number on each rank\n  int index = 0;\n  if (rank == 0) {\n    index = index_global;\n  }\n\n  return index;\n}",True,True,0.0002597302,3,1.0,True,False,0.0055400614,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int even_count = 0;\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            even_count++;\n        }\n    }\n\n    int even_count_per_rank;\n    MPI_Reduce(&even_count, &even_count_per_rank, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_per_rank_local = even_count_per_rank / size;\n    int even_count_per_rank_global = 0;\n    MPI_Reduce(&even_count_per_rank_local, &even_count_per_rank_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_global = 0;\n    MPI_Reduce(&even_count, &even_count_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local = 0;\n    if (rank == 0) {\n        even_count_local = even_count_global - even_count_per_rank_global * (size - 1);\n    }\n\n    int even_count_local_local = 0;\n    MPI_Reduce(&even_count_local, &even_count_local_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local_global = 0;\n    MPI_Reduce(&even_count_local_local, &even_count_local_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local_global_local = 0;\n    if (rank == 0) {\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] % 2 == 0) {\n                even_count_local_global_local++;\n            }\n        }\n    }\n\n    int even_count_local_global_local_local = 0;\n    MPI_Reduce(&even_count_local_global_local, &even_count_local_global_local_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local_global_local_local_local = 0;\n    if (rank == 0) {\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] % 2 == 0) {\n                even_count_local_global_local_local++;\n            }\n        }\n    }\n\n    int even_count_local_global_local_local_local_local = 0;\n    MPI_Reduce(&even_count_local_global_local_local_local, &even_count_local_global_local_local_local_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local_global_local_local_local_local_local = 0;\n    if (rank == 0) {\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] % 2 == 0) {\n                even_count_local_global_local_local_local_local++;\n            }\n        }\n    }\n\n    int even_count_local_global_local_local_local_local_local_local = 0;\n    MPI_Reduce(&even_count_local_global_local_local_local_local_local, &even_count_local_global_local_local_local_local_local_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    int even_count_local_global_local_local_local_local_local_local_local = 0;\n    if (rank == 0) {\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] % 2 == 0) {\n                even_count_local_global_local_local_local_local_local_local++;\n            }\n        }\n    }\n\n    int even_count_local_global_local_local_local_local_local_local_local_local = 0;",False,True,,4,,,,,,
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of even numbers\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // get the number of even numbers on each rank\n  int even_count_on_rank;\n  MPI_Reduce(&even_count, &even_count_on_rank, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the number of even numbers on each rank\n  int even_count_on_rank_before;\n  MPI_Scan(&even_count, &even_count_on_rank_before, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n  // get the index of the first even number on each rank\n  int first_even_index_on_rank = even_count_on_rank_before - even_count_on_rank;\n\n  // get the index of the first even number on rank 0\n  int first_even_index_on_rank_0;\n  MPI_Reduce(&first_even_index_on_rank, &first_even_index_on_rank_0, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the index of the first even number on rank 0\n  int first_even_index_on_rank_0_before;\n  MPI_Scan(&first_even_index_on_rank, &first_even_index_on_rank_0_before, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n  // get the index of the first even number\n  int first_even_index = first_even_index_on_rank_0_before - first_even_index_on_rank_0;\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return first_even_index;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002598996,5,0.0,True,False,0.0012998131,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // sum up the even numbers on each rank\n  int even_count_sum = 0;\n  MPI_Allreduce(&even_count_local, &even_count_sum, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_index_local += even_count_local;\n  }\n\n  // sum up the starting index of the even numbers on each rank\n  int start_index_sum = 0;\n  MPI_Allreduce(&start_index_local, &start_index_sum, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the even numbers\n  int start_index = 0;\n  for (int i = 0; i < rank; i++) {\n    start_index += even_count;\n  }\n\n  // return the index of the first even number\n  return start_index + start_index_sum;\n}",True,True,0.0002602264,6,0.0,True,False,0.0014767622,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements per rank\n  int n = x.size() / size;\n  // number of elements in the last rank\n  int r = x.size() % size;\n\n  // rank 0 sends the first n + r elements to the other ranks\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      MPI_Send(x.data() + i * n + std::min(i, r), n + std::min(i, r), MPI_INT, i, 0, MPI_COMM_WORLD);\n    }\n  }\n\n  // rank 0 receives the first n + r elements from the other ranks\n  if (rank == 0) {\n    int first_even = -1;\n    for (int i = 1; i < size; i++) {\n      int tmp;\n      MPI_Recv(&tmp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      if (tmp % 2 == 0) {\n        first_even = tmp;\n        break;\n      }\n    }\n    return first_even;\n  }\n\n  // rank 0 sends the first n + r elements to the other ranks\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      MPI_Send(x.data() + i * n + std::min(i, r), n + std::min(i, r), MPI_INT, i, 0, MPI_COMM_WORLD);\n    }\n  }\n\n  // rank 0 receives the first n + r elements from the other ranks\n  if (rank == 0) {\n    int first_even = -1;\n    for (int i = 1; i < size; i++) {\n      int tmp;\n      MPI_Recv(&tmp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      if (tmp % 2 == 0) {\n        first_even = tmp;\n        break;\n      }\n    }\n    return first_even;\n  }\n\n  // rank 0 sends the first n + r elements to the other ranks\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      MPI_Send(x.data() + i * n + std::min(i, r), n + std::min(i, r), MPI_INT, i, 0, MPI_COMM_WORLD);\n    }\n  }\n\n  // rank 0 receives the first n + r elements from the other ranks\n  if (rank == 0) {\n    int first_even = -1;\n    for (int i = 1; i < size; i++) {\n      int tmp;\n      MPI_Recv(&tmp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      if (tmp % 2 == 0) {\n        first_even = tmp;\n        break;\n      }\n    }\n    return first_even;\n  }\n\n  // rank 0 sends the first n + r elements to the other ranks\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      MPI_Send(x.data() + i * n + std::min(i, r), n + std::min(i, r), MPI_INT, i, 0, MPI_COMM_WORLD);\n    }\n  }\n\n  // rank 0 receives the first n + r elements from the other ranks\n  if (rank == 0) {\n    int first_even = -1;\n    for (int i = 1; i < size; i++) {\n      int tmp;\n      MPI_Recv(&tmp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      if (tmp % 2 == 0) {\n        first_even = tmp;\n        break;\n      }\n    }\n    return first_even;\n  }\n\n  // rank 0 sends the first n + r elements to the other ranks\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      MPI_Send(x.data() + i * n + std::min(i, r), n + std::min(i, r), MPI_INT, i, 0, MPI_COMM_WORLD);\n    }\n  }\n\n  // rank 0 receives the first n + r elements",False,True,,7,,,,,,
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_per_rank = even_count / size;\n  int remainder = even_count % size;\n\n  // calculate the starting index of the even numbers on each rank\n  int even_start_per_rank = even_count_per_rank * rank;\n  int remainder_start = even_count_per_rank * remainder;\n\n  // calculate the starting index of the even numbers on the remainder\n  int even_start_remainder = remainder_start + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 0\n  int even_start_rank0 = 0;\n\n  // calculate the starting index of the even numbers on rank 1\n  int even_start_rank1 = even_start_remainder + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 2\n  int even_start_rank2 = even_start_rank1 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 3\n  int even_start_rank3 = even_start_rank2 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 4\n  int even_start_rank4 = even_start_rank3 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 5\n  int even_start_rank5 = even_start_rank4 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 6\n  int even_start_rank6 = even_start_rank5 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 7\n  int even_start_rank7 = even_start_rank6 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 8\n  int even_start_rank8 = even_start_rank7 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 9\n  int even_start_rank9 = even_start_rank8 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 10\n  int even_start_rank10 = even_start_rank9 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 11\n  int even_start_rank11 = even_start_rank10 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 12\n  int even_start_rank12 = even_start_rank11 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 13\n  int even_start_rank13 = even_start_rank12 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 14\n  int even_start_rank14 = even_start_rank13 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 15\n  int even_start_rank15 = even_start_rank14 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 16\n  int even_start_rank16 = even_start_rank15 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 17\n  int even_start_rank17 = even_start_rank16 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 18\n  int even_start_rank18 = even_start_rank17 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 19\n  int even_start_rank19 = even_start_rank18 + even_count_per_rank;\n\n  // calculate the starting index of the even numbers on rank 20\n  int even_start_rank20 = even_start_",False,True,,8,,,,,,
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,0.0,True,True,0.000275588,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,1.0,True,True,0.00022845275,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,2.0,True,True,0.00014507775,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,3.0,True,True,0.0001004504875,,8.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,4.0,True,True,6.62177625e-05,,16.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,5.0,True,True,2.5132425e-05,,32.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,6.0,True,True,1.585804063e-05,,64.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,7.0,True,True,8.18613281e-06,,128.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,8.0,True,True,5.8618918e-06,,256.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_process = n / world_size;\n\n    // get the number of elements that are left\n    int n_left = n % world_size;\n\n    // get the start and end index of the process\n    int start = world_rank * n_per_process;\n    int end = start + n_per_process;\n\n    // if the process has elements left, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // search for the first even number in the process\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            return i;\n        }\n    }\n\n    // if no even number was found, return -1\n    return -1;\n}",True,True,0.0002605493,9,9.0,True,False,4.65067109e-06,,512.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,0.0,True,True,0.0015765175,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,1.0,True,True,0.00090885845,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,2.0,True,True,0.001469605825,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,3.0,True,True,0.0009313965125,,8.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,4.0,True,True,0.00042146690625,,16.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,5.0,True,True,0.00017701840312,,32.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,6.0,True,True,0.00017047788906,,64.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each process\n  int n_local = n / world_size;\n\n  // get the starting index of the local vector\n  int start_local = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local = start_local + n_local;\n\n  // get the starting index of the global vector\n  int start_global = 0;\n\n  // get the ending index of the global vector\n  int end_global = n;\n\n  // get the number of even numbers in the local vector\n  int even_local = 0;\n\n  // loop through the local vector\n  for (int i = start_local; i < end_local; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // increment the number of even numbers\n      even_local++;\n    }\n  }\n\n  // get the number of even numbers in the global vector\n  int even_global;\n\n  // get the number of even numbers in the global vector\n  MPI_Reduce(&even_local, &even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // get the starting index of the local vector\n  int start_local_2 = n_local * world_rank;\n\n  // get the ending index of the local vector\n  int end_local_2 = start_local_2 + n_local;\n\n  // get the starting index of the global vector\n  int start_global_2 = 0;\n\n  // get the ending index of the global vector\n  int end_global_2 = n;\n\n  // get the index of the first even number in the local vector\n  int first_even_local = -1;\n\n  // loop through the local vector\n  for (int i = start_local_2; i < end_local_2; i++) {\n    // check if the current element is even\n    if (x[i] % 2 == 0) {\n      // set the index of the first even number\n      first_even_local = i;\n      break;\n    }\n  }\n\n  // get the index of the first even number in the global vector\n  int first_even_global;\n\n  // get the index of the first even number in the global vector\n  MPI_Reduce(&first_even_local, &first_even_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number in the global vector\n  return first_even_global;\n}",True,True,0.0002599979,10,7.0,True,False,8.13486625e-05,,128.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // calculate the number of even numbers in the vector\n    int even_count = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            even_count++;\n        }\n    }\n\n    // calculate the number of even numbers in the vector on each rank\n    int even_count_local = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            even_count_local++;\n        }\n    }\n\n    // sum up the even numbers on each rank\n    int even_count_total = 0;\n    MPI_Reduce(&even_count_local, &even_count_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the starting index of the even numbers on each rank\n    int start_index_local = 0;\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j < i; j++) {\n            if (x[j] % 2 == 0) {\n                start_index_local++;\n            }\n        }\n    }\n\n    // sum up the starting index of the even numbers on each rank\n    int start_index_total = 0;\n    MPI_Reduce(&start_index_local, &start_index_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the starting index of the even numbers\n    int start_index = 0;\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j < i; j++) {\n            if (x[j] % 2 == 0) {\n                start_index++;\n            }\n        }\n    }\n\n    // calculate the index of the first even number on each rank\n    int index_local = start_index_local + even_count_local;\n\n    // sum up the index of the first even number on each rank\n    int index_total = start_index_total + even_count_total;\n\n    // calculate the index of the first even number\n    int index = start_index + even_count;\n\n    // return the index of the first even number on rank 0\n    if (rank == 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}",True,True,0.0002600147,11,0.0,True,False,0.0021170366,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,0.0,True,True,0.0021216643,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,1.0,True,True,0.0023035453,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,2.0,True,True,0.003153233,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,3.0,True,True,0.0032508049125,,8.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,4.0,True,True,0.00268962208125,,16.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,5.0,True,True,0.002416578475,,32.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,6.0,True,True,0.00272136667344,,64.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,7.0,True,True,0.00273834649844,,128.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,8.0,True,True,0.0035014736457,,256.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int n_even = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      n_even_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int n_even_global;\n  MPI_Reduce(&n_even_local, &n_even_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_local += n_even_local;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_global;\n  MPI_Reduce(&start_local, &start_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start = 0;\n  for (int i = 0; i < rank; i++) {\n    start += n_even;\n  }\n\n  // calculate the starting index of the vector on each rank\n  int end = start + n_even_global;\n\n  // find the index of the first even number in the vector\n  for (int i = start; i < end; i++) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",True,True,0.0002601159,12,9.0,True,True,0.00587835426504,,512.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_per_proc = n / world_size;\n\n  // get the number of elements in the last process\n  int n_last_proc = n % world_size;\n\n  // get the starting index of the process\n  int start = world_rank * n_per_proc;\n\n  // get the ending index of the process\n  int end = (world_rank + 1) * n_per_proc;\n\n  // if the process is the last process, add the number of elements in the last process\n  if (world_rank == world_size - 1) {\n    end += n_last_proc;\n  }\n\n  // create a vector to store the even numbers\n  std::vector<int> even_numbers;\n\n  // loop over the elements in the vector\n  for (int i = start; i < end; i++) {\n    // if the element is even, add it to the vector\n    if (x[i] % 2 == 0) {\n      even_numbers.push_back(x[i]);\n    }\n  }\n\n  // get the number of even numbers\n  int n_even = even_numbers.size();\n\n  // get the number of even numbers per process\n  int n_even_per_proc = n_even / world_size;\n\n  // get the number of even numbers in the last process\n  int n_even_last_proc = n_even % world_size;\n\n  // get the starting index of the process\n  int start_even = world_rank * n_even_per_proc;\n\n  // get the ending index of the process\n  int end_even = (world_rank + 1) * n_even_per_proc;\n\n  // if the process is the last process, add the number of even numbers in the last process\n  if (world_rank == world_size - 1) {\n    end_even += n_even_last_proc;\n  }\n\n  // get the index of the first even number in the vector\n  int first_even = even_numbers[start_even];\n\n  // return the index of the first even number in the vector\n  return first_even;\n}",True,True,0.0002597371,13,0.0,True,False,0.0006777632,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int num_procs;\n  MPI_Comm_size(MPI_COMM_WORLD, &num_procs);\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will handle\n  int n_local = n / num_procs;\n\n  // get the start and end indices of the local vector\n  int start = rank * n_local;\n  int end = start + n_local;\n\n  // get the local vector\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // find the index of the first even number in the local vector\n  size_t index = 0;\n  for (size_t i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // get the global index of the first even number\n  int global_index = 0;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the global index\n  return global_index;\n}",True,True,0.0002597943,14,0.0,True,True,0.0007778673,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int num_procs;\n  MPI_Comm_size(MPI_COMM_WORLD, &num_procs);\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will handle\n  int n_local = n / num_procs;\n\n  // get the start and end indices of the local vector\n  int start = rank * n_local;\n  int end = start + n_local;\n\n  // get the local vector\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // find the index of the first even number in the local vector\n  size_t index = 0;\n  for (size_t i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // get the global index of the first even number\n  int global_index = 0;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the global index\n  return global_index;\n}",True,True,0.0002597943,14,1.0,True,False,0.0005441325,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,0.0,True,True,0.0017034541,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,1.0,True,True,0.003024471,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,2.0,True,True,0.006286277525,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,3.0,True,True,0.010233461525,,8.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,4.0,True,True,0.018597876175,,16.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,5.0,True,True,0.02529782097188,,32.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,6.0,True,True,0.04674192924063,,64.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,7.0,True,True,0.08903046508047,,128.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,8.0,True,True,0.17426836933359,,256.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the start index of the even numbers on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the start index of the even numbers on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global + even_count_global;\n  }\n\n  // find the index of the first even number\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the index of the first even number on rank 0\n  int index_global = -1;\n  MPI_Reduce(&index, &index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  // return the index of the first even number\n  if (rank == 0) {\n    return index_global;\n  } else {\n    return -1;\n  }\n}",True,True,0.0002596982,15,9.0,True,True,0.48898135911074,,512.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_global = 0;\n  MPI_Allreduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_index_local += even_count_local;\n  }\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_global = 0;\n  MPI_Allreduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = start_index_global;\n  }\n\n  // find the index of the first even number in the vector\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number in the vector\n  int index_global = -1;\n  MPI_Allreduce(&index, &index_global, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n  return index_global;\n}",True,True,0.0002599784,16,0.0,True,True,0.0018488295,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_global = 0;\n  MPI_Allreduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_index_local += even_count_local;\n  }\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_global = 0;\n  MPI_Allreduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = start_index_global;\n  }\n\n  // find the index of the first even number in the vector\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number in the vector\n  int index_global = -1;\n  MPI_Allreduce(&index, &index_global, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n  return index_global;\n}",True,True,0.0002599784,16,1.0,True,True,0.00187844955,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_global = 0;\n  MPI_Allreduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    start_index_local += even_count_local;\n  }\n\n  // calculate the starting index of the first even number in the vector\n  int start_index_global = 0;\n  MPI_Allreduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM,\n                MPI_COMM_WORLD);\n\n  // calculate the starting index of the first even number in the vector\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = start_index_global;\n  }\n\n  // find the index of the first even number in the vector\n  int index = -1;\n  for (int i = start_index; i < x.size(); i++) {\n    if (x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number in the vector\n  int index_global = -1;\n  MPI_Allreduce(&index, &index_global, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n  return index_global;\n}",True,True,0.0002599784,16,2.0,True,False,0.00237568025,,4.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int nproc;\n    MPI_Comm_size(MPI_COMM_WORLD, &nproc);\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the size of the vector\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_proc = n / nproc;\n\n    // get the remainder\n    int remainder = n % nproc;\n\n    // get the start and end index of the process\n    int start = rank * n_per_proc;\n    int end = start + n_per_proc;\n\n    // if the remainder is not zero, add the remainder to the end index\n    if (remainder > 0) {\n        end += remainder;\n    }\n\n    // get the local vector\n    std::vector<int> local_vec(x.begin() + start, x.begin() + end);\n\n    // find the first even number\n    int even_index = 0;\n    for (int i = 0; i < local_vec.size(); i++) {\n        if (local_vec[i] % 2 == 0) {\n            even_index = i;\n            break;\n        }\n    }\n\n    // get the global even index\n    int global_even_index;\n    MPI_Reduce(&even_index, &global_even_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the global even index\n    return global_even_index;\n}",True,True,0.0002605889,17,0.0,True,True,0.0007668083,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int nproc;\n    MPI_Comm_size(MPI_COMM_WORLD, &nproc);\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the size of the vector\n    int n = x.size();\n\n    // get the number of elements per process\n    int n_per_proc = n / nproc;\n\n    // get the remainder\n    int remainder = n % nproc;\n\n    // get the start and end index of the process\n    int start = rank * n_per_proc;\n    int end = start + n_per_proc;\n\n    // if the remainder is not zero, add the remainder to the end index\n    if (remainder > 0) {\n        end += remainder;\n    }\n\n    // get the local vector\n    std::vector<int> local_vec(x.begin() + start, x.begin() + end);\n\n    // find the first even number\n    int even_index = 0;\n    for (int i = 0; i < local_vec.size(); i++) {\n        if (local_vec[i] % 2 == 0) {\n            even_index = i;\n            break;\n        }\n    }\n\n    // get the global even index\n    int global_even_index;\n    MPI_Reduce(&even_index, &global_even_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the global even index\n    return global_even_index;\n}",True,True,0.0002605889,17,1.0,True,False,0.0005682349,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global;\n  }\n\n  // calculate the ending index of the vector on each rank\n  int end_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        end_index_local++;\n      }\n    }\n  }\n\n  // calculate the ending index of the vector on each rank\n  int end_index_global = 0;\n  MPI_Reduce(&end_index_local, &end_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the ending index of the vector on each rank\n  int end_index = 0;\n  if (rank == 0) {\n    end_index = even_count;\n  } else {\n    end_index = end_index_global;\n  }\n\n  // find the index of the first even number in the vector on each rank\n  int index_local = 0;\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] % 2 == 0) {\n      index_local = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number in the vector on each rank\n  int index_global = 0;\n  MPI_Reduce(&index_local, &index_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  // find the index of the first even number in the vector on each rank\n  int index = 0;\n  if (rank == 0) {\n    index = index_global;\n  }\n\n  return index;\n}",True,True,0.0002596802,18,0.0,True,True,0.0021176016,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of even numbers in the vector\n  int even_count = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_local = 0;\n  for (auto const& i : x) {\n    if (i % 2 == 0) {\n      even_count_local++;\n    }\n  }\n\n  // calculate the number of even numbers in the vector on each rank\n  int even_count_global = 0;\n  MPI_Reduce(&even_count_local, &even_count_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        start_index_local++;\n      }\n    }\n  }\n\n  // calculate the starting index of the vector on each rank\n  int start_index_global = 0;\n  MPI_Reduce(&start_index_local, &start_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the starting index of the vector on each rank\n  int start_index = 0;\n  if (rank == 0) {\n    start_index = 0;\n  } else {\n    start_index = start_index_global;\n  }\n\n  // calculate the ending index of the vector on each rank\n  int end_index_local = 0;\n  for (int i = 0; i < rank; i++) {\n    for (auto const& j : x) {\n      if (j % 2 == 0) {\n        end_index_local++;\n      }\n    }\n  }\n\n  // calculate the ending index of the vector on each rank\n  int end_index_global = 0;\n  MPI_Reduce(&end_index_local, &end_index_global, 1, MPI_INT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // calculate the ending index of the vector on each rank\n  int end_index = 0;\n  if (rank == 0) {\n    end_index = even_count;\n  } else {\n    end_index = end_index_global;\n  }\n\n  // find the index of the first even number in the vector on each rank\n  int index_local = 0;\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] % 2 == 0) {\n      index_local = i;\n      break;\n    }\n  }\n\n  // find the index of the first even number in the vector on each rank\n  int index_global = 0;\n  MPI_Reduce(&index_local, &index_global, 1, MPI_INT, MPI_MIN, 0,\n             MPI_COMM_WORLD);\n\n  // find the index of the first even number in the vector on each rank\n  int index = 0;\n  if (rank == 0) {\n    index = index_global;\n  }\n\n  return index;\n}",True,True,0.0002596802,18,1.0,True,False,0.00489651515,,2.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // compute the number of even numbers in the vector\n    int num_even = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            num_even++;\n        }\n    }\n\n    // compute the number of even numbers in the vector on each rank\n    int num_even_local = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            num_even_local++;\n        }\n    }\n\n    // compute the starting index of the vector on each rank\n    int start_local = 0;\n    for (int i = 0; i < rank; i++) {\n        start_local += num_even_local;\n    }\n\n    // compute the starting index of the vector on rank 0\n    int start = 0;\n    MPI_Reduce(&start_local, &start, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on each rank\n    int end_local = start_local + num_even_local;\n    int end = 0;\n    MPI_Reduce(&end_local, &end, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on rank 0\n    int num_even_total = 0;\n    MPI_Reduce(&num_even_local, &num_even_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the starting index of the vector on rank 0\n    int start_total = 0;\n    MPI_Reduce(&start_local, &start_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on rank 0\n    int end_total = start_total + num_even_total;\n\n    // find the index of the first even number in the vector on rank 0\n    size_t index = 0;\n    for (size_t i = start_total; i < end_total; i++) {\n        if (x[i] % 2 == 0) {\n            index = i;\n            break;\n        }\n    }\n\n    // broadcast the index of the first even number in the vector on each rank\n    int index_local = index;\n    MPI_Bcast(&index_local, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the index of the first even number in the vector on rank 0\n    return index_local;\n}",True,True,0.0002598022,19,0.0,True,True,0.0012989547,,1.0
"#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // compute the number of even numbers in the vector\n    int num_even = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            num_even++;\n        }\n    }\n\n    // compute the number of even numbers in the vector on each rank\n    int num_even_local = 0;\n    for (auto const& i : x) {\n        if (i % 2 == 0) {\n            num_even_local++;\n        }\n    }\n\n    // compute the starting index of the vector on each rank\n    int start_local = 0;\n    for (int i = 0; i < rank; i++) {\n        start_local += num_even_local;\n    }\n\n    // compute the starting index of the vector on rank 0\n    int start = 0;\n    MPI_Reduce(&start_local, &start, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on each rank\n    int end_local = start_local + num_even_local;\n    int end = 0;\n    MPI_Reduce(&end_local, &end, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on rank 0\n    int num_even_total = 0;\n    MPI_Reduce(&num_even_local, &num_even_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the starting index of the vector on rank 0\n    int start_total = 0;\n    MPI_Reduce(&start_local, &start_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // compute the ending index of the vector on rank 0\n    int end_total = start_total + num_even_total;\n\n    // find the index of the first even number in the vector on rank 0\n    size_t index = 0;\n    for (size_t i = start_total; i < end_total; i++) {\n        if (x[i] % 2 == 0) {\n            index = i;\n            break;\n        }\n    }\n\n    // broadcast the index of the first even number in the vector on each rank\n    int index_local = index;\n    MPI_Bcast(&index_local, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the index of the first even number in the vector on rank 0\n    return index_local;\n}",True,True,0.0002598022,19,1.0,True,False,0.00132518205,,2.0
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n    int bid = blockIdx.x;\n    int stride = blockDim.x;\n    int start = bid * stride;\n    int end = min(start + stride, N);\n\n    int local_firstEvenIndex = -1;\n    for (int i = start + tid; i < end; i += stride) {\n        if (x[i] % 2 == 0) {\n            local_firstEvenIndex = i;\n            break;\n        }\n    }\n\n    __syncthreads();\n\n    if (tid == 0) {\n        atomicMax(firstEvenIndex, local_firstEvenIndex);\n    }\n}",False,True,,0,,,,,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n    // hint: use atomicMin to update firstEvenIndex\n},True,True,6.42e-08,1,0.0,True,False,1.800320009e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int threadId = blockIdx.x * blockDim.x + threadIdx.x;\n    if (threadId < N) {\n        if (x[threadId] % 2 == 0) {\n            *firstEvenIndex = threadId;\n            return;\n        }\n    }\n},True,True,7.12e-08,2,0.0,True,False,3.131519966e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,5.81e-08,3,0.0,True,False,1.532799974e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,5.73e-08,4,0.0,True,False,1.748479996e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    int stride = blockDim.x * gridDim.x;\n    for (; i < N; i += stride) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            break;\n        }\n    }\n},True,True,9.01e-08,5,0.0,True,False,3.758720011e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,8.21e-08,6,0.0,True,False,1.771839987e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,6.11e-08,7,0.0,True,False,1.694399994e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            return;\n        }\n    }\n},True,True,6.4e-08,8,0.0,True,False,3.007999994e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    int stride = blockDim.x * gridDim.x;\n    for (int i = tid; i < N; i += stride) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            return;\n        }\n    }\n},True,True,6.11e-08,9,0.0,True,False,4.113279991e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n\n    while (i < N) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            return;\n        }\n        i += stride;\n    }\n},True,True,5.69e-08,10,0.0,True,False,4.055040032e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n\n    for (; i < N; i += stride) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            break;\n        }\n    }\n},True,True,6.41e-08,11,0.0,True,False,4.103999995e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,5.92e-08,12,0.0,True,False,1.451519988e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,5.6e-08,13,0.0,True,False,1.725759991e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,9.42e-08,14,0.0,True,False,1.496320022e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            return;\n        }\n    }\n},True,True,9e-08,15,0.0,True,False,3.041920029e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] % 2 == 0) {\n            *firstEvenIndex = i;\n            return;\n        }\n    }\n},True,True,6.01e-08,16,0.0,True,False,3.096000012e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,6.41e-08,17,0.0,True,False,1.641599983e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int bid = blockIdx.x;\n    int stride = blockDim.x;\n\n    int i = bid * stride + tid;\n    if (i >= N) return;\n\n    if (x[i] % 2 == 0) {\n        *firstEvenIndex = i;\n        return;\n    }\n},True,True,5.82e-08,18,0.0,True,False,2.644480001e-05,,
"/* Find the index of the first even number in the vector x. Store it in firstEvenIndex.\n   Use CUDA to parallelize the search. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\n__global__ void findFirstEven(const int *x, size_t N, size_t *firstEvenIndex) {",38_search_find_the_first_even_number,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,7.42e-08,19,0.0,True,False,1.591680013e-05,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int even_index = -1;\n    int even_number = -1;\n    int even_number_count = 0;\n    int even_number_rank = 0;\n    int even_number_size = 0;\n    int even_number_index = 0;\n    int even_number_index_rank = 0;\n    int even_number_index_size = 0;\n    int even_number_index_count = 0;\n    int even_number_index_local = 0;\n    int even_number_index_local_rank = 0;\n    int even_number_index_local_size = 0;\n    int even_number_index_local_count = 0;\n    int even_number_index_local_max = 0;\n    int even_number_index_local_max_rank = 0;\n    int even_number_index_local_max_size = 0;\n    int even_number_index_local_max_count = 0;\n    int even_number_index_local_max_index = 0;\n    int even_number_index_local_max_index_rank = 0;\n    int even_number_index_local_max_index_size = 0;\n    int even_number_index_local_max_index_count = 0;\n    int even_number_index_local_max_index_local = 0;\n    int even_number_index_local_max_index_local_rank = 0;\n    int even_number_index_local_max_index_local_size = 0;\n    int even_number_index_local_max_index_local_count = 0;\n    int even_number_index_local_max_index_local_max = 0;\n    int even_number_index_local_max_index_local_max_rank = 0;\n    int even_number_index_local_max_index_local_max_size = 0;\n    int even_number_index_local_max_index_local_max_count = 0;\n    int even_number_index_local_max_index_local_max_index = 0;\n    int even_number_index_local_max_index_local_max_index_rank = 0;\n    int even_number_index_local_max_index_local_max_index_size = 0;\n    int even_number_index_local_max_index_local_max_index_count = 0;\n    int even_number_index_local_max_index_local_max_index_local = 0;\n    int even_number_index_local_max_index_local_max_index_local_rank = 0;\n    int even_number_index_local_max_index_local_max_index_local_size = 0;\n    int even_number_index_local_max_index_local_max_index_local_count = 0;\n    int even_number_index_local_max_index_local_max_index_local_max = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_rank = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_size = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_count = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index_rank = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index_size = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index_count = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index_local = 0;\n    int even_number_index_local_max_index_local_max_index_local_max_index_local_rank = 0;\n    int even_",False,False,,0,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// get the number of MPI processes\n  int nprocs;\n  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n\n  // get the rank of the current process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of threads\n  int nthreads = omp_get_max_threads();\n\n  // get the number of elements in x\n  size_t n = x.size();\n\n  // get the number of elements per thread\n  size_t n_per_thread = n / nprocs;\n\n  // get the number of elements per thread on the last process\n  size_t n_last_thread = n_per_thread + n % nprocs;\n\n  // get the start and end indices of the current thread\n  size_t start = rank * n_per_thread;\n  size_t end = start + n_per_thread;\n\n  // get the start and end indices of the last thread\n  size_t start_last = rank * n_last_thread;\n  size_t end_last = start_last + n_last_thread;\n\n  // get the start and end indices of the current thread on the last process\n  size_t start_last_thread = rank * n_per_thread + n % nprocs;\n  size_t end_last_thread = start_last_thread + n % nprocs;\n\n  // get the number of even numbers in the current thread\n  size_t n_even_thread = 0;\n\n  // get the number of even numbers in the last thread\n  size_t n_even_last_thread = 0;\n\n  // get the number of even numbers in the current thread on the last process\n  size_t n_even_last_thread_last_process = 0;\n\n  // get the number of even numbers in the current process\n  size_t n_even_process = 0;\n\n  // get the number of even numbers in the last process\n  size_t n_even_last_process = 0;\n\n  // get the index of the first even number in the current thread\n  size_t first_even_thread = 0;\n\n  // get the index of the first even number in the last thread\n  size_t first_even_last_thread = 0;\n\n  // get the index of the first even number in the current thread on the last process\n  size_t first_even_last_thread_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_process = 0;\n\n  // get the index of the first even number in the last process\n  size_t first_even_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread_last_process_last_thread = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread_last_process_last_thread_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread_last_process_last_thread_last_process_last_thread = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process_last_thread_last_process_last_thread_last_process_last_thread_last_process = 0;\n\n  // get the index of the first even number in the current process\n  size_t first_even_last_process_last_thread_last_process",False,False,,1,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int n = x.size();\n    int even_count = 0;\n    int even_index = -1;\n\n    // each rank has a complete copy of x\n    // rank 0 will return the result\n    if (rank == 0) {\n        for (int i = 0; i < n; i++) {\n            if (x[i] % 2 == 0) {\n                even_count++;\n                even_index = i;\n            }\n        }\n    }\n\n    // each rank will find the index of the first even number\n    // rank 0 will return the result\n    int local_even_index = -1;\n    int local_even_count = 0;\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        if (x[i] % 2 == 0) {\n            local_even_count++;\n            local_even_index = i;\n        }\n    }\n\n    // rank 0 will return the result\n    if (rank == 0) {\n        even_count = local_even_count;\n        even_index = local_even_index;\n    }\n\n    // gather the results from all ranks\n    MPI_Reduce(&even_count, &even_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    MPI_Reduce(&even_index, &even_index, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return even_index;\n}",True,True,,2,0.0,False,,,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,0.0,True,True,0.000757462,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,1.0,True,True,0.0007143721,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,2.0,True,True,0.0006667667,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,3.0,True,True,0.0007663979,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,4.0,True,True,0.0007377489,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,5.0,True,True,0.0007572656,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,6.0,True,True,0.0007391216,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,7.0,True,True,0.0008050211,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,8.0,True,True,0.0007748304,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,9.0,True,True,0.0008115516,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,10.0,True,True,0.00080513155,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,11.0,True,True,0.0007825012,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,12.0,True,True,0.0008290619,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,13.0,True,True,0.0007966762,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,14.0,True,True,0.006501794825,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,15.0,True,True,0.001534974125,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,16.0,True,True,0.001537380525,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,17.0,True,True,0.0015093995,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,18.0,True,True,0.001567169175,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,19.0,True,True,0.001578743275,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number in the local copy\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result = 0;\n  MPI_Reduce(&index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0002593531,3,20.0,True,True,0.001578069075,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // the number of even numbers in the vector\n    int n_even = 0;\n\n    // the index of the first even number in the vector\n    int first_even = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp_omp_omp = 0;\n\n    // the index of the first even number in the vector on each rank\n    int first_even_local_mpi_omp_omp_omp_omp_omp_omp_omp_omp_omp_omp = -1;\n\n    // the number of even numbers in the vector on each rank\n    int n_even_local_mpi_omp_omp_omp",False,False,,4,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t even_index = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int even_found = 0;\n    int even_found_global = 0;\n    int even_index_global = 0;\n    int even_index_local = 0;\n    int even_found_local = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x_size = x.size();\n    int x_size_local = x_size / size;\n    int x_size_remainder = x_size % size;\n    int x_size_local_remainder = x_size_local + x_size_remainder;\n    int x_size_local_remainder_start = x_size_local_remainder * rank;\n    int x_size_local_remainder_end = x_size_local_remainder * (rank + 1);\n    int x_size_local_remainder_end_start = x_size_local_remainder_end - x_size_remainder;\n    int x_size_local_remainder_end_end = x_size_local_remainder_end + x_size_remainder;\n    int x_size_local_remainder_end_start_start = x_size_local_remainder_end_start - x_size_remainder;\n    int x_size_local_remainder_end_start_end = x_size_local_remainder_end_start + x_size_remainder;\n    int x_size_local_remainder_end_end_start = x_size_local_remainder_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end = x_size_local_remainder_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_start = x_size_local_remainder_end_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end_end = x_size_local_remainder_end_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_start = x_size_local_remainder_end_end_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end = x_size_local_remainder_end_end_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_start = x_size_local_remainder_end_end_end_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end = x_size_local_remainder_end_end_end_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end_start = x_size_local_remainder_end_end_end_end_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end_end = x_size_local_remainder_end_end_end_end_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end_end_start = x_size_local_remainder_end_end_end_end_end_end_end - x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end_end_end = x_size_local_remainder_end_end_end_end_end_end_end + x_size_remainder;\n    int x_size_local_remainder_end_end_end_end_end_end_end_end_start = x_size_local_remainder_end_end_end_end_end_end_end_end - x",False,False,,5,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // each rank has a complete copy of x\n    std::vector<int> x_local(x);\n\n    // find the first even number in the local vector\n    size_t first_even_index = 0;\n    for (size_t i = 0; i < x_local.size(); ++i) {\n        if (x_local[i] % 2 == 0) {\n            first_even_index = i;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    int first_even_index_global;\n    MPI_Bcast(&first_even_index, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    return first_even_index_global;\n}",True,False,0.0002597597,6,0.0,True,False,0.0007134223,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> x_local = x;\n\n  // find the index of the first even number in x_local\n  size_t result = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x_local.size(); i++) {\n    if (x_local[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result_global;\n  MPI_Reduce(&result, &result_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result_global;\n}",False,True,,7,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t result = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for\n  for (size_t i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      result = i;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return result;\n}",False,True,,8,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the first even number\n    int local_result = -1;\n    #pragma omp parallel for\n    for (size_t i = 0; i < local_x.size(); i++) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",False,True,,9,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,0.0,True,True,0.0007129638,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,1.0,True,True,0.000665604,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,2.0,True,True,0.0007585955,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,3.0,True,True,0.0007506478,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,4.0,True,True,0.0007708088,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,5.0,True,True,0.0007678851,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,6.0,True,True,0.0007075569,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,7.0,True,True,0.00079056765,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,8.0,True,True,0.00080619055,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,9.0,True,True,0.0008201854,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,10.0,True,True,0.0008038084,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,11.0,True,True,0.0008008545,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,12.0,True,True,0.00080875015,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,13.0,True,True,0.00078640975,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,14.0,True,True,0.0035345585,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,15.0,True,True,0.00154740775,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,16.0,True,True,0.001551166025,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,17.0,True,True,0.001546068275,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,18.0,True,True,0.00157872125,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,19.0,True,True,0.00158917285,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // find the index of the first even number in the local copy of x\n    size_t local_result = 0;\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        if (local_x[i] % 2 == 0) {\n            local_result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result = -1;\n    MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,False,0.0002593431,10,20.0,True,True,0.001549897,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // divide the vector into chunks\n    int chunkSize = x.size() / size;\n    std::vector<int> chunk(chunkSize);\n    for (int i = 0; i < chunkSize; i++) {\n        chunk[i] = x[i + rank * chunkSize];\n    }\n\n    // find the index of the first even number in the chunk\n    int result = -1;\n    #pragma omp parallel for\n    for (int i = 0; i < chunk.size(); i++) {\n        if (chunk[i] % 2 == 0) {\n            result = i;\n            break;\n        }\n    }\n\n    // gather the result from all ranks\n    int result_global;\n    MPI_Reduce(&result, &result_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the result\n    return result_global;\n}",False,True,,11,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // number of even numbers in x\n    int n_even = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank0 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank1 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank2 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank3 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank4 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank5 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank6 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank7 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank8 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank9 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank10 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank11 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank12 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank13 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank14 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank15 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank16 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank17 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank18 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank19 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank20 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank21 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank22 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank23 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank24 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank25 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank26 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank27 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank28 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank29 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank30 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank31 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank32 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank33 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank34 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank35 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank36 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank37 = 0;\n\n    // number of even numbers in x on rank 0\n    int n_even_rank38 = 0;\n\n    // number of",False,False,,12,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int even_count = 0;\n    int even_index = 0;\n\n    // count the number of even numbers in the vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            even_count++;\n            even_index = i;\n        }\n    }\n\n    // find the number of even numbers in the vector\n    int even_count_total = 0;\n    MPI_Reduce(&even_count, &even_count_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // find the index of the first even number in the vector\n    int even_index_total = 0;\n    MPI_Reduce(&even_index, &even_index_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // find the index of the first even number in the vector\n    int first_even_index = 0;\n    if (rank == 0) {\n        first_even_index = even_index_total / size;\n    }\n\n    return first_even_index;\n}",True,False,0.0002601056,13,0.0,True,False,0.0019479598,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t result = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // each rank has a complete copy of x\n    // find the first even number in x\n    // send the result to rank 0\n    // rank 0 will return the result\n    int even_found = 0;\n    int even_index = -1;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            even_found = 1;\n            even_index = i;\n            break;\n        }\n    }\n\n    MPI_Reduce(&even_found, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n    MPI_Reduce(&even_index, &result, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    return result;\n}",False,True,,14,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// get the number of threads\n    int num_threads = omp_get_max_threads();\n    // get the number of processes\n    int num_procs;\n    MPI_Comm_size(MPI_COMM_WORLD, &num_procs);\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    // get the number of elements in the vector\n    int n = x.size();\n    // get the number of elements each process will have\n    int n_local = n / num_procs;\n    // get the number of elements that will be left over\n    int n_remainder = n % num_procs;\n    // get the starting index of the local vector\n    int start = rank * n_local;\n    // get the ending index of the local vector\n    int end = start + n_local;\n    // if the process has a remainder, add it to the end index\n    if (rank < n_remainder) {\n        end += 1;\n    }\n    // initialize the result to -1\n    int result = -1;\n    // get the number of even numbers in the local vector\n    int num_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_even_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_even_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd_even_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even_even_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_even_even_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_odd_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd_odd_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even_odd_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_even_odd_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_even_even_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd_even_even_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even_even_even_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_even_even_even_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_odd_odd_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_odd_odd_odd_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_even_odd_odd_even = 0;\n    // get the number of odd numbers in the local vector\n    int num_local_result_even_odd_odd_odd = 0;\n    // get the number of even numbers in the local vector\n    int num_local_result_odd_even_even_even_even = 0;\n    // get the number of odd numbers in",False,False,,15,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n    size_t result = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int n = x.size();\n    int chunk = n / size;\n    int start = rank * chunk;\n    int end = start + chunk;\n    if (rank == size - 1) {\n        end = n;\n    }\n    int even_count = 0;\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            even_count++;\n            if (rank == 0) {\n                result = i;\n            }\n        }\n    }\n    MPI_Reduce(&even_count, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    return result;\n}",True,False,0.0002602641,16,0.0,True,False,0.0012983214,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int even_count = 0;\n    int even_index = 0;\n    int even_found = 0;\n    int even_found_index = 0;\n    int even_found_rank = 0;\n    int even_found_size = 0;\n    int even_found_count = 0;\n    int even_found_index_rank = 0;\n    int even_found_index_size = 0;\n    int even_found_index_count = 0;\n    int even_found_index_rank_size = 0;\n    int even_found_index_rank_count = 0;\n    int even_found_index_rank_size_count = 0;\n    int even_found_index_rank_size_count_rank = 0;\n    int even_found_index_rank_size_count_size = 0;\n    int even_found_index_rank_size_count_count = 0;\n    int even_found_index_rank_size_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count_count = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count_count_rank = 0;\n    int even_found_index_rank_size_count_count_count_count_count_count_count_count_count_count_size = 0;\n    int even_found_index_rank_size_count_count_count_count",False,False,,17,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,0.0,True,True,0.0007657813,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,1.0,True,True,0.0007786334,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,2.0,True,True,0.0007542697,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,3.0,True,True,0.0007613682,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,4.0,True,True,0.0007784632,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,5.0,True,True,0.0007302036,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,6.0,True,True,0.0007366507,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,7.0,True,True,0.00078319875,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,8.0,True,True,0.0008031296,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,9.0,True,True,0.0007747139,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,10.0,True,True,0.0007748942,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,11.0,True,True,0.00079215555,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,12.0,True,True,0.00080243585,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,13.0,True,True,0.0007967265,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,14.0,True,True,0.00747266765,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,15.0,True,True,0.001522891625,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,16.0,True,True,0.00151750905,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,17.0,True,True,0.00153838995,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,18.0,True,True,0.001579596325,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,19.0,True,True,0.001590804675,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // every rank has a complete copy of x\n  std::vector<int> local_x = x;\n\n  // find the index of the first even number\n  size_t index = 0;\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] % 2 == 0) {\n      index = i;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  int global_index;\n  MPI_Reduce(&index, &global_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return global_index;\n}",True,False,0.0002595045,18,20.0,True,True,0.001530322775,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI and OpenMP to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",38_search_find_the_first_even_number,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n    size_t even_index = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        int even_count = 0;\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] % 2 == 0) {\n                even_count++;\n            }\n        }\n        even_index = even_count;\n    }\n\n    int even_count = 0;\n    int even_index_local = 0;\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            even_count++;\n        }\n    }\n    even_index_local = even_count;\n\n    MPI_Reduce(&even_index_local, &even_index, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return even_index;\n}",True,False,0.0002601759,19,0.0,True,False,0.0004995304,1.0,1.0
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078475541,0,0.0,True,False,7.13e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(int i, bool& update) { update = (x(i) == target); },\n      Kokkos::LOR<bool>(result));\n  return result();\n}",False,True,,1,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(int i, bool& result_local) {\n        result_local = (x(i) == target);\n      },\n      result);\n  return result();\n}",False,True,,2,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"");\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.size()),\n      KOKKOS_LAMBDA(int i, bool& result) { result = x(i) == target; },\n      result);\n  return result();\n}",False,True,,3,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078307423,4,0.0,True,False,4.52e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078259155,5,0.0,True,False,5.71e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"");\n  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n                          KOKKOS_LAMBDA(int i, bool& result) {\n    result = result || (x(i) == target);\n  }, result);\n  return result();\n}",False,True,,6,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078401462,7,0.0,True,False,3.9e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078329695,8,0.0,True,False,6.31e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.size()),\n      KOKKOS_LAMBDA(int i, bool& result_local) {\n        result_local = (x(i) == target);\n      },\n      result);\n  return result();\n}",False,True,,9,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078256917,10,0.0,True,False,5.62e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078298134,11,0.0,True,False,3.9e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n                          KOKKOS_LAMBDA(const int i, bool& update) {\n                            update = update || (x(i) == target);\n                          },\n                          result);\n  return result(0);\n}",False,True,,12,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078239299,13,0.0,True,False,9.01e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(int i, bool& result_local) {\n        result_local = (x(i) == target);\n      },\n      result);\n  return result();\n}",False,True,,14,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(int i, bool& result_local) {\n        result_local = (x(i) == target);\n      },\n      result);\n  return result(0);\n}",False,True,,15,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078271847,16,0.0,True,False,4e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(int i, bool& lresult) {\n        if (x(i) == target) {\n          lresult = true;\n        }\n      },\n      result);\n  return result();\n}",False,True,,17,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},True,True,0.0078482442,18,0.0,True,False,5.3e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,0.0,True,True,0.0347585096,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,1.0,True,True,0.0220853752,2.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,2.0,True,True,0.0157127806,4.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,3.0,True,True,0.0125124334,8.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,4.0,True,True,0.0110147495,16.0,
"#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<int*> &x, int target) {",36_search_check_if_array_contains_value,search,cpp,kokkos,0.2,0.95,True,1024,True,"int n = x.extent(0);\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", n);\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) { result(i) = false; });\n  Kokkos::parallel_for(n, KOKKOS_LAMBDA(int i) {\n    if (x(i) == target) {\n      result(i) = true;\n    }\n  });\n  Kokkos::fence();\n  bool result_host = false;\n  for (int i = 0; i < n; i++) {\n    if (result(i)) {\n      result_host = true;\n    }\n  }\n  return result_host;\n}",True,True,0.0080051044,19,5.0,True,True,0.0102126864,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,0.0,True,True,0.00026280339807,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,1.0,True,True,0.0001794825308,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,2.0,True,True,0.00011120426934,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,3.0,True,True,9.070546366e-05,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,4.0,True,True,0.00011826539412,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,5.0,True,True,0.0001453975914,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n\n  return found;\n},True,True,0.00032540285029,0,6.0,True,True,0.00022556707263,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,0.0,True,True,0.0012996942969,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,1.0,True,True,0.00078955793288,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,2.0,True,True,0.00042613730766,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,3.0,True,True,0.00023290109821,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,4.0,True,True,0.00023733363487,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,5.0,True,True,0.00035444179084,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n    #pragma omp parallel for reduction(|:result)\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            result = true;\n        }\n    }\n    return result;\n},True,True,0.00032697075512,1,6.0,True,True,0.00050167855807,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,0.0,True,True,0.00129956412129,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,1.0,True,True,0.00080346830655,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,2.0,True,True,0.0004249030957,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,3.0,True,True,0.00023231976666,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,4.0,True,True,0.00024450996425,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,5.0,True,True,0.00036456577946,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032636895776,2,6.0,True,True,0.00051583696622,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n},False,True,,3,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,0.0,True,True,0.00130015113391,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,1.0,True,True,0.00080489974935,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,2.0,True,True,0.00042582980823,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,3.0,True,True,0.00023244414479,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,4.0,True,True,0.00024778009392,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,5.0,True,True,0.00035621502902,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n    }\n  }\n  return found;\n},True,True,0.00032630874775,4,6.0,True,True,0.00051461791154,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static)\n    for (int i = 0; i < num_threads; i++) {\n        start = i * chunk_size;\n        end = (i == num_threads - 1)? n : (i + 1) * chunk_size;\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            break;\n        }\n    }\n    return found;\n},False,True,,5,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,0.0,True,True,0.00026886556298,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,1.0,True,True,0.00018510608934,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,2.0,True,True,0.00013792838436,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,3.0,True,True,9.64843668e-05,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,4.0,True,True,0.00013061079662,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,5.0,True,True,0.00013830398675,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n    int start = 0;\n    int end = 0;\n    bool found = false;\n    #pragma omp parallel for schedule(static) num_threads(num_threads)\n    for (int i = 0; i < num_threads; i++) {\n        if (i < remainder) {\n            end = start + chunk_size + 1;\n        } else {\n            end = start + chunk_size;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                found = true;\n                break;\n            }\n        }\n        start = end;\n    }\n    return found;\n},True,True,0.00032536289655,6,6.0,True,True,0.00025058742613,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n},False,True,,7,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,0.0,True,True,0.00018907065969,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,1.0,True,True,0.00015930552036,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,2.0,True,True,0.00016633088235,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,3.0,True,True,0.00016741598956,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,4.0,True,True,0.00022425458301,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,5.0,True,True,0.00035077282228,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    int n = x.size();\n    int sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for(int i = 0; i < n; i++){\n        if(x[i] == target){\n            sum++;\n        }\n    }\n    if(sum == 0){\n        return false;\n    }\n    else{\n        return true;\n    }\n},True,True,0.00032580280676,8,6.0,True,True,0.00049146213569,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,0.0,True,True,0.0002631520154,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,1.0,True,True,0.00018292088062,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,2.0,True,True,0.00013710863423,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,3.0,True,True,9.859337006e-05,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,4.0,True,True,0.00012637660839,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,5.0,True,True,0.00014166142792,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool result = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:result)\n  for (int i = 0; i < num_threads; i++) {\n    if (i == num_threads - 1) {\n      end = start + chunk_size + remainder;\n    } else {\n      end = start + chunk_size;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        result = true;\n        break;\n      }\n    }\n    start = end;\n  }\n  return result;\n},True,True,0.00032552527264,9,6.0,True,True,0.00025718351826,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = chunk_size;\n  bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < num_threads; i++) {\n    if (found) {\n      break;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    start = end;\n    end = end + chunk_size;\n  }\n  return found;\n},False,True,,10,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,0.0,True,True,0.00130032550078,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,1.0,True,True,0.00081143674906,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,2.0,True,True,0.00042787543498,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,3.0,True,True,0.00023362531792,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,4.0,True,True,0.00026976289228,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,5.0,True,True,0.00036218229216,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            found = true;\n        }\n    }\n    return found;\n},True,True,0.0003253959585,11,6.0,True,True,0.00051670782268,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n    if (found) {\n      break;\n    }\n  }\n  return found;\n},False,True,,12,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,0.0,True,True,0.00026962507982,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,1.0,True,True,0.0001929999562,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,2.0,True,True,0.0001161434222,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,3.0,True,True,0.00010102200322,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,4.0,True,True,0.00015150192194,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,5.0,True,True,0.00022490702104,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int remainder = n % num_threads;\n\n    bool result = false;\n\n    #pragma omp parallel for schedule(static) reduction(|:result)\n    for (int i = 0; i < num_threads; i++) {\n        int start = i * chunk_size;\n        int end = (i + 1) * chunk_size;\n        if (i == num_threads - 1) {\n            end += remainder;\n        }\n        for (int j = start; j < end; j++) {\n            if (x[j] == target) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    return result;\n},True,True,0.00032607817557,13,6.0,True,True,0.00034703081474,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,0.0,True,True,0.00026666137855,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,1.0,True,True,0.00018391977064,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,2.0,True,True,0.00010780449957,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,3.0,True,True,9.432737716e-05,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,4.0,True,True,0.0001572445035,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,5.0,True,True,0.0002226998331,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int remainder = n % num_threads;\n  int start = 0;\n  int end = 0;\n  bool found = false;\n  #pragma omp parallel for schedule(static) num_threads(num_threads) reduction(|:found)\n  for (int i = 0; i < num_threads; i++) {\n    start = i * chunk_size;\n    end = start + chunk_size;\n    if (i == num_threads - 1) {\n      end += remainder;\n    }\n    for (int j = start; j < end; j++) {\n      if (x[j] == target) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n},True,True,0.00032653710805,14,6.0,True,True,0.00034539371263,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool result = false;\n\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  return result;\n},False,True,,15,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  bool found = false;\n\n#pragma omp parallel for\n  for (int i = 0; i < n; ++i) {\n    if (x[i] == target) {\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n},False,True,,16,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,0.0,True,True,0.00026746017393,1.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,1.0,True,True,0.0001957652159,2.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,2.0,True,True,0.00013068390545,4.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,3.0,True,True,0.00010114223696,8.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,4.0,True,True,0.00015551340766,16.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,5.0,True,True,0.00023294631392,32.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int num_threads = omp_get_max_threads();\n  int chunk_size = n / num_threads;\n  int start = 0;\n  int end = 0;\n  int i = 0;\n  bool found = false;\n\n  #pragma omp parallel num_threads(num_threads)\n  {\n    #pragma omp for schedule(static)\n    for (i = 0; i < num_threads; i++) {\n      start = i * chunk_size;\n      end = (i + 1) * chunk_size;\n      for (int j = start; j < end; j++) {\n        if (x[j] == target) {\n          found = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return found;\n},True,True,0.00032643799204,17,6.0,True,True,0.0003645636607,64.0,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n},False,True,,18,,,,,,
"#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int num_threads = omp_get_max_threads();\n    int chunk_size = n / num_threads;\n    int start = 0;\n    int end = chunk_size;\n    int thread_id = 0;\n    bool found = false;\n    #pragma omp parallel shared(found) private(thread_id)\n    {\n        thread_id = omp_get_thread_num();\n        #pragma omp for schedule(static)\n        for (int i = start; i < end; i++) {\n            if (x[i] == target) {\n                found = true;\n                break;\n            }\n        }\n    }\n    return found;\n},False,True,,19,,,,,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003271127,0,0.0,True,True,0.000263621,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n},True,True,0.0003274644,1,0.0,True,True,0.0002719528,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003262017,2,0.0,True,True,0.0002663911,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (auto i : x) {\n    if (i == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003276556,3,0.0,True,True,0.0002759162,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), target)!= x.end();\n}",True,True,0.0003930009,4,0.0,True,True,0.0001889796,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (auto const& i : x) {\n    if (i == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003277183,5,0.0,True,True,0.0002770924,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,// TODO: implement this function\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n},True,True,0.0003276865,6,0.0,True,True,0.0002597986,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n},True,True,0.0003264724,7,0.0,True,True,0.0002685513,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003265276,8,0.0,True,True,0.0002709559,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (auto const& i : x) {\n    if (i == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003283928,9,0.0,True,True,0.0002727572,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), target)!= x.end();\n}",True,True,0.0003889241,10,0.0,True,True,0.000195263,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003261277,11,0.0,True,True,0.000265899,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003267276,12,0.0,True,True,0.0002723753,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003287176,13,0.0,True,True,0.000276028,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003269131,14,0.0,True,True,0.0002659661,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n},True,True,0.0003275501,15,0.0,True,True,0.0002729896,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (auto i : x) {\n    if (i == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003268049,16,0.0,True,True,0.0002651707,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (auto const& i : x) {\n    if (i == target) {\n      return true;\n    }\n  }\n  return false;\n},True,True,0.0003272193,17,0.0,True,True,0.000275413,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n},True,True,0.0003264342,18,0.0,True,True,0.000267861,,
"/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), target)!= x.end();\n}",True,True,0.000389971,19,0.0,True,True,0.000188365,,
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,0.0,True,True,0.0002738626,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,1.0,True,True,0.00028459395,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,2.0,True,True,0.00028435795,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,3.0,True,True,0.0004372222125,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,4.0,True,True,0.000335563425,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,5.0,True,True,0.0004229784,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,6.0,True,True,0.00041305201875,,64.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,7.0,True,True,0.00038319674922,,128.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,8.0,True,True,0.00125637731758,,256.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_result = -1;\n  if (rank == 0) {\n    local_target = target;\n  }\n  MPI_Bcast(&local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n  MPI_Bcast(&local_result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  return local_result == 1;\n}",True,True,0.0003272762,0,9.0,True,True,0.00141751724961,,512.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,0.0,True,True,0.0007094604,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,1.0,True,True,0.00043823605,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,2.0,True,True,0.00028090605,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,3.0,True,True,0.000200174925,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,4.0,True,True,0.00012906093125,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // calculate the number of elements per rank\n  int n_per_rank = n / size;\n\n  // calculate the number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // calculate the starting index of the current rank\n  int start = n_per_rank * rank;\n\n  // calculate the end index of the current rank\n  int end = n_per_rank * (rank + 1);\n\n  // if the current rank is the last rank, add the number of elements in the last rank\n  if (rank == size - 1) {\n    end += n_last_rank;\n  }\n\n  // create a vector of the elements in the current rank\n  std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n  // search for the target in the local vector\n  for (int i = 0; i < local_x.size(); i++) {\n    if (local_x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003254049,1,5.0,True,False,4.080120625e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,0.0,True,True,0.0002659291,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,1.0,True,True,0.0001450305,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,2.0,True,True,7.663815e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,3.0,True,True,5.9788325e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,4.0,True,True,2.50291625e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003259999,2,5.0,True,False,1.28313875e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size = x.size();\n  int rank = 0;\n  int result = 0;\n\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int start = rank * size / 2;\n  int end = (rank + 1) * size / 2;\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      result = 1;\n      break;\n    }\n  }\n\n  int global_result = 0;\n  MPI_Reduce(&result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result == 1;\n}",True,True,0.0003247473,3,0.0,True,False,1.1592e-06,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,0.0,True,True,0.0002686451,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,1.0,True,True,0.0001456196,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,2.0,True,True,7.648335e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,3.0,True,True,5.60563e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,4.0,True,True,3.244299375e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = (rank + 1) * chunk_size;\n\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003261736,4,5.0,True,False,1.237105625e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will search\n  int n_local = n / world_size;\n\n  // get the starting index of the process in the vector\n  int start = n_local * world_rank;\n\n  // get the ending index of the process in the vector\n  int end = start + n_local;\n\n  // search the vector in the process\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the process did not find the target, send a message to the other processes\n  // that they should search their own vector\n  MPI_Request request;\n  MPI_Status status;\n  if (world_rank!= 0) {\n    MPI_Isend(&target, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &request);\n  }\n\n  // if the process is not rank 0, receive a message from the process with rank 0\n  // that they should search their own vector\n  if (world_rank!= 0) {\n    MPI_Recv(&target, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);\n  }\n\n  // if the process is rank 0, search the vector in the process\n  if (world_rank == 0) {\n    for (int i = 0; i < n; i++) {\n      if (x[i] == target) {\n        return true;\n      }\n    }\n  }\n\n  // return false if the process did not find the target\n  return false;\n}",True,True,0.0003257692,5,0.0,True,True,0.0005353973,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will search\n  int n_local = n / world_size;\n\n  // get the starting index of the process in the vector\n  int start = n_local * world_rank;\n\n  // get the ending index of the process in the vector\n  int end = start + n_local;\n\n  // search the vector in the process\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the process did not find the target, send a message to the other processes\n  // that they should search their own vector\n  MPI_Request request;\n  MPI_Status status;\n  if (world_rank!= 0) {\n    MPI_Isend(&target, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &request);\n  }\n\n  // if the process is not rank 0, receive a message from the process with rank 0\n  // that they should search their own vector\n  if (world_rank!= 0) {\n    MPI_Recv(&target, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);\n  }\n\n  // if the process is rank 0, search the vector in the process\n  if (world_rank == 0) {\n    for (int i = 0; i < n; i++) {\n      if (x[i] == target) {\n        return true;\n      }\n    }\n  }\n\n  // return false if the process did not find the target\n  return false;\n}",True,True,0.0003257692,5,1.0,False,,,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,0.0,True,True,0.0002707931,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,1.0,True,True,0.0001440403,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,2.0,True,True,7.56578e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,3.0,True,True,5.81233e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,4.0,True,True,3.490779375e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003258054,6,5.0,True,False,1.268073437e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,0.0,True,True,0.0002867238,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,1.0,True,True,0.00014588515,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,2.0,True,True,7.2694375e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,3.0,True,True,5.4731675e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,4.0,True,True,2.671209375e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in the vector that each rank will search\n  int num_elements = x.size() / size;\n  // compute the number of elements that rank 0 will search\n  int num_elements_rank0 = x.size() % size;\n\n  // compute the start and end indices of the elements that rank `rank` will search\n  int start = rank * num_elements;\n  int end = (rank + 1) * num_elements;\n  if (rank == 0) {\n    end += num_elements_rank0;\n  }\n\n  // search for the target in the elements that rank `rank` will search\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the target is not found, return false\n  return false;\n}",True,True,0.0003277226,7,5.0,True,False,1.385379063e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_result = 0;\n    int local_size = x.size();\n\n    MPI_Scatter(&local_target, 1, MPI_INT, &local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Scatter(&local_size, 1, MPI_INT, &local_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (x[i] == local_target) {\n            local_result = 1;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return global_result == 1;\n}",True,True,0.0003273013,8,0.0,True,True,0.0002706365,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_result = 0;\n    int local_size = x.size();\n\n    MPI_Scatter(&local_target, 1, MPI_INT, &local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Scatter(&local_size, 1, MPI_INT, &local_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (x[i] == local_target) {\n            local_result = 1;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return global_result == 1;\n}",True,True,0.0003273013,8,1.0,True,True,0.00014441505,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_result = 0;\n    int local_size = x.size();\n\n    MPI_Scatter(&local_target, 1, MPI_INT, &local_target, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Scatter(&local_size, 1, MPI_INT, &local_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (x[i] == local_target) {\n            local_result = 1;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return global_result == 1;\n}",True,True,0.0003273013,8,2.0,False,,,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,0.0,True,True,0.0002687342,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,1.0,True,True,0.0002740848,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,2.0,True,True,0.0002781686,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,3.0,True,True,0.0004329607375,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,4.0,True,True,0.00032880114375,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,5.0,True,True,0.0004053723125,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,6.0,True,True,0.00048932331562,,64.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,7.0,True,True,0.00053328061953,,128.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,8.0,True,True,0.00103296479961,,256.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_found = 0;\n\n    // find the target in the local vector\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_found = 1;\n            break;\n        }\n    }\n\n    // broadcast the result to all ranks\n    MPI_Bcast(&local_found, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // return the result on rank 0\n    if (rank == 0) {\n        return local_found;\n    } else {\n        return false;\n    }\n}",True,True,0.0003263043,9,9.0,True,True,0.0013593471082,,512.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,0.0,True,True,0.0002665282,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,1.0,True,True,0.0001385254,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,2.0,True,True,7.5687375e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,3.0,True,True,5.40225375e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,4.0,True,True,3.72203125e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements per rank\n  int elements_per_rank = x.size() / size;\n\n  // calculate the number of elements that are left over\n  int elements_left_over = x.size() % size;\n\n  // calculate the start and end index of the elements that this rank has\n  int start = rank * elements_per_rank;\n  int end = start + elements_per_rank;\n\n  // if this is the last rank, then add the elements left over\n  if (rank == size - 1) {\n    end += elements_left_over;\n  }\n\n  // search for the target in the elements that this rank has\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, then the target was not found\n  return false;\n}",True,True,0.0003267144,10,5.0,True,False,1.289179375e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,0.0,True,True,0.000268584,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,1.0,True,True,0.00014218965,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,2.0,True,True,7.5859225e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,3.0,True,True,5.5102675e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,4.0,True,True,4.802903125e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vector into chunks\n  int chunk_size = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if we get here, the value was not found\n  return false;\n}",True,True,0.0003250803,11,5.0,True,False,1.257053437e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_result = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result == 1;\n}",True,True,0.0003253966,12,0.0,True,True,0.0002678576,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_result = 0;\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result == 1;\n}",True,True,0.0003253966,12,1.0,True,False,0.00028049905,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,0.0,True,True,0.0002732515,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,1.0,True,True,0.0001405352,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,2.0,True,True,6.9482875e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,3.0,True,True,5.8369225e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,4.0,True,True,3.5267375e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int n = x.size();\n  int chunk_size = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank < remainder) {\n    end++;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003293551,13,5.0,True,False,1.22247125e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,0.0,True,True,0.0002657847,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,1.0,True,True,0.00013919655,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,2.0,True,True,7.230645e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,3.0,True,True,5.583245e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,4.0,True,True,2.490595625e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003270137,14,5.0,True,False,1.243931875e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_target = target;\n    int local_result = 0;\n\n    // find the local target\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            local_target = i;\n            break;\n        }\n    }\n\n    // find the local result\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == local_target) {\n            local_result = 1;\n            break;\n        }\n    }\n\n    int global_result = 0;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    return global_result == 1;\n}",True,True,0.0003244201,15,0.0,True,False,0.0008168187,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements in each subarray\n  int n_per_rank = n / size;\n\n  // number of elements in the last subarray\n  int n_last = n % size;\n\n  // rank of the last subarray\n  int rank_last = size - 1;\n\n  // rank of the first subarray\n  int rank_first = 0;\n\n  // number of elements in the first subarray\n  int n_first = n_per_rank + n_last;\n\n  // number of elements in the last subarray\n  int n_last_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank_rank_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank_rank_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank_rank_rank_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank_rank_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank_rank_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank_rank_rank_rank_rank = rank_first;\n\n  // number of elements in the first subarray\n  int n_first_rank_rank_rank_rank_rank_rank_rank = n_per_rank;\n\n  // number of elements in the last subarray\n  int n_last_rank_rank_rank_rank_rank_rank_rank_rank = n_last;\n\n  // rank of the last subarray\n  int rank_last_rank_rank_rank_rank_rank_rank_rank_rank = rank_last;\n\n  // rank of the first subarray\n  int rank_first_rank_rank_rank_rank_rank_rank_rank_",False,True,,16,,,,,,
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // divide the vector into equal parts\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  // get the start and end index of the chunk\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  // if the remainder is not zero, add the remainder to the end index\n  if (remainder!= 0) {\n    end += remainder;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the chunk does not contain the target, search in the next chunk\n  if (rank < size - 1) {\n    return contains(x, target);\n  }\n\n  // if the chunk does not contain the target, return false\n  return false;\n}",True,True,0.0003295024,17,0.0,True,True,0.0002706288,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // divide the vector into equal parts\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  // get the start and end index of the chunk\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  // if the remainder is not zero, add the remainder to the end index\n  if (remainder!= 0) {\n    end += remainder;\n  }\n\n  // search in the chunk\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  // if the chunk does not contain the target, search in the next chunk\n  if (rank < size - 1) {\n    return contains(x, target);\n  }\n\n  // if the chunk does not contain the target, return false\n  return false;\n}",True,True,0.0003295024,17,1.0,False,,,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,0.0,True,True,0.0002687702,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,1.0,True,True,0.00014300785,,2.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,2.0,True,True,7.759965e-05,,4.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,3.0,True,True,5.20244e-05,,8.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,4.0,True,True,2.81525125e-05,,16.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements each rank will search\n  int elements_per_rank = x.size() / size;\n\n  // compute the number of elements that will be left over\n  int elements_left_over = x.size() % size;\n\n  // compute the starting index of the elements that this rank will search\n  int start_index = rank * elements_per_rank;\n\n  // compute the ending index of the elements that this rank will search\n  int end_index = (rank + 1) * elements_per_rank;\n\n  // if this rank is the last rank, then it will search the remaining elements\n  if (rank == size - 1) {\n    end_index += elements_left_over;\n  }\n\n  // search the elements that this rank will search\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,0.0003249695,18,5.0,True,False,1.226540625e-05,,32.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size();\n  int local_target = target;\n\n  int local_result = 0;\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result == 1;\n  } else {\n    return false;\n  }\n}",True,True,0.0003442,19,0.0,True,True,0.0002838306,,1.0
"#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size();\n  int local_target = target;\n\n  int local_result = 0;\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result == 1;\n  } else {\n    return false;\n  }\n}",True,True,0.0003442,19,1.0,True,False,0.00028128985,,2.0
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    if (i < N) {\n        if (x[i] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003268961,0,0.0,True,True,1.464639986e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0003306192,1,0.0,True,False,9.57760001e-06,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n  int gid = blockIdx.x * blockDim.x + threadIdx.x;\n  int stride = blockDim.x * gridDim.x;\n  for (int i = gid; i < N; i += stride) {\n    if (x[i] == target) {\n      *found = true;\n      return;\n    }\n  }\n},True,True,0.0003310659,2,0.0,True,True,1.543680001e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003304274,3,0.0,True,True,1.464e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        if (x[tid] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003339262,4,0.0,True,True,1.323200008e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (gid < N) {\n        if (x[gid] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003319317,5,0.0,True,True,1.416319981e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n\n    for (int i = gid; i < N; i += stride) {\n        if (x[i] == target) {\n            *found = true;\n            return;\n        }\n    }\n},True,True,0.0003301594,6,0.0,True,True,1.573759997e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003322059,7,0.0,True,True,1.395839984e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int stride = blockDim.x;\n    int i = blockIdx.x * stride + tid;\n    int found_local = 0;\n    while (i < N) {\n        if (x[i] == target) {\n            found_local = 1;\n            break;\n        }\n        i += stride;\n    }\n    __syncthreads();\n    if (tid == 0) {\n        *found = found_local;\n    }\n},True,True,0.0003319623,8,0.0,True,False,0.00262666561604,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n  if (i < N) {\n    if (x[i] == target) {\n      *found = true;\n    }\n  }\n},True,True,0.0003332908,9,0.0,True,True,1.448640004e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        if (x[tid] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003325926,10,0.0,True,True,1.484160004e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + threadIdx.x;\n    int stride = blockDim.x * gridDim.x;\n\n    for (int i = gid; i < N; i += stride) {\n        if (x[i] == target) {\n            *found = true;\n            return;\n        }\n    }\n},True,True,0.0003300799,11,0.0,True,True,1.541759996e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    if (gid < N) {\n        if (x[gid] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.000330109,12,0.0,True,True,1.394240009e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0003313895,13,0.0,True,False,8.18560007e-06,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n\n    for (int i = gid; i < N; i += stride) {\n        if (x[i] == target) {\n            *found = true;\n            return;\n        }\n    }\n},True,True,0.0003331044,14,0.0,True,True,1.522879992e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0003294194,15,0.0,True,False,9.89440009e-06,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0003281724,16,0.0,True,False,9.96479997e-06,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    if (i < N) {\n        if (x[i] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003320858,17,0.0,True,True,1.4432e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    if (gid < N) {\n        if (x[gid] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003283548,18,0.0,True,True,1.35999999e-05,,
"/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {",36_search_check_if_array_contains_value,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (x[i] == target) {\n            *found = true;\n        }\n    }\n},True,True,0.0003272895,19,0.0,True,True,1.45312001e-05,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int start = rank * local_size;\n    int end = start + local_size;\n\n    std::vector<int> local_x(x.begin() + start, x.begin() + end);\n\n    bool result = false;\n    #pragma omp parallel for\n    for (int i = 0; i < local_x.size(); i++) {\n        if (local_x[i] == target) {\n            result = true;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&result, &global_result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    return global_result;\n}",False,True,,0,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int start = local_size * rank;\n    int end = start + local_size;\n\n    bool result = false;\n    #pragma omp parallel for\n    for (int i = start; i < end; i++) {\n        if (x[i] == target) {\n            result = true;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&result, &global_result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n    return global_result;\n}",False,True,,1,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  bool found = false;\n  #pragma omp parallel for\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      found = true;\n      break;\n    }\n  }\n\n  bool result;\n  MPI_Reduce(&found, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n  return result;\n}",False,True,,2,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int local_start = rank * local_size;\n    int local_end = local_start + local_size;\n\n    bool result = false;\n    #pragma omp parallel for\n    for (int i = local_start; i < local_end; i++) {\n        if (x[i] == target) {\n            result = true;\n            break;\n        }\n    }\n\n    int result_int = result;\n    MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    return result;\n}",False,True,,3,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int start = rank * chunk;\n  int end = start + chunk;\n\n  bool result = false;\n\n  #pragma omp parallel for reduction(|:result)\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",False,True,,4,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int local_size = x.size() / size;\n  int local_start = rank * local_size;\n  int local_end = local_start + local_size;\n  int local_target = target;\n  bool found = false;\n  #pragma omp parallel for\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == local_target) {\n      found = true;\n      break;\n    }\n  }\n  bool global_found;\n  MPI_Reduce(&found, &global_found, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n  return global_found;\n}",False,True,,5,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // each rank gets a chunk of the data\n    int chunk_size = n / size;\n    int start = rank * chunk_size;\n    int end = (rank + 1) * chunk_size;\n    if (rank == size - 1) {\n        end = n;\n    }\n\n    // search in parallel\n    bool result = false;\n    #pragma omp parallel for\n    for (int i = start; i < end; i++) {\n        if (x[i] == target) {\n            result = true;\n            break;\n        }\n    }\n\n    // gather results\n    int result_int = result;\n    MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n    return result;\n}",False,True,,6,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to search in parallel\n  // we can use OpenMP to parallelize the search\n  // we can use MPI to distribute the work across the ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the target value to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast the result to all ranks\n  // we can use MPI to collect the results on rank 0\n  // we can use MPI to broadcast",False,False,,7,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,0.0,True,True,0.0002719817,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,1.0,True,True,0.0002711432,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,2.0,True,True,0.0002704428,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,3.0,True,True,0.0002702457,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,4.0,True,True,0.0002676148,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,5.0,True,True,0.000265192,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,6.0,True,True,0.0002717965,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = target;\n  int local_result = 0;\n\n  // search for the target in the local vector\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == local_target) {\n      local_result = 1;\n      break;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return (rank == 0)? (global_result == 1) : false;\n}",True,False,0.0003247491,8,7.0,True,False,0.00028256135,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per rank\n  int n_per_rank = n / size;\n\n  // get the number of elements that are left over\n  int n_left_over = n % size;\n\n  // get the start and end indices for this rank\n  int start = rank * n_per_rank;\n  int end = start + n_per_rank;\n\n  // if this rank has any elements left over, add them to the end\n  if (rank < n_left_over) {\n    end++;\n  }\n\n  // initialize the result\n  bool result = false;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // reduce the result across all ranks\n  MPI_Reduce(&result, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",False,True,,9,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,0.0,True,True,0.0001918283,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,1.0,True,True,0.0001909618,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,2.0,True,True,0.000191725,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,3.0,True,True,0.000191632,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,4.0,True,True,0.0001899338,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,5.0,True,True,0.0001905339,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,6.0,True,True,0.0001928186,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  bool result = false;\n  if (rank == 0) {\n    for (int i = 0; i < size; i++) {\n      int start_i = i * chunk_size;\n      int end_i = start_i + chunk_size;\n      if (std::find(x.begin() + start_i, x.begin() + end_i, target)!= x.end()) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  MPI_Bcast(&result, 1, MPI_CXX_BOOL, 0, MPI_COMM_WORLD);\n  return result;\n}",True,False,0.0003889788,10,7.0,True,False,9.62181e-05,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int local_start = local_size * rank;\n  int local_end = local_start + local_size;\n\n  bool result = false;\n  #pragma omp parallel for\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n  return result;\n}",False,True,,11,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements in each chunk\n  int chunk_size = n / size;\n\n  // get the number of elements in the last chunk\n  int last_chunk_size = n % size;\n\n  // get the start and end indices of the chunk\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n\n  // if this is the last chunk, adjust the end index\n  if (rank == size - 1) {\n    end = start + last_chunk_size;\n  }\n\n  // get the chunk\n  std::vector<int> chunk(x.begin() + start, x.begin() + end);\n\n  // search the chunk\n  bool found = false;\n#pragma omp parallel for\n  for (int i = 0; i < chunk.size(); i++) {\n    if (chunk[i] == target) {\n      found = true;\n    }\n  }\n\n  // gather the results\n  bool result;\n  MPI_Reduce(&found, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,True,0.0003256416,12,0.0,True,False,2.6379e-06,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,0.0,True,True,0.0002750236,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,1.0,True,True,0.000278489,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,2.0,True,True,0.0002719508,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,3.0,True,True,0.0002680575,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,4.0,True,True,0.0002721773,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,5.0,True,True,0.0002699561,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,6.0,True,True,0.0002684271,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,7.0,True,True,0.00014457935,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,8.0,True,True,0.00014699895,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,9.0,True,True,0.000145461,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,10.0,True,True,0.0001457198,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,11.0,True,True,0.0001472348,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,12.0,True,True,0.0001487041,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,13.0,True,True,0.0001523477,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,14.0,True,True,0.004671070975,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,15.0,True,True,0.00032620655,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,16.0,True,True,0.00032663275,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,17.0,True,True,0.000329143875,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,18.0,True,True,0.0003482501,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,19.0,True,True,0.000328413825,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x\n  int n = x.size();\n\n  // number of elements per rank\n  int n_per_rank = n / size;\n\n  // number of elements in the last rank\n  int n_last_rank = n % size;\n\n  // start index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // start index of the last rank\n  int start_index_last_rank = start_index + n_per_rank;\n\n  // end index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // end index of the last rank\n  int end_index_last_rank = start_index_last_rank + n_last_rank;\n\n  // result of the search\n  bool result = false;\n\n  // search in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  // search in the last rank\n  if (!result) {\n    for (int i = start_index_last_rank; i < end_index_last_rank; i++) {\n      if (x[i] == target) {\n        result = true;\n        break;\n      }\n    }\n  }\n\n  // gather the result from all ranks\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,False,0.0003258668,13,20.0,True,True,0.000344500125,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,0.0,True,True,0.0013847201,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,1.0,True,True,0.0013827014,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,2.0,True,True,0.0013816941,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,3.0,True,True,0.0013817353,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,4.0,True,True,0.0013819306,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,5.0,True,True,0.0013835378,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,6.0,True,True,0.001383135,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,7.0,True,True,0.00070307305,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,8.0,True,True,0.00070098105,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,9.0,True,True,0.0007020142,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,10.0,True,True,0.00070102075,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,11.0,True,True,0.00070542935,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,12.0,True,True,0.00070400105,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,13.0,True,True,0.0007063125,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,14.0,True,True,0.00062621335,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,15.0,True,True,0.0006025181,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,16.0,True,True,0.0006023332,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,17.0,True,True,0.00060176825,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,18.0,True,True,0.00059920235,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,19.0,True,True,0.000597579875,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int chunk_size = n / size;\n  int start = rank * chunk_size;\n  int end = start + chunk_size;\n  if (rank == size - 1) {\n    end = n;\n  }\n\n  int local_count = 0;\n  for (int i = start; i < end; i++) {\n    if (x[i] == target) {\n      local_count++;\n    }\n  }\n\n  int global_count = 0;\n  MPI_Reduce(&local_count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_count > 0;\n}",True,False,0.0003252639,14,20.0,True,True,0.000623651975,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int start = local_size * rank;\n    int end = start + local_size;\n\n    bool result = false;\n    #pragma omp parallel for\n    for (int i = start; i < end; i++) {\n        if (x[i] == target) {\n            result = true;\n            break;\n        }\n    }\n\n    int global_result;\n    MPI_Reduce(&result, &global_result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n    return global_result;\n}",False,True,,15,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // every rank has a complete copy of x\n    std::vector<int> local_x = x;\n\n    // compute the number of elements in the local vector\n    int local_size = local_x.size();\n\n    // compute the number of elements in the local vector\n    int local_target = target;\n\n    // compute the number of elements in the local vector\n    int local_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found_target_result = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found_target_result_found_target = 0;\n\n    // compute the number of elements in the local vector\n    int local_found_result_target_result_found_target_result_found_target_result_found_target_",False,False,,16,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,0.0,True,True,0.0003315545,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,1.0,True,True,0.0002265061,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,2.0,True,True,0.0001805789,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,3.0,True,True,0.0001779399,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,4.0,True,True,0.0002484496,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,5.0,True,True,0.0016254425,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,6.0,True,True,0.0017200774,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,7.0,True,True,0.0003766026,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,8.0,True,True,0.0002534325,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,9.0,True,True,0.0002266639,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,10.0,True,True,0.00024810015,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,11.0,True,True,0.0002746382,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,12.0,True,True,0.00085498385,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,13.0,True,True,0.00102585295,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,14.0,True,True,0.00063995545,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,15.0,True,True,0.00050960455,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,16.0,True,True,0.0004788397,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,17.0,True,True,0.0004928467,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,18.0,True,True,0.000532298675,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,19.0,True,True,0.000586944675,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // each rank has a complete copy of x\n  // we can use this to parallelize the search\n  int local_size = x.size();\n  int local_target = target;\n  int local_result = 0;\n\n  // use OpenMP to parallelize the search\n  #pragma omp parallel for reduction(+:local_result)\n  for (int i = 0; i < local_size; i++) {\n    if (x[i] == local_target) {\n      local_result++;\n    }\n  }\n\n  // sum up the results from all ranks\n  int global_result = 0;\n  MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  return global_result > 0;\n}",True,True,0.0003262185,17,20.0,True,True,0.0007197024,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int chunk = n / size;\n  int remainder = n % size;\n\n  int start = rank * chunk;\n  int end = start + chunk;\n  if (rank == size - 1) {\n    end += remainder;\n  }\n\n  bool result = false;\n  #pragma omp parallel for\n  for (int i = start; i < end; ++i) {\n    if (x[i] == target) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_int = result;\n  MPI_Reduce(&result_int, &result, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",False,True,,18,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,0.0,True,True,0.0002709638,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,1.0,True,True,0.0002682778,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,2.0,True,True,0.000270073,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,3.0,True,True,0.000268487,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,4.0,True,True,0.0002791861,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,5.0,True,True,0.0002732641,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,6.0,True,True,0.0002690601,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",36_search_check_if_array_contains_value,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_target = -1;\n  int local_n = 0;\n  int local_result = 0;\n\n  // find the target in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_target = i;\n      break;\n    }\n  }\n\n  // count the number of elements in the local vector\n  for (int i = 0; i < n; i++) {\n    if (x[i] == target) {\n      local_n++;\n    }\n  }\n\n  // check if the target is in the local vector\n  if (local_target!= -1) {\n    local_result = 1;\n  }\n\n  // gather the results from all ranks\n  int result = 0;\n  MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  // return the result\n  if (rank == 0) {\n    return result == 1;\n  } else {\n    return false;\n  }\n}",True,False,0.0003251204,19,7.0,True,False,0.0002877835,1.0,2.0
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<int*> x_xor_y(""x_xor_y"", x.size() + y.size());\n  Kokkos::parallel_for(""xor_contains"", x.size(), KOKKOS_LAMBDA(const int i) {\n    x_xor_y(i) = x(i);\n  });\n  for (auto& v : y) {\n    Kokkos::parallel_for(""xor_contains"", x.size(), KOKKOS_LAMBDA(const int i) {\n      x_xor_y(i) ^= *v;\n    });\n  }\n  Kokkos::View<int> result(""result"", 1);\n  Kokkos::parallel_reduce(""xor_contains"", x.size(), KOKKOS_LAMBDA(const int i, int& lsum) {\n    lsum += x_xor_y(i) == val;\n  }, result);\n  return result() == 1;\n}",False,True,,0,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},False,True,,1,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> x_view(""x"", x.extent(0));\n  Kokkos::View<const int*> y_view(""y"", y.size());\n  Kokkos::View<const int*> val_view(""val"", 1);\n  Kokkos::deep_copy(x_view, x);\n  Kokkos::deep_copy(y_view, y);\n  Kokkos::deep_copy(val_view, val);\n\n  Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(""xorContains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, 1), KOKKOS_LAMBDA(int, bool& result, const bool& final_result) {\n    bool found = false;\n    for (int i = 0; i < x_view.extent(0); ++i) {\n      if (x_view(i) == val_view(0)) {\n        found = true;\n        break;\n      }\n    }\n    for (int i = 0; i < y_view.extent(0); ++i) {\n      if (y_view(i) == val_view(0)) {\n        found = true;\n        break;\n      }\n    }\n    result = found;\n    final_result = result || final_result;\n  }, result);\n\n  bool result_val;\n  Kokkos::deep_copy(result_val, result);\n  return result_val;\n}",False,True,,2,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*, Kokkos::HostSpace> x_host(""x_host"", x.extent(0));\n  Kokkos::deep_copy(x_host, x);\n  for (auto const& v : y) {\n    for (int i = 0; i < x.extent(0); ++i) {\n      if (x_host(i) == val) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",False,True,,3,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> all_x(""all_x"", x.extent(0) + y.size());\n  Kokkos::View<const int*> all_y(""all_y"", y.size());\n  Kokkos::deep_copy(all_x, x);\n  Kokkos::deep_copy(all_y, y);\n  Kokkos::View<bool> found(""found"", 1);\n  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, all_x.extent(0)),\n                          KOKKOS_LAMBDA(int i, bool& f) {\n                            f |= (all_x(i) == val) ^ (std::find(all_y.data(), all_y.data() + all_y.extent(0), all_x(i))!= all_y.data() + all_y.extent(0));\n                          },\n                          found);\n  bool result;\n  Kokkos::deep_copy(result, found);\n  return result;\n}",False,True,,4,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> x_view(""x_view"", x.size());\n  Kokkos::View<const int*> y_view(""y_view"", y.size());\n  Kokkos::deep_copy(x_view, x);\n  Kokkos::deep_copy(y_view, y);\n  Kokkos::View<bool, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""xor_contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.size()),\n      KOKKOS_LAMBDA(int i, bool& result_local) {\n        result_local = (std::find(y.begin(), y.end(), &x_view(i))!= y.end()) ^\n                      (std::find(y.begin(), y.end(), &y_view(i))!= y.end());\n      },\n      result);\n  return result();\n}",False,True,,5,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},False,True,,6,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(""xorContains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)), KOKKOS_LAMBDA(int i, bool& lresult) {\n    bool result = false;\n    for (auto const& v : y) {\n      result |= (v[i] == val);\n    }\n    lresult |= result;\n  }, result);\n  return result();\n}",False,True,,7,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<int*> x_xor_y(""x_xor_y"", x.size() + y.size());\n  Kokkos::parallel_for(""xor_contains"", x.size() + y.size(), KOKKOS_LAMBDA(int i) {\n    x_xor_y(i) = x(i) ^ y[i % y.size()][i];\n  });\n  Kokkos::fence();\n  for (int i = 0; i < x_xor_y.size(); i++) {\n    if (x_xor_y(i) == val) {\n      return true;\n    }\n  }\n  return false;\n}",False,True,,8,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*, Kokkos::HostSpace> x_host(""x_host"", x.extent(0));\n  Kokkos::deep_copy(x_host, x);\n\n  bool found = false;\n  for (auto const& y_i : y) {\n    for (auto const& x_i : x_host) {\n      if (x_i == val) {\n        found = true;\n        break;\n      }\n    }\n    if (found) {\n      break;\n    }\n  }\n  return found;\n}",False,True,,9,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> vals(""vals"", 2);\n  vals(0) = val;\n  vals(1) = val;\n\n  Kokkos::View<bool*> result(""result"", 1);\n  Kokkos::parallel_for(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, 1),\n                       KOKKOS_LAMBDA(const int i) {\n                         result(i) = false;\n                       });\n  Kokkos::fence();\n\n  Kokkos::parallel_for(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n                       KOKKOS_LAMBDA(const int i) {\n                         if (std::find(y.begin(), y.end(), &x(i))!= y.end()) {\n                           result(0) = true;\n                         }\n                       });\n  Kokkos::fence();\n\n  Kokkos::parallel_for(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, vals.extent(0)),\n                       KOKKOS_LAMBDA(const int i) {\n                         if (std::find(y.begin(), y.end(), &vals(i))!= y.end()) {\n                           result(0) = true;\n                         }\n                       });\n  Kokkos::fence();\n\n  bool res = false;\n  Kokkos::deep_copy(res, result(0));\n  return res;\n}",False,True,,10,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> y_view(""y_view"", y.size());\n  Kokkos::deep_copy(y_view, y);\n  Kokkos::View<bool> result(""result"", 1);\n  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n                          KOKKOS_LAMBDA(int i, bool& lresult) {\n                            lresult = (std::find(y_view.data(), y_view.data() + y_view.extent(0), x(i))!= y_view.data() + y_view.extent(0)) ^ (x(i) == val);\n                          },\n                          result);\n  bool result_h;\n  Kokkos::deep_copy(result_h, result);\n  return result_h;\n}",False,True,,11,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> x_view(""x_view"", x.size());\n  Kokkos::View<const int*> y_view(""y_view"", y.size());\n  Kokkos::View<int> result(""result"", 1);\n  Kokkos::deep_copy(x_view, x);\n  Kokkos::deep_copy(y_view, y);\n  Kokkos::deep_copy(result, 0);\n\n  Kokkos::parallel_for(""xor_contains"", x.size() + y.size(), KOKKOS_LAMBDA(int i) {\n    if (i < x.size()) {\n      result() = result() || (x_view(i) == val);\n    } else {\n      result() = result() || (y_view(i - x.size()) == val);\n    }\n  });\n\n  int result_val;\n  Kokkos::deep_copy(result_val, result);\n  return result_val;\n}",False,True,,12,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> vals(""vals"", 2);\n  vals(0) = val;\n  vals(1) = val;\n\n  Kokkos::View<bool*> result(""result"", 1);\n  Kokkos::parallel_for(""xorContains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, 1), KOKKOS_LAMBDA(int i) {\n    result(i) = false;\n    for (auto const& v : y) {\n      if (std::find(x.data(), x.data() + x.extent(0), *v)!= x.data() + x.extent(0)) {\n        result(i) = true;\n        break;\n      }\n    }\n  });\n\n  return result(0);\n}",False,True,,13,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0) + y.size()),\n      KOKKOS_LAMBDA(const int i, bool& result) {\n        result = result || (x(i) == val);\n        for (auto const& y_i : y) {\n          result = result || (y_i[i] == val);\n        }\n      },\n      result);\n  return result();\n}",False,True,,14,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(""xorContains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)), KOKKOS_LAMBDA(int i, bool& lresult) {\n    bool result = false;\n    for (auto& y_i : y) {\n      result = result || (x(i) == *y_i);\n    }\n    lresult = lresult || result;\n  }, result);\n  return result();\n}",False,True,,15,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<int*, Kokkos::HostSpace> x_host(""x_host"", x.extent(0));\n  Kokkos::deep_copy(x_host, x);\n  std::vector<int*> y_host(y.size());\n  for (int i = 0; i < y.size(); ++i) {\n    y_host[i] = new int[y[i].extent(0)];\n    Kokkos::deep_copy(y_host[i], y[i]);\n  }\n  Kokkos::View<int*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""xor_contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(const int i, bool& result) {\n        result = (std::find(y_host.begin(), y_host.end(), &x_host(i))!= y_host.end()) ^\n                 (std::find(y_host.begin(), y_host.end(), &val)!= y_host.end());\n      },\n      result);\n  return result();\n}",False,True,,16,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return false;\n},False,True,,17,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<bool*, Kokkos::HostSpace> result(""result"", 1);\n  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, 1),\n                          KOKKOS_LAMBDA(int, bool& result, const int& i) {\n                            result = false;\n                            for (auto const& v : y) {\n                              if (std::find(v, v + 6, val)!= v + 6) {\n                                result = true;\n                                break;\n                              }\n                            }\n                          },\n                          result);\n  return result();\n}",False,True,,18,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, std::vector<const int*> const& y, int val) {",39_search_xor_contains,search,cpp,kokkos,0.2,0.95,True,1024,True,"Kokkos::View<const int*> x_view(""x"", x.size());\n  Kokkos::View<const int*> y_view(""y"", y.size());\n  Kokkos::View<const int*> val_view(""val"", 1);\n  Kokkos::deep_copy(x_view, x);\n  Kokkos::deep_copy(y_view, y);\n  Kokkos::deep_copy(val_view, val);\n\n  Kokkos::View<bool> result(""result"", 1);\n  Kokkos::parallel_reduce(\n      ""xor_contains"", Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x_view.size() + y_view.size()),\n      KOKKOS_LAMBDA(const int i, bool& result) {\n        if (x_view(i) == val_view(0)) {\n          result = true;\n        } else if (std::find(y.begin(), y.end(), &x_view(i))!= y.end()) {\n          result = true;\n        }\n      },\n      result);\n  Kokkos::deep_copy(result, result);\n  return result();\n}",False,True,,19,,,,,,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,0.0,True,True,0.00035373338033,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,1.0,True,True,0.0003518213518,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,2.0,True,True,0.00035121683031,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,3.0,True,True,0.00034402494784,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,4.0,True,True,0.00041702117305,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,5.0,True,True,0.00052355746739,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.45359173e-06,0,6.0,True,True,0.00065897547174,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,0.0,True,True,0.00036546131596,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,1.0,True,True,0.00031789194327,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,2.0,True,True,0.00032469159923,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,3.0,True,True,0.00032871409785,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,4.0,True,True,0.0004059957806,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,5.0,True,True,0.0006068713963,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.0542715e-06,1,6.0,True,True,0.00080490699038,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,0.0,True,True,0.00035633607768,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,1.0,True,True,0.00035397738684,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,2.0,True,True,0.00035853127483,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,3.0,True,True,0.00034198102076,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,4.0,True,True,0.0004127852153,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,5.0,True,True,0.00052151782438,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < x.size(); i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  for (int i = 0; i < y.size(); i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,8.42821319e-06,2,6.0,True,True,0.00067600712646,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,0.0,True,True,0.00035581709817,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,1.0,True,True,0.00031983966473,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,2.0,True,True,0.00032681047451,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,3.0,True,True,0.00033068079501,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,4.0,True,True,0.00041159400716,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,5.0,True,True,0.00072284936905,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05797351e-06,3,6.0,True,True,0.00080262052361,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,0.0,True,True,0.00037241149694,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,1.0,True,True,0.00032482275274,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,2.0,True,True,0.00032803574577,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,3.0,True,True,0.00033244502265,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,4.0,True,True,0.00041029483546,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,5.0,True,True,0.00060459796805,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05774068e-06,4,6.0,True,True,0.00079943940509,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,0.0,True,True,0.00035466798581,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,1.0,True,True,0.00032345154323,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,2.0,True,True,0.00033476764802,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,3.0,True,True,0.00032815807499,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,4.0,True,True,0.00041111430619,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,5.0,True,True,0.00061592834536,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.05399211e-06,5,6.0,True,True,0.00079293418676,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,0.0,True,True,0.00036844275892,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,1.0,True,True,0.00032743979245,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,2.0,True,True,0.0003280187957,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,3.0,True,True,0.00033112003002,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,4.0,True,True,0.00041642305441,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,5.0,True,True,0.00060782597866,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n  return count == 1;\n},True,True,9.05820634e-06,6,6.0,True,True,0.00080336262472,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,0.0,True,True,0.00037133344449,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,1.0,True,True,0.00031892084517,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,2.0,True,True,0.00032799888868,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,3.0,True,True,0.00033214264549,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,4.0,True,True,0.00040640030056,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,5.0,True,True,0.00062566972338,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int found = 0;\n    #pragma omp parallel\n    {\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < x.size(); i++) {\n            if (x[i] == val) {\n                found++;\n            }\n        }\n        #pragma omp for reduction(+:found)\n        for (int i = 0; i < y.size(); i++) {\n            if (y[i] == val) {\n                found++;\n            }\n        }\n    }\n    return found == 1;\n},True,True,9.04987101e-06,7,6.0,True,True,0.00079284620006,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,0.0,True,True,0.00036734980531,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,1.0,True,True,0.00032674460672,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,2.0,True,True,0.00032917896751,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,3.0,True,True,0.00033081402071,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,4.0,True,True,0.0004087556852,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,5.0,True,True,0.00063225913327,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06095374e-06,8,6.0,True,True,0.00080446796492,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < x.size(); i++) {\n    found |= (x[i] == val);\n  }\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < y.size(); i++) {\n    found |= (y[i] == val);\n  }\n  return found;\n},True,True,1.01842219e-05,9,0.0,True,False,0.00259917436633,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < x.size(); i++) {\n    found |= (x[i] == val);\n  }\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < y.size(); i++) {\n    found |= (y[i] == val);\n  }\n  return found;\n},True,True,9.88754909e-06,10,0.0,True,False,0.0025914351223,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,0.0,True,True,0.00036613387056,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,1.0,True,True,0.00032666549087,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,2.0,True,True,0.00032926737331,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,3.0,True,True,0.00032835945021,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,4.0,True,True,0.00040934868157,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,5.0,True,True,0.00062661154661,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,11,6.0,True,True,0.00080448209774,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,0.0,True,True,0.00036488149781,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,1.0,True,True,0.00033451300114,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,2.0,True,True,0.00032883051317,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,3.0,True,True,0.00032960204408,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,4.0,True,True,0.00041426590178,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,5.0,True,True,0.00061925170012,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.05811321e-06,12,6.0,True,True,0.00195886420552,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,0.0,True,True,0.00036410966422,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,1.0,True,True,0.00032980018295,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,2.0,True,True,0.00032782051712,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,3.0,True,True,0.00032474067993,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,4.0,True,True,0.00040791111533,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,5.0,True,True,0.00061534531415,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06509813e-06,13,6.0,True,True,0.00080364032183,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,0.0,True,True,0.0003572429996,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,1.0,True,True,0.0003243819112,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,2.0,True,True,0.00032470878214,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,3.0,True,True,0.00032196328975,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,4.0,True,True,0.00041232472286,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,5.0,True,True,0.00062162009999,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.03396867e-06,14,6.0,True,True,0.00080226908904,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,0.0,True,True,0.00035638019908,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,1.0,True,True,0.00033011194319,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,2.0,True,True,0.00032588432077,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,3.0,True,True,0.00034154667519,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,4.0,True,True,0.00041997968219,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,5.0,True,True,0.00061435946263,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.06116329e-06,15,6.0,True,True,0.00079196139704,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,0.0,True,True,0.0003562081838,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,1.0,True,True,0.00032722949982,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,2.0,True,True,0.00033586348873,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,3.0,True,True,0.00033170983661,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,4.0,True,True,0.00041913406458,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,5.0,True,True,0.00290179261938,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int count = 0;\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < n; i++) {\n    if (x[i] == val) {\n      count++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:count)\n  for (int i = 0; i < m; i++) {\n    if (y[i] == val) {\n      count++;\n    }\n  }\n\n  return count == 1;\n},True,True,9.07189678e-06,16,6.0,True,True,0.00080070982222,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,0.0,True,True,0.00036399976816,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,1.0,True,True,0.00032882639207,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,2.0,True,True,0.00032600117847,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,3.0,True,True,0.00033432687633,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,4.0,True,True,0.0004267036682,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,5.0,True,True,0.00062059718184,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int count = 0;\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < n; i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < m; i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n\n    return count == 1;\n},True,True,9.06414352e-06,17,6.0,True,True,0.00079239527695,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,0.0,True,True,0.00036248348188,1.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,1.0,True,True,0.00031784791499,2.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,2.0,True,True,0.00032707119826,4.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,3.0,True,True,0.00032508119475,8.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,4.0,True,True,0.00041492776945,16.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,5.0,True,True,0.0006034509046,32.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            count++;\n        }\n    }\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            count++;\n        }\n    }\n    return count == 1;\n},True,True,9.05087218e-06,18,6.0,True,True,0.00313934828155,64.0,
"#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,omp,0.2,0.95,True,1024,True,bool found = false;\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < x.size(); i++) {\n    found |= (x[i] == val);\n  }\n  #pragma omp parallel for reduction(|:found)\n  for (int i = 0; i < y.size(); i++) {\n    found |= (y[i] == val);\n  }\n  return found;\n},True,True,9.83742066e-06,19,0.0,True,False,0.00259540351108,1.0,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (int i : x) {\n    if (i == val) {\n      return true;\n    }\n  }\n  for (int i : y) {\n    if (i == val) {\n      return true;\n    }\n  }\n  return false;\n},True,True,8.5861e-06,0,0.0,True,False,5.1849e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.938e-06,1,0.0,True,True,7.3118e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.9299e-06,2,0.0,True,True,7.0433e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (auto const& i : x) {\n    if (i == val) {\n      return true;\n    }\n  }\n  for (auto const& i : y) {\n    if (i == val) {\n      return true;\n    }\n  }\n  return false;\n},True,True,8.9008e-06,3,0.0,True,False,5.0096e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^ std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,9.0189e-06,4,0.0,True,True,6.9613e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.9057e-06,5,0.0,True,True,7.0752e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^ std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,9.0553e-06,6,0.0,True,True,7.5091e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (auto i : x) {\n    if (i == val) {\n      return true;\n    }\n  }\n  for (auto i : y) {\n    if (i == val) {\n      return true;\n    }\n  }\n  return false;\n},True,True,8.9007e-06,7,0.0,True,False,5.1159e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (int i : x) {\n        if (i == val) {\n            return true;\n        }\n    }\n    for (int i : y) {\n        if (i == val) {\n            return true;\n        }\n    }\n    return false;\n},True,True,8.6815e-06,8,0.0,True,False,5.4724e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"// xor of two vectors is the same as xor of their elements\n  // xor of two elements is the same as xor of their bits\n  // xor of two bits is 0 if they are the same, 1 if they are different\n  // so if we xor the two vectors, we get the xor of their elements\n  // and if we xor that with val, we get the xor of their elements and val\n  // if the xor of their elements and val is 0, then val is not in both vectors\n  // if the xor of their elements and val is not 0, then val is in both vectors\n  return (std::accumulate(x.begin(), x.end(), 0) ^ std::accumulate(y.begin(), y.end(), 0) ^ val) == 0;\n}",True,True,9.9058e-06,9,0.0,True,True,0.0003359169,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.9559e-06,10,0.0,True,True,7.1533e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (int i : x) {\n        if (i == val) {\n            return true;\n        }\n    }\n    for (int i : y) {\n        if (i == val) {\n            return true;\n        }\n    }\n    return false;\n},True,True,8.5621e-06,11,0.0,True,False,5.0235e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"// XOR of two vectors is the set of elements that are in one of the vectors, but not both\n    // XOR of two sets is the set of elements that are in one of the sets, but not both\n    // XOR of two numbers is the number that is in one of the numbers, but not both\n    // XOR of two booleans is the boolean that is in one of the booleans, but not both\n    // XOR of two characters is the character that is in one of the characters, but not both\n    // XOR of two strings is the string that is in one of the strings, but not both\n    // XOR of two pointers is the pointer that is in one of the pointers, but not both\n    // XOR of two references is the reference that is in one of the references, but not both\n    // XOR of two arrays is the array that is in one of the arrays, but not both\n    // XOR of two functions is the function that is in one of the functions, but not both\n    // XOR of two classes is the class that is in one of the classes, but not both\n    // XOR of two structs is the struct that is in one of the structs, but not both\n    // XOR of two unions is the union that is in one of the unions, but not both\n    // XOR of two enumerations is the enumeration that is in one of the enumerations, but not both\n    // XOR of two namespaces is the namespace that is in one of the namespaces, but not both\n    // XOR of two typedefs is the typedef that is in one of the typedefs, but not both\n    // XOR of two templates is the template that is in one of the templates, but not both\n    // XOR of two macros is the macro that is in one of the macros, but not both\n    // XOR of two preprocessor directives is the preprocessor directive that is in one of the preprocessor directives, but not both\n    // XOR of two labels is the label that is in one of the labels, but not both\n    // XOR of two statements is the statement that is in one of the statements, but not both\n    // XOR of two expressions is the expression that is in one of the expressions, but not both\n    // XOR of two types is the type that is in one of the types, but not both\n    // XOR of two variables is the variable that is in one of the variables, but not both\n    // XOR of two constants is the constant that is in one of the constants, but not both\n    // XOR of two literals is the literal that is in one of the literals, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of two attributes is the attribute that is in one of the attributes, but not both\n    // XOR of",False,True,,12,,,,,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n           std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,9.032e-06,13,0.0,True,True,7.4417e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.8859e-06,14,0.0,True,True,7.1895e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^ std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,9.3438e-06,15,0.0,True,True,7.6064e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^ std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.9529e-06,16,0.0,True,True,7.1987e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,for (auto const& i : x) {\n        if (i == val) {\n            return true;\n        }\n    }\n    for (auto const& i : y) {\n        if (i == val) {\n            return true;\n        }\n    }\n    return false;\n},True,True,8.6862e-06,17,0.0,True,False,5.1675e-06,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,// xor of two vectors is the same as xor of their sums\n    int sum_x = 0;\n    int sum_y = 0;\n\n    for (int i = 0; i < x.size(); i++) {\n        sum_x += x[i];\n    }\n\n    for (int i = 0; i < y.size(); i++) {\n        sum_y += y[i];\n    }\n\n    return (sum_x ^ sum_y) == val;\n},True,True,9.9296e-06,18,0.0,True,True,0.0005066649,,
"/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,serial,0.2,0.95,True,1024,True,"return std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",True,True,8.9586e-06,19,0.0,True,True,7.3849e-06,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_local_size = x_size / size;\n  int y_local_size = y_size / size;\n\n  int x_start = x_local_size * rank;\n  int y_start = y_local_size * rank;\n\n  int x_end = x_start + x_local_size;\n  int y_end = y_start + y_local_size;\n\n  if (rank == 0) {\n    x_end = x_size;\n    y_end = y_size;\n  }\n\n  int x_local_size_with_remainder = x_end - x_start;\n  int y_local_size_with_remainder = y_end - y_start;\n\n  std::vector<int> x_local(x_local_size_with_remainder);\n  std::vector<int> y_local(y_local_size_with_remainder);\n\n  MPI_Scatter(&x[x_start], x_local_size_with_remainder, MPI_INT, &x_local[0], x_local_size_with_remainder, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Scatter(&y[y_start], y_local_size_with_remainder, MPI_INT, &y_local[0], y_local_size_with_remainder, MPI_INT, 0, MPI_COMM_WORLD);\n\n  bool result = false;\n  for (int i = 0; i < x_local_size_with_remainder; i++) {\n    if (x_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  for (int i = 0; i < y_local_size_with_remainder; i++) {\n    if (y_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_int = result;\n  int result_int_local;\n\n  MPI_Reduce(&result_int, &result_int_local, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n  return result_int_local;\n}",True,True,8.7356e-06,0,0.0,True,False,0.002624017,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> xChunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> yChunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunk\n  bool found = false;\n  for (int i = 0; i < xChunk.size(); i++) {\n    if (xChunk[i] == val || yChunk[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // gather the results\n  bool result;\n  MPI_Reduce(&found, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",True,True,8.6492e-06,1,0.0,True,False,0.0020811874,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // send the size of the vectors to all ranks\n  int x_size = x.size();\n  int y_size = y.size();\n  MPI_Bcast(&x_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Bcast(&y_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // send the vectors to all ranks\n  std::vector<int> x_local(x_size);\n  std::vector<int> y_local(y_size);\n  MPI_Scatter(x.data(), x_size, MPI_INT, x_local.data(), x_size, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Scatter(y.data(), y_size, MPI_INT, y_local.data(), y_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // search for the value in the local vectors\n  bool found = false;\n  for (int i = 0; i < x_size; i++) {\n    if (x_local[i] == val) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < y_size; i++) {\n    if (y_local[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  bool found_global;\n  MPI_Reduce(&found, &found_global, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return found_global;\n}",True,True,8.7373e-06,2,0.0,True,False,0.0026601079,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // send the size of the vectors to all ranks\n  int x_size = x.size();\n  int y_size = y.size();\n  MPI_Bcast(&x_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Bcast(&y_size, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // send the vectors to all ranks\n  std::vector<int> x_local(x_size);\n  std::vector<int> y_local(y_size);\n  MPI_Scatter(x.data(), x_size, MPI_INT, x_local.data(), x_size, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Scatter(y.data(), y_size, MPI_INT, y_local.data(), y_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // search for val in x_local and y_local\n  bool found = false;\n  for (int i = 0; i < x_size; i++) {\n    if (x_local[i] == val) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < y_size; i++) {\n    if (y_local[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // gather the results from all ranks\n  bool found_global;\n  MPI_Reduce(&found, &found_global, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return found_global;\n}",True,True,9.1011e-06,3,0.0,True,False,0.0025576883,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_start = x_size * rank / size;\n  int x_end = x_size * (rank + 1) / size;\n\n  int y_start = y_size * rank / size;\n  int y_end = y_size * (rank + 1) / size;\n\n  for (int i = x_start; i < x_end; i++) {\n    if (x[i] == val) {\n      return true;\n    }\n  }\n\n  for (int i = y_start; i < y_end; i++) {\n    if (y[i] == val) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,9.1403e-06,4,0.0,True,False,5.4794e-06,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in x\n  int x_size = x.size();\n\n  // get the number of elements in y\n  int y_size = y.size();\n\n  // get the number of elements in x and y\n  int total_size = x_size + y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_size = 0;\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] == val) {\n      local_size++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val) {\n      local_size++;\n    }\n  }\n\n  // get the number of elements in x and y that are in the current process\n  int local_x_size = 0;\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] == val) {\n      local_x_size++;\n    }\n  }\n\n  // get the number of elements in x and y that are in the current process\n  int local_y_size = 0;\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val) {\n      local_y_size++;\n    }\n  }\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_size = local_x_size + local_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_size = local_x_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_y_size = local_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_size = local_xor_x_size + local_xor_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_size = local_xor_x_y_size - local_xor_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_size = local_xor_x_y_xor_size - local_xor_x_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_y_size = local_xor_x_y_xor_size - local_xor_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_y_size = local_xor_x_y_xor_x_size + local_xor_x_y_xor_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_y_xor_size = local_xor_x_y_xor_x_y_size - local_xor_x_y_xor_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_y_xor_x_size = local_xor_x_y_xor_x_y_xor_size - local_xor_x_y_xor_x_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_y_xor_y_size = local_xor_x_y_xor_x_y_xor_size - local_xor_x_y_xor_y_size;\n\n  // get the number of elements in x and y that are in the current process\n  int local_xor_x_y_xor_x_y_xor_x_y_size = local_xor_x_y_xor_x_y_xor_x_size + local_xor_x_y_xor_x_y_xor_y_size;\n\n  // get the number of elements in",False,True,,5,,,,,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_x_size = x.size();\n    int local_y_size = y.size();\n\n    int local_x_start = 0;\n    int local_y_start = 0;\n\n    int local_x_end = local_x_size;\n    int local_y_end = local_y_size;\n\n    int global_x_size = 0;\n    int global_y_size = 0;\n\n    int global_x_start = 0;\n    int global_y_start = 0;\n\n    int global_x_end = 0;\n    int global_y_end = 0;\n\n    MPI_Allreduce(&local_x_size, &global_x_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_size, &global_y_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_start, &global_x_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_start, &global_y_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_end, &global_x_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_end, &global_y_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    int local_x_index = 0;\n    int local_y_index = 0;\n\n    int global_x_index = 0;\n    int global_y_index = 0;\n\n    for (int i = 0; i < rank; i++) {\n        local_x_index += x[i];\n        local_y_index += y[i];\n    }\n\n    for (int i = 0; i < global_x_start; i++) {\n        global_x_index += x[i];\n    }\n\n    for (int i = 0; i < global_y_start; i++) {\n        global_y_index += y[i];\n    }\n\n    int local_x_xor_y = 0;\n    int global_x_xor_y = 0;\n\n    for (int i = global_x_start; i < global_x_end; i++) {\n        local_x_xor_y ^= x[i];\n    }\n\n    for (int i = global_y_start; i < global_y_end; i++) {\n        local_x_xor_y ^= y[i];\n    }\n\n    MPI_Allreduce(&local_x_xor_y, &global_x_xor_y, 1, MPI_INT, MPI_BOR, MPI_COMM_WORLD);\n\n    if (global_x_xor_y == val) {\n        return true;\n    } else {\n        return false;\n    }\n}",True,True,9.086e-06,6,0.0,True,True,0.0019563601,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_x_size = x.size();\n    int local_y_size = y.size();\n\n    int local_x_start = 0;\n    int local_y_start = 0;\n\n    int local_x_end = local_x_size;\n    int local_y_end = local_y_size;\n\n    int global_x_size = 0;\n    int global_y_size = 0;\n\n    int global_x_start = 0;\n    int global_y_start = 0;\n\n    int global_x_end = 0;\n    int global_y_end = 0;\n\n    MPI_Allreduce(&local_x_size, &global_x_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_size, &global_y_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_start, &global_x_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_start, &global_y_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_end, &global_x_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_end, &global_y_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    int local_x_index = 0;\n    int local_y_index = 0;\n\n    int global_x_index = 0;\n    int global_y_index = 0;\n\n    for (int i = 0; i < rank; i++) {\n        local_x_index += x[i];\n        local_y_index += y[i];\n    }\n\n    for (int i = 0; i < global_x_start; i++) {\n        global_x_index += x[i];\n    }\n\n    for (int i = 0; i < global_y_start; i++) {\n        global_y_index += y[i];\n    }\n\n    int local_x_xor_y = 0;\n    int global_x_xor_y = 0;\n\n    for (int i = global_x_start; i < global_x_end; i++) {\n        local_x_xor_y ^= x[i];\n    }\n\n    for (int i = global_y_start; i < global_y_end; i++) {\n        local_x_xor_y ^= y[i];\n    }\n\n    MPI_Allreduce(&local_x_xor_y, &global_x_xor_y, 1, MPI_INT, MPI_BOR, MPI_COMM_WORLD);\n\n    if (global_x_xor_y == val) {\n        return true;\n    } else {\n        return false;\n    }\n}",True,True,9.086e-06,6,1.0,True,True,0.00461812975,,2.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_x_size = x.size();\n    int local_y_size = y.size();\n\n    int local_x_start = 0;\n    int local_y_start = 0;\n\n    int local_x_end = local_x_size;\n    int local_y_end = local_y_size;\n\n    int global_x_size = 0;\n    int global_y_size = 0;\n\n    int global_x_start = 0;\n    int global_y_start = 0;\n\n    int global_x_end = 0;\n    int global_y_end = 0;\n\n    MPI_Allreduce(&local_x_size, &global_x_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_size, &global_y_size, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_start, &global_x_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_start, &global_y_start, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    MPI_Allreduce(&local_x_end, &global_x_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n    MPI_Allreduce(&local_y_end, &global_y_end, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n\n    int local_x_index = 0;\n    int local_y_index = 0;\n\n    int global_x_index = 0;\n    int global_y_index = 0;\n\n    for (int i = 0; i < rank; i++) {\n        local_x_index += x[i];\n        local_y_index += y[i];\n    }\n\n    for (int i = 0; i < global_x_start; i++) {\n        global_x_index += x[i];\n    }\n\n    for (int i = 0; i < global_y_start; i++) {\n        global_y_index += y[i];\n    }\n\n    int local_x_xor_y = 0;\n    int global_x_xor_y = 0;\n\n    for (int i = global_x_start; i < global_x_end; i++) {\n        local_x_xor_y ^= x[i];\n    }\n\n    for (int i = global_y_start; i < global_y_end; i++) {\n        local_x_xor_y ^= y[i];\n    }\n\n    MPI_Allreduce(&local_x_xor_y, &global_x_xor_y, 1, MPI_INT, MPI_BOR, MPI_COMM_WORLD);\n\n    if (global_x_xor_y == val) {\n        return true;\n    } else {\n        return false;\n    }\n}",True,True,9.086e-06,6,2.0,False,,,,4.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // create a vector of size size that will store the result of each rank\n  std::vector<bool> result(size);\n\n  // get the size of the vectors\n  int x_size = x.size();\n  int y_size = y.size();\n\n  // get the start and end index of the subvector that this rank will search\n  int start = (x_size * rank) / size;\n  int end = (x_size * (rank + 1)) / size;\n\n  // search for the value in the subvector\n  for (int i = start; i < end; i++) {\n    if (x[i] == val) {\n      result[rank] = true;\n      break;\n    }\n  }\n\n  // search for the value in the subvector\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val) {\n      result[rank] = true;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, result.data(), 1, MPI_C_BOOL, MPI_COMM_WORLD);\n\n  // return the result on rank 0\n  return result[0];\n}",False,True,,7,,,,,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // send the length of the vectors to all ranks\n  int x_len = x.size();\n  int y_len = y.size();\n  MPI_Bcast(&x_len, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Bcast(&y_len, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // send the vectors to all ranks\n  std::vector<int> x_send(x.begin(), x.end());\n  std::vector<int> y_send(y.begin(), y.end());\n  MPI_Bcast(x_send.data(), x_len, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Bcast(y_send.data(), y_len, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // search for val in x and y\n  bool found = false;\n  for (int i = 0; i < x_len; i++) {\n    if (x_send[i] == val) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < y_len; i++) {\n    if (y_send[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  bool found_all;\n  MPI_Reduce(&found, &found_all, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return found_all;\n}",True,True,8.7955e-06,8,0.0,True,False,0.0019294766,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int x_size = x.size();\n    int y_size = y.size();\n\n    int x_start = 0;\n    int x_end = x_size;\n    int y_start = 0;\n    int y_end = y_size;\n\n    int x_size_per_rank = x_size / size;\n    int y_size_per_rank = y_size / size;\n\n    int x_start_per_rank = x_start + x_size_per_rank * rank;\n    int x_end_per_rank = x_start_per_rank + x_size_per_rank;\n    int y_start_per_rank = y_start + y_size_per_rank * rank;\n    int y_end_per_rank = y_start_per_rank + y_size_per_rank;\n\n    int x_size_per_rank_local = x_end_per_rank - x_start_per_rank;\n    int y_size_per_rank_local = y_end_per_rank - y_start_per_rank;\n\n    int x_start_local = x_start_per_rank;\n    int x_end_local = x_end_per_rank;\n    int y_start_local = y_start_per_rank;\n    int y_end_local = y_end_per_rank;\n\n    int x_size_local = x_end_local - x_start_local;\n    int y_size_local = y_end_local - y_start_local;\n\n    int x_local[x_size_local];\n    int y_local[y_size_local];\n\n    MPI_Scatter(x.data() + x_start_local, x_size_per_rank_local, MPI_INT, x_local, x_size_per_rank_local, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Scatter(y.data() + y_start_local, y_size_per_rank_local, MPI_INT, y_local, y_size_per_rank_local, MPI_INT, 0, MPI_COMM_WORLD);\n\n    bool result = false;\n\n    for (int i = 0; i < x_size_local; i++) {\n        for (int j = 0; j < y_size_local; j++) {\n            if (x_local[i] == val || y_local[j] == val) {\n                result = true;\n                break;\n            }\n        }\n    }\n\n    int result_local = result;\n    int result_global;\n\n    MPI_Reduce(&result_local, &result_global, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    return result_global;\n}",True,True,8.7605e-06,9,0.0,True,False,11.0841817116,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in x and y\n  int x_size = x.size();\n  int y_size = y.size();\n\n  // compute the number of elements in x and y that are less than val\n  int x_less_than_val = 0;\n  int y_less_than_val = 0;\n\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] < val) {\n      x_less_than_val++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] < val) {\n      y_less_than_val++;\n    }\n  }\n\n  // compute the number of elements in x and y that are greater than val\n  int x_greater_than_val = x_size - x_less_than_val;\n  int y_greater_than_val = y_size - y_less_than_val;\n\n  // compute the number of elements in x and y that are equal to val\n  int x_equal_to_val = 0;\n  int y_equal_to_val = 0;\n\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] == val) {\n      x_equal_to_val++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val) {\n      y_equal_to_val++;\n    }\n  }\n\n  // compute the number of elements in x and y that are less than val\n  int x_less_than_val_on_rank = 0;\n  int y_less_than_val_on_rank = 0;\n\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] < val && rank == 0) {\n      x_less_than_val_on_rank++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] < val && rank == 0) {\n      y_less_than_val_on_rank++;\n    }\n  }\n\n  // compute the number of elements in x and y that are greater than val\n  int x_greater_than_val_on_rank = x_size - x_less_than_val_on_rank;\n  int y_greater_than_val_on_rank = y_size - y_less_than_val_on_rank;\n\n  // compute the number of elements in x and y that are equal to val\n  int x_equal_to_val_on_rank = 0;\n  int y_equal_to_val_on_rank = 0;\n\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] == val && rank == 0) {\n      x_equal_to_val_on_rank++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val && rank == 0) {\n      y_equal_to_val_on_rank++;\n    }\n  }\n\n  // compute the number of elements in x and y that are less than val\n  int x_less_than_val_on_rank_minus_1 = 0;\n  int y_less_than_val_on_rank_minus_1 = 0;\n\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] < val && rank == size - 1) {\n      x_less_than_val_on_rank_minus_1++;\n    }\n  }\n\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] < val && rank == size - 1) {\n      y_less_than_val_on_rank_minus_1++;\n    }\n  }\n\n  // compute the number of elements in x and y that are greater than val\n  int x_greater_than_val_on_rank_minus_1 = x_size - x_less_than_val_on_rank_minus_1;\n  int y_greater_than_val_on_rank_minus_1 = y_size - y_less_than_val_on_rank_minus_1",False,True,,10,,,,,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // send the size of the vectors to all ranks\n  int xSize = x.size();\n  int ySize = y.size();\n  MPI_Bcast(&xSize, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Bcast(&ySize, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // send the vectors to all ranks\n  std::vector<int> xLocal(xSize);\n  std::vector<int> yLocal(ySize);\n  MPI_Scatter(x.data(), xSize, MPI_INT, xLocal.data(), xSize, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Scatter(y.data(), ySize, MPI_INT, yLocal.data(), ySize, MPI_INT, 0, MPI_COMM_WORLD);\n\n  // search for val in xLocal and yLocal\n  bool found = false;\n  for (int i = 0; i < xSize; i++) {\n    if (xLocal[i] == val) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = 0; i < ySize; i++) {\n    if (yLocal[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // gather the result from all ranks\n  bool foundGlobal;\n  MPI_Gather(&found, 1, MPI_C_BOOL, &foundGlobal, 1, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n\n  return foundGlobal;\n}",True,True,9.3704e-06,11,0.0,True,False,0.0026209354,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int size;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the length of the vectors\n  int x_len = x.size();\n  int y_len = y.size();\n\n  // get the length of the smaller vector\n  int min_len = std::min(x_len, y_len);\n\n  // get the length of the larger vector\n  int max_len = std::max(x_len, y_len);\n\n  // create a vector to store the result\n  std::vector<int> result(size, 0);\n\n  // get the number of elements in the smaller vector\n  int num_elements = min_len / size;\n\n  // get the number of elements in the larger vector\n  int num_elements_extra = max_len - num_elements * size;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank = num_elements + (rank < num_elements_extra);\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank = num_elements_extra + (rank >= num_elements_extra);\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_x = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_x = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_y = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_y = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_x_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_x_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_y_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_y_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_result_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_result_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_x_result_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_x_result_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_y_result_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_y_result_result = num_elements_extra_in_rank;\n\n  // get the number of elements in the smaller vector that are in the current rank\n  int num_elements_in_rank_result_result_result = num_elements_in_rank;\n\n  // get the number of elements in the larger vector that are in the current rank\n  int num_elements_extra_in_rank_result_result_result = num_elements_extra_in_rank;\n\n  // get the number",False,True,,12,,,,,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int x_size = x.size();\n    int y_size = y.size();\n\n    int x_start = x_size * rank / size;\n    int x_end = x_size * (rank + 1) / size;\n    int y_start = y_size * rank / size;\n    int y_end = y_size * (rank + 1) / size;\n\n    int x_local_size = x_end - x_start;\n    int y_local_size = y_end - y_start;\n\n    std::vector<int> x_local(x_local_size);\n    std::vector<int> y_local(y_local_size);\n\n    MPI_Scatter(&x[x_start], x_local_size, MPI_INT, &x_local[0], x_local_size, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Scatter(&y[y_start], y_local_size, MPI_INT, &y_local[0], y_local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    bool result = false;\n    for (int i = 0; i < x_local_size; i++) {\n        if (x_local[i] == val) {\n            result = true;\n            break;\n        }\n    }\n    for (int i = 0; i < y_local_size; i++) {\n        if (y_local[i] == val) {\n            result = true;\n            break;\n        }\n    }\n\n    int result_local = result;\n    MPI_Reduce(&result_local, &result, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,True,9.0228e-06,13,0.0,True,False,0.0025871519,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_local_size = x_size / size;\n  int y_local_size = y_size / size;\n\n  int x_local_start = x_local_size * rank;\n  int y_local_start = y_local_size * rank;\n\n  int x_local_end = x_local_start + x_local_size;\n  int y_local_end = y_local_start + y_local_size;\n\n  std::vector<int> x_local(x_local_end - x_local_start);\n  std::vector<int> y_local(y_local_end - y_local_start);\n\n  MPI_Scatter(&x[x_local_start], x_local_size, MPI_INT, &x_local[0], x_local_size, MPI_INT, 0, MPI_COMM_WORLD);\n  MPI_Scatter(&y[y_local_start], y_local_size, MPI_INT, &y_local[0], y_local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n  bool result = false;\n\n  for (int i = 0; i < x_local.size(); i++) {\n    if (x_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  for (int i = 0; i < y_local.size(); i++) {\n    if (y_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_local = result;\n  int result_global;\n\n  MPI_Reduce(&result_local, &result_global, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result_global;\n}",True,True,8.7136e-06,14,0.0,True,False,0.0026454354,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // compute the number of elements in x and y\n  int x_size = x.size();\n  int y_size = y.size();\n\n  // compute the number of elements in x and y that are less than val\n  int x_less = 0;\n  int y_less = 0;\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] < val) {\n      x_less++;\n    }\n  }\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] < val) {\n      y_less++;\n    }\n  }\n\n  // compute the number of elements in x and y that are greater than val\n  int x_greater = 0;\n  int y_greater = 0;\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] > val) {\n      x_greater++;\n    }\n  }\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] > val) {\n      y_greater++;\n    }\n  }\n\n  // compute the number of elements in x and y that are equal to val\n  int x_equal = 0;\n  int y_equal = 0;\n  for (int i = 0; i < x_size; i++) {\n    if (x[i] == val) {\n      x_equal++;\n    }\n  }\n  for (int i = 0; i < y_size; i++) {\n    if (y[i] == val) {\n      y_equal++;\n    }\n  }\n\n  // compute the number of elements in x and y that are not equal to val\n  int x_not_equal = x_size - x_equal;\n  int y_not_equal = y_size - y_equal;\n\n  // compute the number of elements in x and y that are greater than val\n  int x_greater_equal = x_size - x_less;\n  int y_greater_equal = y_size - y_less;\n\n  // compute the number of elements in x and y that are less than val\n  int x_less_equal = x_greater_equal - x_greater;\n  int y_less_equal = y_greater_equal - y_greater;\n\n  // compute the number of elements in x and y that are not less than val\n  int x_not_less = x_less_equal - x_less;\n  int y_not_less = y_less_equal - y_less;\n\n  // compute the number of elements in x and y that are not greater than val\n  int x_not_greater = x_greater - x_greater_equal;\n  int y_not_greater = y_greater - y_greater_equal;\n\n  // compute the number of elements in x and y that are not equal to val\n  int x_not_equal_equal = x_not_equal - x_equal;\n  int y_not_equal_equal = y_not_equal - y_equal;\n\n  // compute the number of elements in x and y that are not less than val\n  int x_not_less_less = x_not_less - x_less;\n  int y_not_less_less = y_not_less - y_less;\n\n  // compute the number of elements in x and y that are not greater than val\n  int x_not_greater_greater = x_not_greater - x_greater;\n  int y_not_greater_greater = y_not_greater - y_greater;\n\n  // compute the number of elements in x and y that are not equal to val\n  int x_not_equal_not_equal = x_not_equal_equal - x_equal;\n  int y_not_equal_not_equal = y_not_equal_equal - y_equal;\n\n  // compute the number of elements in x and y that are not less than val\n  int x_not_less_not_less = x_not_less_less - x_less;\n  int y_not_less_not_less = y_not_less_less - y_less;\n\n  // compute the number of elements in x and y that are not greater than val\n  int x_not_greater_not_greater = x_not_greater_greater - x_greater;\n  int y_not_greater_not_greater = y_not_greater_greater - y_greater;\n\n  // compute the",False,True,,15,,,,,,
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,0.0,True,True,1.0731e-06,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,1.0,True,True,1.12675e-06,,2.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,2.0,True,True,1.419025e-06,,4.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,3.0,True,True,1.3514e-06,,8.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,4.0,True,True,1.6537125e-06,,16.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,5.0,True,True,5.65004375e-06,,32.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into sub-vectors\n  std::vector<int> x_sub(x.begin() + rank, x.begin() + rank + size);\n  std::vector<int> y_sub(y.begin() + rank, y.begin() + rank + size);\n\n  // find the xor of the sub-vectors\n  std::vector<int> x_xor(x_sub.size());\n  std::vector<int> y_xor(y_sub.size());\n  std::transform(x_sub.begin(), x_sub.end(), y_sub.begin(), x_xor.begin(), std::bit_xor<int>());\n\n  // find the rank of the xor value\n  int x_xor_rank = std::distance(x_xor.begin(), std::find(x_xor.begin(), x_xor.end(), val));\n  int y_xor_rank = std::distance(y_xor.begin(), std::find(y_xor.begin(), y_xor.end(), val));\n\n  // return true if the xor value is in only one of the sub-vectors\n  return x_xor_rank!= y_xor_rank;\n}",True,True,8.635e-06,16,6.0,True,False,5.15378437e-06,,64.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_start = x_size * rank / size;\n  int x_end = x_size * (rank + 1) / size;\n\n  int y_start = y_size * rank / size;\n  int y_end = y_size * (rank + 1) / size;\n\n  bool found = false;\n  for (int i = x_start; i < x_end; i++) {\n    if (x[i] == val) {\n      found = true;\n      break;\n    }\n  }\n  for (int i = y_start; i < y_end; i++) {\n    if (y[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  int found_int = found? 1 : 0;\n  int result;\n  MPI_Reduce(&found_int, &result, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n  return result == 1;\n}",True,True,9.059e-06,17,0.0,True,False,1.23031e-05,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_start = x_size / size * rank;\n  int x_end = x_size / size * (rank + 1);\n  int y_start = y_size / size * rank;\n  int y_end = y_size / size * (rank + 1);\n\n  std::vector<int> x_local(x.begin() + x_start, x.begin() + x_end);\n  std::vector<int> y_local(y.begin() + y_start, y.begin() + y_end);\n\n  std::vector<int> x_local_xor(x_local.size());\n  std::vector<int> y_local_xor(y_local.size());\n\n  for (int i = 0; i < x_local.size(); i++) {\n    x_local_xor[i] = x_local[i] ^ val;\n  }\n\n  for (int i = 0; i < y_local.size(); i++) {\n    y_local_xor[i] = y_local[i] ^ val;\n  }\n\n  std::vector<int> x_local_xor_all(x_local_xor.size());\n  std::vector<int> y_local_xor_all(y_local_xor.size());\n\n  MPI_Allreduce(x_local_xor.data(), x_local_xor_all.data(), x_local_xor.size(), MPI_INT, MPI_BOR, MPI_COMM_WORLD);\n  MPI_Allreduce(y_local_xor.data(), y_local_xor_all.data(), y_local_xor.size(), MPI_INT, MPI_BOR, MPI_COMM_WORLD);\n\n  for (int i = 0; i < x_local_xor_all.size(); i++) {\n    if (x_local_xor_all[i] == 0) {\n      return true;\n    }\n  }\n\n  for (int i = 0; i < y_local_xor_all.size(); i++) {\n    if (y_local_xor_all[i] == 0) {\n      return true;\n    }\n  }\n\n  return false;\n}",True,True,9.3286e-06,18,0.0,True,False,0.0090398689,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,0.0,True,True,0.0021741692,,1.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,1.0,True,True,0.00166788465,,2.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,2.0,True,True,0.0014956758,,4.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,3.0,True,True,0.0015554267625,,8.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,4.0,True,True,0.0007066853375,,16.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,5.0,True,True,0.001235848125,,32.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,6.0,True,True,0.00013260736094,,64.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,7.0,True,True,0.00014408575703,,128.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,8.0,True,True,0.00010609056016,,256.0
"#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the vectors into equal chunks\n  int chunkSize = x.size() / size;\n  std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n  std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n  // search for the value in the chunks\n  bool in_x = std::find(x_chunk.begin(), x_chunk.end(), val)!= x_chunk.end();\n  bool in_y = std::find(y_chunk.begin(), y_chunk.end(), val)!= y_chunk.end();\n\n  // reduce the results to rank 0\n  int in_x_int = in_x;\n  int in_y_int = in_y;\n  MPI_Reduce(&in_x_int, &in_x, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&in_y_int, &in_y, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  // return the result\n  return in_x!= in_y;\n}",True,True,9.112e-06,19,9.0,True,True,0.00011551346172,,512.0
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,2.324e-07,0,0.0,True,True,1.401600009e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        *found = (*x == val) ^ (*y == val);\n    }\n},True,True,2.334e-07,1,0.0,True,True,2.389439996e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n    bool local_found = false;\n\n    while (gid < N) {\n        int x_val = x[gid];\n        int y_val = y[gid];\n        int xor_val = x_val ^ y_val;\n        if (xor_val == val) {\n            local_found = true;\n            break;\n        }\n        gid += stride;\n    }\n\n    // reduce local_found across all threads in the block\n    __shared__ bool shared_found;\n    if (tid == 0) {\n        shared_found = local_found;\n    }\n    __syncthreads();\n\n    // reduce shared_found across all blocks\n    if (tid == 0) {\n        atomicOr(found, shared_found);\n    }\n}",False,True,,2,,,,,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x;\n    int stride = blockDim.x;\n\n    int i = gid * stride + tid;\n    if (i < N) {\n        int x_val = x[i];\n        int y_val = y[i];\n        int xor_val = x_val ^ y_val;\n        if (xor_val == val) {\n            *found = true;\n        }\n    }\n},True,True,2.246e-07,3,0.0,True,False,3.29951996e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        *found = *found ^ (x[tid] == val) ^ (y[tid] == val);\n    }\n},True,True,2.205e-07,4,0.0,True,True,0.00010023999959,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    int sum = 0;\n    while (i < N) {\n        sum ^= x[i] ^ y[i];\n        i += blockDim.x * gridDim.x;\n    }\n    __shared__ int s_sum;\n    if (tid == 0) {\n        s_sum = sum;\n    }\n    __syncthreads();\n    if (tid == 0) {\n        *found = (s_sum & (1 << (val - 1)))!= 0;\n    }\n},True,True,2.274e-07,5,0.0,True,True,2.31552003e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    __shared__ int x_shared[1024];\n    __shared__ int y_shared[1024];\n    if (tid < N) {\n        x_shared[tid] = x[tid];\n        y_shared[tid] = y[tid];\n    }\n    __syncthreads();\n    if (tid < N) {\n        *found = *found ^ (x_shared[tid] == val) ^ (y_shared[tid] == val);\n    }\n},True,True,2.293e-07,6,0.0,True,True,4.519359935e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    __shared__ bool found_local;\n    if (tid == 0) {\n        found_local = false;\n    }\n    __syncthreads();\n    for (int i = tid; i < N; i += blockDim.x) {\n        found_local = found_local ^ (x[i] == val) ^ (y[i] == val);\n    }\n    __syncthreads();\n    if (tid == 0) {\n        *found = found_local;\n    }\n},True,True,2.265e-07,7,0.0,True,True,0.00941506557465,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n  int gid = blockIdx.x * blockDim.x + tid;\n  int stride = blockDim.x * gridDim.x;\n  bool myFound = false;\n\n  for (int i = gid; i < N; i += stride) {\n    if (x[i] == val) {\n      myFound = true;\n      break;\n    }\n    if (y[i] == val) {\n      myFound = true;\n      break;\n    }\n  }\n\n  __syncthreads();\n\n  if (tid == 0) {\n    *found = myFound;\n  }\n},True,True,2.323e-07,8,0.0,True,True,2.752000038e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n  if (tid < N) {\n    *found = *found ^ (x[tid] == val) ^ (y[tid] == val);\n  }\n},True,True,2.556e-07,9,0.0,True,True,0.00011594560072,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    // hint: use atomicAdd() to update the value of `found`\n},True,True,2.376e-07,10,0.0,True,True,1.682560006e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n  int i = blockIdx.x * blockDim.x + tid;\n  if (i < N) {\n    *found = (*found) ^ ((x[i] ^ val) == (y[i] ^ val));\n  }\n},True,True,3.118e-07,11,0.0,True,True,0.00011330560073,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        *found = *found ^ (x[tid] == val) ^ (y[tid] == val);\n    }\n},True,True,2.334e-07,12,0.0,True,True,0.00011353920028,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int i = blockIdx.x * blockDim.x + tid;\n    int sum = 0;\n    while (i < N) {\n        sum += (x[i] ^ val) | (y[i] ^ val);\n        i += blockDim.x * gridDim.x;\n    }\n    __shared__ int s_sum;\n    if (tid == 0) {\n        s_sum = sum;\n    }\n    __syncthreads();\n    if (tid == 0) {\n        *found = s_sum == 0;\n    }\n},True,True,2.323e-07,13,0.0,True,True,3.053440023e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    __shared__ int x_shared[1024];\n    __shared__ int y_shared[1024];\n    x_shared[tid] = x[tid];\n    y_shared[tid] = y[tid];\n    __syncthreads();\n    if (tid < N) {\n        found[0] = found[0] ^ (x_shared[tid] == val) ^ (y_shared[tid] == val);\n    }\n},True,True,2.284e-07,14,0.0,True,True,5.45855999e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n\n    if (gid < N) {\n        int x_val = x[gid];\n        int y_val = y[gid];\n        int xor_val = x_val ^ y_val;\n        if (xor_val == val) {\n            *found = true;\n        } else if (xor_val!= 0) {\n            *found = false;\n        }\n    }\n},True,True,2.546e-07,15,0.0,True,True,4.064320028e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n  __shared__ bool found_local;\n  found_local = false;\n  for (int i = tid; i < N; i += blockDim.x) {\n    found_local = found_local ^ (x[i] == val) ^ (y[i] == val);\n  }\n  __syncthreads();\n  if (tid == 0) {\n    *found = found_local;\n  }\n},True,True,3.086e-07,16,0.0,True,True,0.00921464643478,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + tid;\n    int stride = blockDim.x * gridDim.x;\n\n    for (int i = gid; i < N; i += stride) {\n        if ((x[i] ^ val) == (y[i] ^ val)) {\n            *found = true;\n            return;\n        }\n    }\n},True,True,2.625e-07,17,0.0,True,False,3.509440031e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,2.285e-07,18,0.0,True,True,1.545599988e-05,,
"/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {",39_search_xor_contains,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = threadIdx.x;\n    __shared__ bool found_local;\n    if (tid == 0) {\n        found_local = false;\n    }\n    __syncthreads();\n    for (int i = tid; i < N; i += blockDim.x) {\n        if ((x[i] ^ val) == (y[i] ^ val)) {\n            found_local = true;\n        }\n    }\n    __syncthreads();\n    if (tid == 0) {\n        *found = found_local;\n    }\n},True,True,2.254e-07,19,0.0,True,False,0.00754524798393,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // get the size of the vectors\n    int x_size = x.size();\n    int y_size = y.size();\n\n    // get the number of elements in each vector\n    int x_elements = x_size / size;\n    int y_elements = y_size / size;\n\n    // get the number of elements in the last vector\n    int x_last_elements = x_size - x_elements * (size - 1);\n    int y_last_elements = y_size - y_elements * (size - 1);\n\n    // get the start and end index of the current rank\n    int x_start = rank * x_elements;\n    int x_end = x_start + x_elements;\n    int y_start = rank * y_elements;\n    int y_end = y_start + y_elements;\n\n    // get the last rank\n    int last_rank = size - 1;\n\n    // get the start and end index of the last rank\n    int x_last_start = last_rank * x_elements;\n    int x_last_end = x_last_start + x_last_elements;\n    int y_last_start = last_rank * y_elements;\n    int y_last_end = y_last_start + y_last_elements;\n\n    // get the result of the current rank\n    bool result = false;\n    if (rank == last_rank) {\n        result = xorContains(x.begin() + x_last_start, x.begin() + x_last_end, y.begin() + y_last_start, y.begin() + y_last_end, val);\n    } else {\n        result = xorContains(x.begin() + x_start, x.begin() + x_end, y.begin() + y_start, y.begin() + y_end, val);\n    }\n\n    // get the result of all ranks\n    bool result_all;\n    MPI_Allreduce(&result, &result_all, 1, MPI_C_BOOL, MPI_LOR, MPI_COMM_WORLD);\n\n    return result_all;\n}",False,False,,0,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the data into chunks\n  int chunkSize = x.size() / size;\n  int remainder = x.size() % size;\n  int start = rank * (chunkSize + (rank < remainder? 1 : 0));\n  int end = start + chunkSize + (rank < remainder? 1 : 0);\n\n  // get the chunk\n  std::vector<int> chunk(x.begin() + start, x.begin() + end);\n\n  // search in parallel\n  bool found = false;\n  #pragma omp parallel for\n  for (int i = 0; i < chunk.size(); i++) {\n    if (chunk[i] == val) {\n      found = true;\n      break;\n    }\n  }\n\n  // reduce the result\n  bool result;\n  MPI_Reduce(&found, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n  return result;\n}",False,True,,1,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements in x and y\n  int n_x = x.size();\n  int n_y = y.size();\n\n  // get the number of elements in x and y that are less than or equal to val\n  int n_x_less_than_or_equal_to_val = 0;\n  int n_y_less_than_or_equal_to_val = 0;\n\n  #pragma omp parallel for reduction(+:n_x_less_than_or_equal_to_val)\n  for (int i = 0; i < n_x; i++) {\n    if (x[i] <= val) {\n      n_x_less_than_or_equal_to_val++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:n_y_less_than_or_equal_to_val)\n  for (int i = 0; i < n_y; i++) {\n    if (y[i] <= val) {\n      n_y_less_than_or_equal_to_val++;\n    }\n  }\n\n  // get the number of elements in x and y that are greater than val\n  int n_x_greater_than_val = n_x - n_x_less_than_or_equal_to_val;\n  int n_y_greater_than_val = n_y - n_y_less_than_or_equal_to_val;\n\n  // get the number of elements in x and y that are equal to val\n  int n_x_equal_to_val = 0;\n  int n_y_equal_to_val = 0;\n\n  #pragma omp parallel for reduction(+:n_x_equal_to_val)\n  for (int i = 0; i < n_x; i++) {\n    if (x[i] == val) {\n      n_x_equal_to_val++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+:n_y_equal_to_val)\n  for (int i = 0; i < n_y; i++) {\n    if (y[i] == val) {\n      n_y_equal_to_val++;\n    }\n  }\n\n  // get the number of elements in x and y that are less than val\n  int n_x_less_than_val = n_x_less_than_or_equal_to_val - n_x_equal_to_val;\n  int n_y_less_than_val = n_y_less_than_or_equal_to_val - n_y_equal_to_val;\n\n  // get the number of elements in x and y that are greater than or equal to val\n  int n_x_greater_than_or_equal_to_val = n_x - n_x_less_than_val;\n  int n_y_greater_than_or_equal_to_val = n_y - n_y_less_than_val;\n\n  // get the number of elements in x and y that are not equal to val\n  int n_x_not_equal_to_val = n_x_equal_to_val - n_x_less_than_val;\n  int n_y_not_equal_to_val = n_y_equal_to_val - n_y_less_than_val;\n\n  // get the number of elements in x and y that are not less than val\n  int n_x_not_less_than_val = n_x_less_than_or_equal_to_val - n_x_equal_to_val;\n  int n_y_not_less_than_val = n_y_less_than_or_equal_to_val - n_y_equal_to_val;\n\n  // get the number of elements in x and y that are not greater than val\n  int n_x_not_greater_than_val = n_x_greater_than_or_equal_to_val - n_x_equal_to_val;\n  int n_y_not_greater_than_val = n_y_greater_than_or_equal_to_val - n_y_equal_to_val;\n\n  // get the number of elements in x and y that are not less than or equal to val\n  int n_x_not_less_than_or_equal_to_",False,True,,2,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_xor = 0;\n  for (int i = 0; i < x.size(); i++) {\n    local_xor ^= x[i];\n  }\n  for (int i = 0; i < y.size(); i++) {\n    local_xor ^= y[i];\n  }\n\n  int global_xor = 0;\n  MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (global_xor & val)!= 0;\n  } else {\n    return false;\n  }\n}",True,False,8.5912e-06,3,0.0,True,False,0.0013127192,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,0.0,True,True,0.0028615196,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,1.0,True,True,0.0027774398,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,2.0,True,True,0.0022278671,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,3.0,True,True,0.0028107115,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,4.0,True,True,0.0034196394,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,5.0,True,True,0.0039960636,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,6.0,True,True,0.0054610477,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,7.0,True,True,0.0017753029,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,8.0,True,True,0.00173008355,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,9.0,True,True,0.00169076945,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,10.0,True,True,0.00176507065,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,11.0,True,True,0.0022436553,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,12.0,True,True,0.00253824485,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,13.0,True,True,0.00301639505,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,14.0,True,True,0.002906877375,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,15.0,True,True,0.001517028725,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,16.0,True,True,0.0016017329,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,17.0,True,True,0.00157793665,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,18.0,True,True,0.001755056475,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,19.0,True,True,0.001995808075,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n  int m = y.size();\n\n  int rank;\n  int size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n_local = n / size;\n  int m_local = m / size;\n\n  int start = n_local * rank;\n  int end = start + n_local;\n\n  std::vector<int> x_local(x.begin() + start, x.begin() + end);\n  std::vector<int> y_local(y.begin() + start, y.begin() + end);\n\n  int n_local_xor = 0;\n  int m_local_xor = 0;\n\n  #pragma omp parallel for reduction(+: n_local_xor)\n  for (int i = 0; i < n_local; i++) {\n    if (x_local[i] == val) {\n      n_local_xor++;\n    }\n  }\n\n  #pragma omp parallel for reduction(+: m_local_xor)\n  for (int i = 0; i < m_local; i++) {\n    if (y_local[i] == val) {\n      m_local_xor++;\n    }\n  }\n\n  int n_xor = 0;\n  int m_xor = 0;\n  MPI_Reduce(&n_local_xor, &n_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&m_local_xor, &m_xor, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (n_xor == 1) ^ (m_xor == 1);\n  } else {\n    return false;\n  }\n}",True,True,9.1913e-06,4,20.0,True,True,0.002341179625,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,int n = x.size();\n    int m = y.size();\n    int nthreads = omp_get_max_threads();\n    int nprocs = 0;\n    int rank = 0;\n    int nperproc = 0;\n    int nleft = 0;\n    int nright = 0;\n    int nfound = 0;\n    int nfound_local = 0;\n    int nfound_global = 0;\n    int nfound_global_final = 0;\n    int nfound_local_final = 0;\n    int nfound_local_final_all = 0;\n    int nfound_global_final_all = 0;\n    int nfound_global_final_all_final = 0;\n    int nfound_local_final_all_final = 0;\n    int nfound_local_final_all_final_all = 0;\n    int nfound_global_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final_all = 0;\n    int nfound_global_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final_all_final = 0;\n    int nfound_local_final_all_final_all_final_all_,False,False,,5,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int m = y.size();\n\n  int local_xor = 0;\n  for (int i = 0; i < n; i++) {\n    local_xor ^= x[i];\n  }\n  for (int i = 0; i < m; i++) {\n    local_xor ^= y[i];\n  }\n\n  int global_xor = 0;\n  MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (global_xor & val)!= 0;\n  } else {\n    return false;\n  }\n}",True,False,9.8555e-06,6,0.0,True,False,0.0013184763,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n    int m = y.size();\n    int rank;\n    int nprocs;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n    int chunk = n / nprocs;\n    int start = rank * chunk;\n    int end = start + chunk;\n    if (rank == nprocs - 1) {\n        end = n;\n    }\n    std::vector<int> local_x(x.begin() + start, x.begin() + end);\n    std::vector<int> local_y(y.begin() + start, y.begin() + end);\n    int local_xor = 0;\n    #pragma omp parallel for reduction(|:local_xor)\n    for (int i = 0; i < local_x.size(); i++) {\n        local_xor |= local_x[i] ^ local_y[i];\n    }\n    int global_xor = 0;\n    MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n    return (global_xor & val)!= 0;\n}",True,True,9.639e-06,7,0.0,True,False,0.0028352036,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_xor = 0;\n    #pragma omp parallel for reduction(|:local_xor)\n    for (int i = 0; i < x.size(); i++) {\n        local_xor |= (x[i] == val) ^ (y[i] == val);\n    }\n\n    int global_xor = 0;\n    MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n    return global_xor;\n}",True,True,9.1684e-06,8,0.0,True,False,0.0003474332,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // get the size of the smaller vector\n    int x_size = x.size();\n    int y_size = y.size();\n    int min_size = x_size < y_size? x_size : y_size;\n\n    // get the size of the larger vector\n    int max_size = x_size > y_size? x_size : y_size;\n\n    // get the number of elements that are in the smaller vector\n    int num_in_x = 0;\n    int num_in_y = 0;\n    #pragma omp parallel for reduction(+:num_in_x)\n    for (int i = 0; i < min_size; i++) {\n        if (x[i] == val) {\n            num_in_x++;\n        }\n        if (y[i] == val) {\n            num_in_y++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_max = 0;\n    #pragma omp parallel for reduction(+:num_in_max)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_max++;\n        }\n        if (y[i] == val) {\n            num_in_max++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_min = 0;\n    #pragma omp parallel for reduction(+:num_in_min)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_min++;\n        }\n        if (y[i] == val) {\n            num_in_min++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_both = 0;\n    #pragma omp parallel for reduction(+:num_in_both)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_both++;\n        }\n        if (y[i] == val) {\n            num_in_both++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_neither = 0;\n    #pragma omp parallel for reduction(+:num_in_neither)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_neither++;\n        }\n        if (y[i] == val) {\n            num_in_neither++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_one = 0;\n    #pragma omp parallel for reduction(+:num_in_one)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_one++;\n        }\n        if (y[i] == val) {\n            num_in_one++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_both_or_neither = 0;\n    #pragma omp parallel for reduction(+:num_in_both_or_neither)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_both_or_neither++;\n        }\n        if (y[i] == val) {\n            num_in_both_or_neither++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_both_or_one = 0;\n    #pragma omp parallel for reduction(+:num_in_both_or_one)\n    for (int i = min_size; i < max_size; i++) {\n        if (x[i] == val) {\n            num_in_both_or_one++;\n        }\n        if (y[i] == val) {\n            num_in_both_or_one++;\n        }\n    }\n\n    // get the number of elements that are in the larger vector\n    int num_in_one_or_neither = 0;\n    #pragma omp parallel for reduction(+:num_in_one_or_neither)\n    for (int i",False,True,,9,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int x_size = x.size();\n  int y_size = y.size();\n\n  int x_start = x_size * rank / size;\n  int x_end = x_size * (rank + 1) / size;\n  int y_start = y_size * rank / size;\n  int y_end = y_size * (rank + 1) / size;\n\n  int x_local_size = x_end - x_start;\n  int y_local_size = y_end - y_start;\n\n  std::vector<int> x_local(x_local_size);\n  std::vector<int> y_local(y_local_size);\n\n  std::copy(x.begin() + x_start, x.begin() + x_end, x_local.begin());\n  std::copy(y.begin() + y_start, y.begin() + y_end, y_local.begin());\n\n  bool result = false;\n  #pragma omp parallel for\n  for (int i = 0; i < x_local_size; i++) {\n    if (x_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  #pragma omp parallel for\n  for (int i = 0; i < y_local_size; i++) {\n    if (y_local[i] == val) {\n      result = true;\n      break;\n    }\n  }\n\n  int result_local = result;\n  MPI_Reduce(&result_local, &result, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result;\n}",False,True,,10,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // number of elements in x and y\n  int n_x = x.size();\n  int n_y = y.size();\n\n  // number of elements in x and y that are less than val\n  int n_less_x = 0;\n  int n_less_y = 0;\n\n  // number of elements in x and y that are greater than val\n  int n_greater_x = 0;\n  int n_greater_y = 0;\n\n  // number of elements in x and y that are equal to val\n  int n_equal_x = 0;\n  int n_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not less than val\n  int n_not_less_x = 0;\n  int n_not_less_y = 0;\n\n  // number of elements in x and y that are not greater than val\n  int n_not_greater_x = 0;\n  int n_not_greater_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;\n  int n_not_equal_y = 0;\n\n  // number of elements in x and y that are not equal to val\n  int n_not_equal_x = 0;",False,False,,11,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_xor = 0;\n    #pragma omp parallel for reduction(|:local_xor)\n    for (int i = 0; i < x.size(); i++) {\n        local_xor |= (x[i] == val) ^ (y[i] == val);\n    }\n\n    int global_xor = 0;\n    MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n    return global_xor;\n}",True,True,9.047e-06,12,0.0,True,False,0.0003470023,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_xor = 0;\n  for (int i = 0; i < x.size(); i++) {\n    local_xor ^= x[i];\n  }\n  for (int i = 0; i < y.size(); i++) {\n    local_xor ^= y[i];\n  }\n\n  int global_xor = 0;\n  MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_xor & val;\n  } else {\n    return false;\n  }\n}",True,False,8.4617e-06,13,0.0,True,False,0.001314201,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_xor = 0;\n  for (int i = 0; i < x.size(); i++) {\n    local_xor ^= x[i];\n  }\n  for (int i = 0; i < y.size(); i++) {\n    local_xor ^= y[i];\n  }\n\n  int global_xor = 0;\n  MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return (global_xor & val)!= 0;\n  } else {\n    return false;\n  }\n}",True,False,8.6442e-06,14,0.0,True,False,0.0013154625,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,int n = x.size();\n  int m = y.size();\n  int nthreads = omp_get_max_threads();\n  int nprocs = 0;\n  int rank = 0;\n  int nperproc = 0;\n  int nperthread = 0;\n  int nperproc_x = 0;\n  int nperproc_y = 0;\n  int nperthread_x = 0;\n  int nperthread_y = 0;\n  int nperproc_x_start = 0;\n  int nperproc_y_start = 0;\n  int nperthread_x_start = 0;\n  int nperthread_y_start = 0;\n  int nperproc_x_end = 0;\n  int nperproc_y_end = 0;\n  int nperthread_x_end = 0;\n  int nperthread_y_end = 0;\n  int nperproc_x_offset = 0;\n  int nperproc_y_offset = 0;\n  int nperthread_x_offset = 0;\n  int nperthread_y_offset = 0;\n  int nperproc_x_local = 0;\n  int nperproc_y_local = 0;\n  int nperthread_x_local = 0;\n  int nperthread_y_local = 0;\n  int nperproc_x_local_start = 0;\n  int nperproc_y_local_start = 0;\n  int nperthread_x_local_start = 0;\n  int nperthread_y_local_start = 0;\n  int nperproc_x_local_end = 0;\n  int nperproc_y_local_end = 0;\n  int nperthread_x_local_end = 0;\n  int nperthread_y_local_end = 0;\n  int nperproc_x_local_offset = 0;\n  int nperproc_y_local_offset = 0;\n  int nperthread_x_local_offset = 0;\n  int nperthread_y_local_offset = 0;\n  int nperproc_x_local_index = 0;\n  int nperproc_y_local_index = 0;\n  int nperthread_x_local_index = 0;\n  int nperthread_y_local_index = 0;\n  int nperproc_x_local_index_start = 0;\n  int nperproc_y_local_index_start = 0;\n  int nperthread_x_local_index_start = 0;\n  int nperthread_y_local_index_start = 0;\n  int nperproc_x_local_index_end = 0;\n  int nperproc_y_local_index_end = 0;\n  int nperthread_x_local_index_end = 0;\n  int nperthread_y_local_index_end = 0;\n  int nperproc_x_local_index_offset = 0;\n  int nperproc_y_local_index_offset = 0;\n  int nperthread_x_local_index_offset = 0;\n  int nperthread_y_local_index_offset = 0;\n  int nperproc_x_local_index_start_offset = 0;\n  int nperproc_y_local_index_start_offset = 0;\n  int nperthread_x_local_index_start_offset = 0;\n  int nperthread_y_local_index_start_offset = 0;\n  int nperproc_x_local_index_end_offset = 0;\n  int nperproc_y_local_index_end_offset = 0;\n  int nperthread_x_local_index_end_offset = 0;\n  int nperthread_y_local_index_end_offset = 0;\n  int nperproc_x_local_index_offset_offset = 0;\n  int nperproc_y_local_index_offset_offset = 0;\n  int nperthread_x_local_index_offset_offset = 0;\n  int nperthread_y_local_index_offset_offset = 0;\n  int nperproc_x_local_index_start_offset_offset = 0;\n  int nperproc_y_local_index_start_offset_offset,False,False,,15,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // split the input vectors into `size` chunks\n  int chunkSize = x.size() / size;\n  int remainder = x.size() % size;\n\n  // get the start and end indices of the chunk\n  int start = rank * chunkSize;\n  int end = start + chunkSize;\n\n  // add the remainder to the end index\n  if (rank < remainder) {\n    end++;\n  }\n\n  // get the chunk of x and y\n  std::vector<int> chunkX(x.begin() + start, x.begin() + end);\n  std::vector<int> chunkY(y.begin() + start, y.begin() + end);\n\n  // get the result of the xor operation\n  bool result = false;\n  #pragma omp parallel for reduction(|:result)\n  for (int i = 0; i < chunkX.size(); i++) {\n    result |= (chunkX[i] == val) ^ (chunkY[i] == val);\n  }\n\n  // get the result from rank 0\n  int result_int = 0;\n  MPI_Reduce(&result, &result_int, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n  return result_int;\n}",True,True,8.7824e-06,16,0.0,True,False,0.0041028489,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n    int m = y.size();\n    int nprocs, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    int chunk = n / nprocs;\n    int start = rank * chunk;\n    int end = start + chunk;\n    if (rank == nprocs - 1) {\n        end = n;\n    }\n    int local_xor = 0;\n    for (int i = start; i < end; i++) {\n        local_xor ^= x[i];\n    }\n    for (int i = 0; i < m; i++) {\n        local_xor ^= y[i];\n    }\n    int global_xor = 0;\n    MPI_Reduce(&local_xor, &global_xor, 1, MPI_INT, MPI_BOR, 0, MPI_COMM_WORLD);\n    return global_xor & val;\n}",True,False,8.5691e-06,17,0.0,True,False,0.0013128818,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int n = x.size();\n    int m = y.size();\n    int rank;\n    int size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int local_xor = 0;\n    int local_xor_count = 0;\n    int local_xor_count_total = 0;\n    int local_xor_count_total_all = 0;\n    int local_xor_count_total_all_all = 0;\n    int local_xor_count_total_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all = 0;\n    int local_xor_count_total_all_all_all_all_all_all_all",False,False,,18,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",39_search_xor_contains,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // split the input vectors into chunks\n    int chunkSize = x.size() / size;\n    std::vector<int> x_chunk(x.begin() + rank * chunkSize, x.begin() + (rank + 1) * chunkSize);\n    std::vector<int> y_chunk(y.begin() + rank * chunkSize, y.begin() + (rank + 1) * chunkSize);\n\n    // search for val in x_chunk and y_chunk in parallel\n    bool found = false;\n    #pragma omp parallel for\n    for (int i = 0; i < x_chunk.size(); i++) {\n        if (x_chunk[i] == val || y_chunk[i] == val) {\n            found = true;\n        }\n    }\n\n    // gather the results from all ranks\n    bool result;\n    MPI_Reduce(&found, &result, 1, MPI_C_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    return result;\n}",True,True,8.9348e-06,19,0.0,True,False,0.0036877078,1.0,1.0
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,0.0,True,True,0.0130371455,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,1.0,True,True,0.0065477504,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,2.0,True,True,0.0032699653,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,3.0,True,True,0.0016515803,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,4.0,True,True,0.0008440083,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& result) {\n      if (books(i).pages < 100) {\n         result = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.00295119,0,5.0,True,True,0.0008122811,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"auto last_short_book = Kokkos::View<size_t>(""last_short_book"", 1);\n   Kokkos::parallel_for(""find_last_short_book"", 0, books.extent(0), [&books, &last_short_book](size_t i) {\n      if (books(i).pages < 100) {\n         last_short_book() = i;\n      }\n   });\n   return last_short_book();\n}",False,True,,1,,,,,,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"auto last = Kokkos::View<size_t>(""last"", 1);\n   Kokkos::parallel_for(""findLastShortBook"", 0, books.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      if (books(i).pages < 100) {\n         last() = i;\n      }\n   });\n   Kokkos::fence();\n   return last();\n}",False,True,,2,,,,,,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,0.0,True,True,0.0131028488,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,1.0,True,True,0.006566646,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,2.0,True,True,0.0032884551,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,3.0,True,True,0.0016561081,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,4.0,True,True,0.0008502221,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029617576,3,5.0,True,True,0.0008188692,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,0.0,True,True,0.0131194319,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,1.0,True,True,0.0065828496,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,2.0,True,True,0.0032866128,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,3.0,True,True,0.0016559305,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,4.0,True,True,0.0008485731,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029567596,4,5.0,True,True,0.0007858333,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029872708,5,0.0,True,False,2.566e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029901251,6,0.0,True,False,3.555e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029673151,7,0.0,True,False,3.376e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,0.0,True,True,0.0130275236,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,1.0,True,True,0.0065233435,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,2.0,True,True,0.0032716879,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,3.0,True,True,0.0016452672,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,4.0,True,True,0.0008640896,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029642897,8,5.0,True,True,0.0008143342,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,0.0,True,True,0.0130386499,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,1.0,True,True,0.0065244507,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,2.0,True,True,0.0032715896,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,3.0,True,True,0.0016461151,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,4.0,True,True,0.0008436578,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029279234,9,5.0,True,True,0.0008293628,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,0.0,True,True,0.0130411625,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,1.0,True,True,0.006521053,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,2.0,True,True,0.0032738895,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,3.0,True,True,0.0016461535,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,4.0,True,True,0.0008475529,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029496841,10,5.0,True,True,0.000858277,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029974647,11,0.0,True,False,3.104e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,0.0,True,True,0.0130265249,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,1.0,True,True,0.0065609955,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,2.0,True,True,0.0032784823,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,3.0,True,True,0.0016459903,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,4.0,True,True,0.0008387865,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.0029488776,12,5.0,True,True,0.0008156077,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,0.0,True,True,0.0130376209,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,1.0,True,True,0.0065310458,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,2.0,True,True,0.0032693243,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,3.0,True,True,0.0016608949,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,4.0,True,True,0.0008469088,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(const size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002951119,13,5.0,True,True,0.0007674903,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0030017515,14,0.0,True,False,2.407e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,0.0,True,True,0.0130267575,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,1.0,True,True,0.0065556925,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,2.0,True,True,0.003271623,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,3.0,True,True,0.0016498469,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,4.0,True,True,0.0008425246,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029500122,15,5.0,True,True,0.000788234,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,0.0,True,True,0.0130208358,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,1.0,True,True,0.0065217984,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,2.0,True,True,0.0032706595,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,3.0,True,True,0.0016477943,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,4.0,True,True,0.0008633628,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t result = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& max_i) {\n      if (books(i).pages < 100) {\n         max_i = i;\n      }\n   }, Kokkos::Max<size_t>(result));\n   return result;\n}",True,True,0.0029581855,16,5.0,True,True,0.0007871173,32.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029873966,17,0.0,True,False,2.893e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n   return 0;\n},True,True,0.0029823358,18,0.0,True,False,3.179e-07,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,0.0,True,True,0.013031996,1.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,1.0,True,True,0.006531145,2.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,2.0,True,True,0.0032723416,4.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,3.0,True,True,0.0016460207,8.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,4.0,True,True,0.0008416672,16.0,
"#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,kokkos,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   Kokkos::parallel_reduce(books.extent(0), KOKKOS_LAMBDA(size_t i, size_t& last_short_book) {\n      if (books(i).pages < 100) {\n         last_short_book = i;\n      }\n   }, Kokkos::Max<size_t>(last_short_book));\n   return last_short_book;\n}",True,True,0.002953083,19,5.0,True,True,0.000822943,32.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00288391809445,0,0.0,True,True,0.0031774390256,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00288391809445,0,1.0,True,True,0.00217406498268,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00288391809445,0,2.0,True,False,0.00211660603527,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287623370532,1,0.0,True,True,0.00317790871486,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287623370532,1,1.0,True,True,0.00211278770585,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287623370532,1,2.0,True,False,0.00213288464583,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00288551165722,2,0.0,True,True,0.00317094800994,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00288551165722,2,1.0,True,True,0.00215114459861,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00288551165722,2,2.0,True,False,0.00213303579949,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287684584036,3,0.0,True,True,0.00316189879086,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287684584036,3,1.0,True,True,0.00215538588818,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287684584036,3,2.0,True,False,0.00210908870213,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0028417468071,4,0.0,True,True,0.00318067732733,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0028417468071,4,1.0,True,True,0.00210707681254,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0028417468071,4,2.0,True,False,0.00219455850311,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00282891066745,5,0.0,True,True,0.00316096323077,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00282891066745,5,1.0,True,True,0.00215310552157,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00282891066745,5,2.0,True,False,0.00218130243011,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00283539269585,6,0.0,True,True,0.00318596402649,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00283539269585,6,1.0,True,True,0.00216618804261,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00283539269585,6,2.0,True,False,0.00219145158771,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00283545900602,7,0.0,True,True,0.00318639392499,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00283545900602,7,1.0,True,True,0.00215002465993,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00283545900602,7,2.0,True,False,0.00207912730984,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBookIndex = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBookIndex = i;\n      }\n   }\n   return lastShortBookIndex;\n},True,True,0.00284459413961,8,0.0,True,True,0.00315977612045,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBookIndex = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBookIndex = i;\n      }\n   }\n   return lastShortBookIndex;\n},True,True,0.00284459413961,8,1.0,True,True,0.00213165818714,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBookIndex = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBookIndex = i;\n      }\n   }\n   return lastShortBookIndex;\n},True,True,0.00284459413961,8,2.0,True,False,0.00211142825428,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,0.0,True,True,0.00313389033545,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,1.0,True,True,0.00209751087241,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,2.0,True,True,0.00214349150192,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,3.0,True,True,0.00225765490904,8.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,4.0,True,True,0.00210880616214,16.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,5.0,True,True,0.00211526027415,32.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for reduction(max:result)\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00278038515244,9,6.0,True,True,0.00227322659921,64.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00291231838055,10,0.0,True,True,0.00318718559574,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00291231838055,10,1.0,True,True,0.0021548128454,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t lastShortBook = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   return lastShortBook;\n},True,True,0.00291231838055,10,2.0,True,False,0.00217437562533,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00282379300334,11,0.0,True,True,0.00316665798891,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00282379300334,11,1.0,True,True,0.00216403917875,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t result = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n   return result;\n},True,True,0.00282379300334,11,2.0,True,False,0.00211050948128,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029122201493,12,0.0,True,True,0.00316906131338,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029122201493,12,1.0,True,True,0.00216344899964,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029122201493,12,2.0,True,False,0.00219861387741,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00286970725283,13,0.0,True,True,0.00317222119775,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00286970725283,13,1.0,True,True,0.00214898688719,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00286970725283,13,2.0,True,True,0.00211029080674,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00286970725283,13,3.0,True,False,0.00229223594069,8.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287051475607,14,0.0,True,True,0.00316837611608,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287051475607,14,1.0,True,True,0.00217863556463,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00287051475607,14,2.0,True,False,0.00214261694346,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00281611464452,15,0.0,True,True,0.00318867019378,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00281611464452,15,1.0,True,True,0.00215024598874,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.00281611464452,15,2.0,True,False,0.0021533110179,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00289052946027,16,0.0,True,True,0.00317025871482,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00289052946027,16,1.0,True,True,0.00215655013453,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00289052946027,16,2.0,True,False,0.00209735548124,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00283034536988,17,0.0,True,True,0.00317816419993,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00283034536988,17,1.0,True,True,0.00213389620185,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00283034536988,17,2.0,True,False,0.00208897697739,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00287067608442,18,0.0,True,True,0.00318325501867,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00287067608442,18,1.0,True,True,0.0021368549671,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.00287067608442,18,2.0,True,False,0.00211968978401,4.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0028978111688,19,0.0,True,True,0.00317340719048,1.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0028978111688,19,1.0,True,True,0.00215910268016,2.0,
"#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,omp,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0028978111688,19,2.0,True,False,0.00214852190111,4.0,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029337884,0,0.0,True,True,0.0031997538,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = books.size() - 1;\n   while (last_short_book > 0 && books[last_short_book].pages >= 100) {\n      --last_short_book;\n   }\n   return last_short_book;\n},True,True,0.0028166768,1,0.0,True,True,0.0030110612,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,"auto it = std::find_if(books.rbegin(), books.rend(), [](Book const& book) { return book.pages < 100; });\n   return std::distance(books.rbegin(), it);\n}",True,True,0.0027462891,2,0.0,True,False,0.002698014,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,"auto it = std::find_if(books.rbegin(), books.rend(), [](Book const& b) { return b.pages < 100; });\n   return std::distance(books.rbegin(), it);\n}",True,True,0.0028912083,3,0.0,True,False,0.0027029808,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029574551,4,0.0,True,True,0.0031742816,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0029473979,5,0.0,True,True,0.0031373352,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0029424309,6,0.0,True,True,0.003135635,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n   return 0;\n},True,True,0.0026756171,7,0.0,True,True,0.0030881405,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0028244036,8,0.0,True,True,0.003144748,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0028515125,9,0.0,True,True,0.0031742529,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t index = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         index = i;\n      }\n   }\n   return index;\n},True,True,0.002853878,10,0.0,True,True,0.0031711257,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0028538139,11,0.0,True,True,0.0031424662,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0027868977,12,0.0,True,True,0.0031416935,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,"auto it = std::find_if(books.rbegin(), books.rend(), [](Book const& b) { return b.pages < 100; });\n   return std::distance(books.rbegin(), it);\n}",True,True,0.0027371109,13,0.0,True,False,0.0027054343,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = books.size();\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n   return last_short_book;\n},True,True,0.0031315644,14,0.0,True,True,0.0034313433,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,"auto it = std::find_if(books.rbegin(), books.rend(), [](Book const& book) { return book.pages < 100; });\n   return std::distance(books.rbegin(), it);\n}",True,True,0.0028598964,15,0.0,True,False,0.0027094948,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book = books.size() - 1;\n   for (size_t i = books.size() - 1; i > 0; --i) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n         break;\n      }\n   }\n   return last_short_book;\n},True,True,0.0028423753,16,0.0,True,True,0.002959413,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = books.size(); i > 0; --i) {\n      if (books[i - 1].pages < 100) {\n         return i - 1;\n      }\n   }\n   return 0;\n},True,True,0.0027726018,17,0.0,True,True,0.0030739346,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,for (size_t i = books.size(); i > 0; --i) {\n      if (books[i - 1].pages < 100) {\n         return i - 1;\n      }\n   }\n   return 0;\n},True,True,0.0028487555,18,0.0,True,True,0.0031614046,,
"struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,serial,0.2,0.95,True,1024,True,size_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n},True,True,0.0027640117,19,0.0,True,True,0.0030982547,,
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,0.0,True,True,0.0031744637,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,1.0,True,True,0.00334829355,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,2.0,True,True,0.003976609425,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,3.0,True,True,0.0040226167375,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,4.0,True,True,0.006453660675,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,5.0,True,True,0.0112295624125,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,6.0,True,True,0.02824577854688,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,7.0,True,True,0.02722257878047,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,8.0,True,True,0.02328643100938,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size();\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_index = i;\n      }\n   }\n\n   int global_index;\n   MPI_Allreduce(&local_index, &global_index, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0027979942,0,9.0,True,True,0.0370821677623,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages to search for\n   int pagesToSearch = 100;\n   int pagesToSearchPerRank = pagesToSearch / size;\n   int pagesToSearchRemainder = pagesToSearch % size;\n\n   // calculate the start and end index of the books to search for\n   int startIndex = rank * pagesToSearchPerRank;\n   int endIndex = startIndex + pagesToSearchPerRank;\n   if (rank < pagesToSearchRemainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBookIndex = 0;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBookIndex = i;\n      }\n   }\n\n   // gather the last short book index from all ranks\n   int lastShortBookIndexOnRank0;\n   MPI_Reduce(&lastShortBookIndex, &lastShortBookIndexOnRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookIndexOnRank0;\n}",True,True,0.0031639221,1,0.0,True,False,5.3071e-06,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,0.0,True,True,0.0030799223,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,1.0,True,True,0.0031109795,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,2.0,True,True,0.004319155475,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,3.0,True,True,0.00388489795,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,4.0,True,True,0.00541697345625,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,5.0,True,True,0.0059521205625,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,6.0,True,True,0.00654004938281,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,7.0,True,True,0.00978765035625,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,8.0,True,True,0.01511327740234,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_index = books.size() - 1;\n   for (int i = books.size() - 1; i >= 0; i--) {\n      if (books[i].pages < 100) {\n         local_index = i;\n         break;\n      }\n   }\n\n   int global_index = -1;\n   MPI_Reduce(&local_index, &global_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return global_index;\n}",True,True,0.0026631407,2,9.0,True,True,0.0278559430793,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,0.0,True,True,0.0031683256,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,1.0,True,True,0.0032422318,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,2.0,True,True,0.00413512415,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,3.0,True,True,0.003875509575,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,4.0,True,True,0.0050674861875,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,5.0,True,True,0.00790332179688,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,6.0,True,True,0.01205349947188,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,7.0,True,True,0.01159919516797,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,8.0,True,True,0.01694485363359,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t result = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int local_result = 0;\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_result = i;\n      }\n   }\n\n   MPI_Reduce(&local_result, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0027470317,3,9.0,True,True,0.0314450417041,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int chunk = n / size;\n   int remainder = n % size;\n\n   int start = rank * chunk;\n   int end = start + chunk;\n\n   if (rank == size - 1) {\n      end += remainder;\n   }\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   return -1;\n}",True,True,0.00325065,4,0.0,True,False,0.0003450574,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of ranks\n   int world_size;\n   MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n   // get the rank of the current process\n   int world_rank;\n   MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n   // get the number of items in the vector\n   int n = books.size();\n\n   // calculate the number of items each rank will process\n   int n_per_rank = n / world_size;\n\n   // calculate the number of items that will be left over after dividing up the items\n   int n_left_over = n % world_size;\n\n   // calculate the starting index of the current rank\n   int start_index = n_per_rank * world_rank;\n\n   // calculate the ending index of the current rank\n   int end_index = n_per_rank * (world_rank + 1);\n\n   // if the current rank is not the last rank, add the number of items that will be left over to the ending index\n   if (world_rank!= world_size - 1) {\n      end_index += n_left_over;\n   }\n\n   // create a vector of the books that will be processed by the current rank\n   std::vector<Book> books_per_rank(books.begin() + start_index, books.begin() + end_index);\n\n   // create a vector of the pages of the books that will be processed by the current rank\n   std::vector<int> pages_per_rank;\n   for (Book const& book : books_per_rank) {\n      pages_per_rank.push_back(book.pages);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a vector of the indices of the books that will be processed by the current rank\n   std::vector<int> indices_per_rank;\n   for (int i = start_index; i < end_index; i++) {\n      indices_per_rank.push_back(i);\n   }\n\n   // create a",False,True,,5,,,,,,
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages to search for\n   int pagesToSearch = 100;\n   int pagesToSearchPerRank = pagesToSearch / size;\n   int pagesToSearchForRank = pagesToSearchPerRank + (rank < pagesToSearch % size);\n\n   // calculate the start and end index of the search\n   int startIndex = books.size() * rank / size;\n   int endIndex = books.size() * (rank + 1) / size;\n\n   // search for the last book with less than pagesToSearchForRank pages\n   for (int i = endIndex - 1; i >= startIndex; --i) {\n      if (books[i].pages < pagesToSearchForRank) {\n         return i;\n      }\n   }\n\n   // if no book was found, return the end index\n   return endIndex;\n}",True,True,0.0027777124,6,0.0,True,True,0.0031947232,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages to search for\n   int pagesToSearch = 100;\n   int pagesToSearchPerRank = pagesToSearch / size;\n   int pagesToSearchForRank = pagesToSearchPerRank + (rank < pagesToSearch % size);\n\n   // calculate the start and end index of the search\n   int startIndex = books.size() * rank / size;\n   int endIndex = books.size() * (rank + 1) / size;\n\n   // search for the last book with less than pagesToSearchForRank pages\n   for (int i = endIndex - 1; i >= startIndex; --i) {\n      if (books[i].pages < pagesToSearchForRank) {\n         return i;\n      }\n   }\n\n   // if no book was found, return the end index\n   return endIndex;\n}",True,True,0.0027777124,6,1.0,True,False,0.0016970864,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will search\n   int books_per_rank = books.size() / size;\n   // calculate the number of books that the last rank will search\n   int last_rank_books = books.size() % size;\n\n   // calculate the start and end index of the books that each rank will search\n   int start_index = rank * books_per_rank;\n   int end_index = start_index + books_per_rank;\n\n   // if this is the last rank, then the end index is the end of the vector\n   if (rank == size - 1) {\n      end_index = books.size();\n   }\n\n   // search for the last short book\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // broadcast the last short book index to all ranks\n   MPI_Bcast(&last_short_book_index, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.00273617,7,0.0,True,True,0.0031584718,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will search\n   int books_per_rank = books.size() / size;\n   // calculate the number of books that the last rank will search\n   int last_rank_books = books.size() % size;\n\n   // calculate the start and end index of the books that each rank will search\n   int start_index = rank * books_per_rank;\n   int end_index = start_index + books_per_rank;\n\n   // if this is the last rank, then the end index is the end of the vector\n   if (rank == size - 1) {\n      end_index = books.size();\n   }\n\n   // search for the last short book\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // broadcast the last short book index to all ranks\n   MPI_Bcast(&last_short_book_index, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.00273617,7,1.0,True,False,0.0016501815,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n   int world_size;\n   MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n   // get the rank of the process\n   int world_rank;\n   MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n   // get the number of elements in the vector\n   int n = books.size();\n\n   // calculate the number of elements each process will work on\n   int n_per_process = n / world_size;\n\n   // calculate the number of elements each process will work on\n   int n_left = n % world_size;\n\n   // calculate the start index of the process\n   int start_index = n_per_process * world_rank;\n\n   // calculate the end index of the process\n   int end_index = start_index + n_per_process;\n\n   // if the process is not the last process, add the number of elements that are left\n   if (world_rank!= world_size - 1) {\n      end_index += n_left;\n   }\n\n   // iterate over the vector and find the last element where Book.pages < 100\n   for (int i = end_index - 1; i >= start_index; --i) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   // if no element was found, return -1\n   return -1;\n}",True,True,0.002651533,8,0.0,True,True,0.0031860617,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n   int world_size;\n   MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n   // get the rank of the process\n   int world_rank;\n   MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n   // get the number of elements in the vector\n   int n = books.size();\n\n   // calculate the number of elements each process will work on\n   int n_per_process = n / world_size;\n\n   // calculate the number of elements each process will work on\n   int n_left = n % world_size;\n\n   // calculate the start index of the process\n   int start_index = n_per_process * world_rank;\n\n   // calculate the end index of the process\n   int end_index = start_index + n_per_process;\n\n   // if the process is not the last process, add the number of elements that are left\n   if (world_rank!= world_size - 1) {\n      end_index += n_left;\n   }\n\n   // iterate over the vector and find the last element where Book.pages < 100\n   for (int i = end_index - 1; i >= start_index; --i) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   // if no element was found, return -1\n   return -1;\n}",True,True,0.002651533,8,1.0,True,False,0.0014864217,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages in the last book\n   int last_book_pages = books.back().pages;\n\n   // calculate the number of pages in the last book on each rank\n   int last_book_pages_on_rank = last_book_pages / size;\n   if (rank == size - 1) {\n      last_book_pages_on_rank += last_book_pages % size;\n   }\n\n   // calculate the number of books in the last book on each rank\n   int last_book_books_on_rank = books.size() / size;\n   if (rank == size - 1) {\n      last_book_books_on_rank += books.size() % size;\n   }\n\n   // calculate the index of the last book on each rank\n   int last_book_index_on_rank = last_book_books_on_rank - 1;\n\n   // calculate the index of the last book\n   int last_book_index = last_book_index_on_rank * size + rank;\n\n   // calculate the index of the last book on each rank\n   int last_book_pages_on_rank_index = last_book_index_on_rank * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_index = last_book_pages_on_rank_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_on_rank_index = last_book_index_on_rank * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_index = last_book_index_on_rank_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_on_rank_index_index = last_book_pages_on_rank_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_index_index = last_book_pages_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_on_rank_index_index = last_book_index_on_rank_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_index_index = last_book_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_on_rank_index_index_index = last_book_pages_on_rank_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_index_index_index = last_book_pages_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_on_rank_index_index_index = last_book_index_on_rank_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_index_index_index = last_book_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_on_rank_index_index_index_index = last_book_pages_on_rank_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_index_index_index_index = last_book_pages_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_on_rank_index_index_index_index = last_book_index_on_rank_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_index_index_index_index = last_book_index_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_on_rank_index_index_index_index_index = last_book_pages_on_rank_index_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_pages_index_index_index_index_index = last_book_pages_index_index_index_index * size + rank;\n\n   // calculate the index of the last book\n   int last_book_index_on_rank_index_index_index",False,True,,9,,,,,,
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages in the last book\n   int last_book_pages = books.back().pages;\n\n   // calculate the number of pages in the last book\n   int pages_per_rank = last_book_pages / size;\n\n   // calculate the number of pages in the last book\n   int remainder = last_book_pages % size;\n\n   // calculate the start index of the last book\n   int start_index = rank * pages_per_rank;\n\n   // calculate the end index of the last book\n   int end_index = start_index + pages_per_rank;\n\n   // if the remainder is not zero, add it to the end index\n   if (remainder!= 0) {\n      end_index += remainder;\n   }\n\n   // iterate through the books and find the last book with pages less than 100\n   for (size_t i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   // if no book was found, return the size of the vector\n   return books.size();\n}",True,True,0.0032240795,10,0.0,True,False,2.1441e-06,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,0.0,True,True,0.0031380394,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,1.0,True,True,0.00318376985,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,2.0,True,True,0.004240231275,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,3.0,True,True,0.003854707625,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,4.0,True,True,0.00669206486875,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,5.0,True,True,0.00707024686875,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,6.0,True,True,0.00768466613906,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,7.0,True,True,0.01115150875078,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,8.0,True,True,0.01727094749297,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   // find the last short book in the local vector\n   for (size_t i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   // find the last short book in the global vector\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027500811,11,9.0,True,True,0.03166499974531,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n   int size = books.size();\n   // get the rank of the process\n   int rank;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   // get the number of processes\n   int world_size;\n   MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n   // get the number of elements per process\n   int elements_per_process = size / world_size;\n   // get the remainder\n   int remainder = size % world_size;\n   // get the start index of the process\n   int start_index = rank * elements_per_process;\n   // get the end index of the process\n   int end_index = start_index + elements_per_process;\n   // if the remainder is not zero, add the remainder to the end index\n   if (remainder!= 0) {\n      end_index += remainder;\n   }\n   // get the last element of the process\n   Book last_element = books[end_index - 1];\n   // get the index of the last element of the process\n   int last_element_index = end_index - 1;\n   // get the index of the last element of the process\n   int last_short_book_index = -1;\n   // loop through the vector\n   for (int i = end_index - 2; i >= start_index; i--) {\n      // if the current element is less than 100 pages, set the index of the last short book\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   // if the last short book index is not equal to -1, set the last short book index to the last element index\n   if (last_short_book_index!= -1) {\n      last_short_book_index = last_element_index;\n   }\n   // get the result\n   int result;\n   // if the rank is 0, set the result to the last short book index\n   if (rank == 0) {\n      result = last_short_book_index;\n   }\n   // broadcast the result to all processes\n   MPI_Bcast(&result, 1, MPI_INT, 0, MPI_COMM_WORLD);\n   // return the result\n   return result;\n}",True,True,0.0026956348,12,0.0,True,False,0.0036881175,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // split books into chunks\n   std::vector<Book> chunks(size);\n   for (size_t i = 0; i < books.size(); i += size) {\n      chunks[i % size] = books[i];\n   }\n\n   // find the last book in the chunk\n   size_t last_book_index = 0;\n   for (size_t i = 0; i < chunks.size(); i++) {\n      if (chunks[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the last book index from all ranks\n   int last_book_index_global;\n   MPI_Reduce(&last_book_index, &last_book_index_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the last book index\n   return last_book_index_global;\n}",True,True,0.0028685478,13,0.0,True,False,0.0186625694,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,0.0,True,True,0.0031659769,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,1.0,True,True,0.0016441405,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,2.0,True,True,0.001948578,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,3.0,True,True,0.001110009025,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,4.0,True,True,0.0006685880375,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,5.0,True,True,0.00052156951875,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,6.0,True,True,0.00081606049375,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,7.0,True,True,0.00072358384219,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,8.0,True,True,0.00113047401719,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books that each rank will process\n   int booksPerRank = books.size() / size;\n   // calculate the number of books that the last rank will process\n   int lastRankBooks = books.size() % size;\n\n   // calculate the start and end index of the books that this rank will process\n   int start = booksPerRank * rank;\n   int end = start + booksPerRank;\n\n   // if this is the last rank, process the remaining books\n   if (rank == size - 1) {\n      end += lastRankBooks;\n   }\n\n   // find the last book that is less than 100 pages\n   size_t lastShortBook = 0;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int lastShortBookFromRank0 = 0;\n   MPI_Reduce(&lastShortBook, &lastShortBookFromRank0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result\n   return lastShortBookFromRank0;\n}",True,True,0.002734689,14,9.0,True,True,0.00042373889453,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,0.0,True,True,0.0031688101,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,1.0,True,True,0.0016689178,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,2.0,True,True,0.00187380155,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,3.0,True,True,0.0011457215875,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,4.0,True,True,0.00061702015625,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,5.0,True,True,0.00053285282812,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,6.0,True,True,0.00067286145313,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,7.0,True,True,0.00086550396328,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,8.0,True,True,0.00061799008437,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of books on each rank\n   int num_books_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // calculate the start and end index of the books on each rank\n   int start_index = num_books_per_rank * rank;\n   int end_index = start_index + num_books_per_rank;\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   // search for the last book on each rank\n   size_t last_book_index = 0;\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         last_book_index = i;\n      }\n   }\n\n   // gather the results from all ranks\n   int last_book_index_on_rank_0;\n   MPI_Reduce(&last_book_index, &last_book_index_on_rank_0, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   // return the result on rank 0\n   if (rank == 0) {\n      return last_book_index_on_rank_0;\n   } else {\n      return 0;\n   }\n}",True,True,0.002835276,15,9.0,True,True,0.00035303081289,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages\n   int pages = books.size() / size;\n   if (rank == size - 1) {\n      pages += books.size() % size;\n   }\n\n   // calculate the start index\n   int start = rank * pages;\n\n   // calculate the end index\n   int end = start + pages;\n\n   // find the last book with pages less than 100\n   for (int i = end - 1; i >= start; i--) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   // if no book with pages less than 100 was found, return -1\n   return -1;\n}",True,True,0.0026134858,16,0.0,True,True,0.0032603134,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages\n   int pages = books.size() / size;\n   if (rank == size - 1) {\n      pages += books.size() % size;\n   }\n\n   // calculate the start index\n   int start = rank * pages;\n\n   // calculate the end index\n   int end = start + pages;\n\n   // find the last book with pages less than 100\n   for (int i = end - 1; i >= start; i--) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   // if no book with pages less than 100 was found, return -1\n   return -1;\n}",True,True,0.0026134858,16,1.0,True,False,0.0014980325,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // calculate the number of pages to search for\n   int pagesToSearch = books.size() / size;\n   if (rank == size - 1) {\n      pagesToSearch += books.size() % size;\n   }\n\n   // search for the last book with less than pagesToSearch pages\n   int lastBook = 0;\n   for (int i = 0; i < pagesToSearch; ++i) {\n      if (books[books.size() - 1 - i].pages < pagesToSearch) {\n         lastBook = books.size() - 1 - i;\n         break;\n      }\n   }\n\n   // gather the result from all ranks\n   int result = 0;\n   MPI_Reduce(&lastBook, &result, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,True,0.0030068269,17,0.0,True,False,5.1297e-06,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,0.0,True,True,0.0035492714,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,1.0,True,True,0.00354695555,,2.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,2.0,True,True,0.004459880925,,4.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,3.0,True,True,0.004298339425,,8.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,4.0,True,True,0.00574005963125,,16.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,5.0,True,True,0.00599859013125,,32.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,6.0,True,True,0.00741613233438,,64.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,7.0,True,True,0.01189169175625,,128.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,8.0,True,True,0.01783041749414,,256.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int last_short_book_index = -1;\n   int last_short_book_pages = -1;\n\n   int local_last_short_book_index = -1;\n   int local_last_short_book_pages = -1;\n\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n         local_last_short_book_pages = books[i].pages;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   MPI_Reduce(&local_last_short_book_pages, &last_short_book_pages, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027842844,18,9.0,True,True,0.03163520523359,,512.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int num_books = books.size();\n   int num_books_per_rank = num_books / size;\n   int remainder = num_books % size;\n\n   int start_index = rank * num_books_per_rank;\n   int end_index = start_index + num_books_per_rank;\n\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   for (int i = end_index - 1; i >= start_index; i--) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   return -1;\n}",True,True,0.0026685059,19,0.0,True,True,0.0032623149,,1.0
"#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int num_books = books.size();\n   int num_books_per_rank = num_books / size;\n   int remainder = num_books % size;\n\n   int start_index = rank * num_books_per_rank;\n   int end_index = start_index + num_books_per_rank;\n\n   if (rank < remainder) {\n      end_index++;\n   }\n\n   for (int i = end_index - 1; i >= start_index; i--) {\n      if (books[i].pages < 100) {\n         return i;\n      }\n   }\n\n   return -1;\n}",True,True,0.0026685059,19,1.0,True,False,0.00151346875,,2.0
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,0,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n	int bid = blockIdx.x;\n	int stride = blockDim.x;\n	int start = bid * stride + tid;\n	int end = min(start + stride, N);\n\n	for (int i = start; i < end; i++) {\n		if (books[i].pages < 100) {\n			*lastShortBookIndex = i;\n		}\n	}\n}",False,True,,1,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,2,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,int i = blockIdx.x * blockDim.x + threadIdx.x;\n   if (i < N) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n},False,True,,3,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n}",False,True,,4,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBookIndex\n	// Hint: use the blockIdx.x and blockDim.x variables to determine the index of the current thread\n	// Hint: use the gridDim.x variable to determine the total number of threads in the grid\n	// Hint: use the blockIdx.x * blockDim.x + threadIdx.x formula to determine the global thread index\n	// Hint: use the atomicMin function to update lastShortBook,False,True,,5,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n}",False,True,,6,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,7,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n}",False,True,,8,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,9,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n   int last = start;\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         last = i;\n      }\n   }\n   __syncthreads();\n   if (tid == 0) {\n      *lastShortBookIndex = last;\n   }\n}",False,True,,10,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,11,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n   if (tid < N) {\n      if (books[tid].pages < 100) {\n         *lastShortBookIndex = tid;\n      }\n   }\n},False,True,,12,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n}",False,True,,13,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n   *lastShortBookIndex = 0;\n   for (int i = 0; i < N; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n},False,True,,14,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n   if (tid < N) {\n      if (books[tid].pages < 100) {\n         *lastShortBookIndex = tid;\n      }\n   }\n},False,True,,15,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},False,True,,16,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,"int tid = threadIdx.x;\n   int bid = blockIdx.x;\n   int stride = blockDim.x;\n   int start = bid * stride + tid;\n   int end = min(start + stride, N);\n\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         *lastShortBookIndex = i;\n      }\n   }\n}",False,True,,17,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n	// TODO: use the atomicMax function to update lastShortBookIndex\n	// TODO: use the atomicCAS function to update lastShortBookIndex\n},False,True,,18,,,,,,
"struct Book {\n   char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {",35_search_search_for_last_struct_by_key,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n	// hint: use atomicMin() to find the index of the last book with pages < 100\n},False,True,,19,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   if (rank == 0) {\n      last_short_book_index = books.size() - 1;\n      for (int i = 1; i < size; ++i) {\n         int last_short_book_index_from_rank;\n         MPI_Recv(&last_short_book_index_from_rank, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         if (last_short_book_index_from_rank < last_short_book_index) {\n            last_short_book_index = last_short_book_index_from_rank;\n         }\n      }\n   } else {\n      for (size_t i = 0; i < books.size(); ++i) {\n         if (books[i].pages < 100) {\n            last_short_book_index = i;\n         }\n      }\n      MPI_Send(&last_short_book_index, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n   }\n\n   return last_short_book_index;\n}",True,False,0.0030701813,0,0.0,True,False,7.022e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int num_threads = omp_get_max_threads();\n   int rank, num_ranks;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);\n   int num_books_per_rank = books.size() / num_ranks;\n   int num_books_left_over = books.size() % num_ranks;\n   int start_index = rank * num_books_per_rank;\n   int end_index = (rank + 1) * num_books_per_rank;\n   if (rank == num_ranks - 1) {\n      end_index += num_books_left_over;\n   }\n   int local_last_short_book_index = 0;\n   #pragma omp parallel for\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return last_short_book_index;\n}",True,True,0.0027919851,1,0.0,True,True,0.0031578351,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int num_threads = omp_get_max_threads();\n   int rank, num_ranks;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);\n   int num_books_per_rank = books.size() / num_ranks;\n   int num_books_left_over = books.size() % num_ranks;\n   int start_index = rank * num_books_per_rank;\n   int end_index = (rank + 1) * num_books_per_rank;\n   if (rank == num_ranks - 1) {\n      end_index += num_books_left_over;\n   }\n   int local_last_short_book_index = 0;\n   #pragma omp parallel for\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return last_short_book_index;\n}",True,True,0.0027919851,1,1.0,True,True,0.0021441382,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int num_threads = omp_get_max_threads();\n   int rank, num_ranks;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);\n   int num_books_per_rank = books.size() / num_ranks;\n   int num_books_left_over = books.size() % num_ranks;\n   int start_index = rank * num_books_per_rank;\n   int end_index = (rank + 1) * num_books_per_rank;\n   if (rank == num_ranks - 1) {\n      end_index += num_books_left_over;\n   }\n   int local_last_short_book_index = 0;\n   #pragma omp parallel for\n   for (int i = start_index; i < end_index; i++) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return last_short_book_index;\n}",True,True,0.0027919851,1,2.0,True,False,0.0021656554,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   // Hint: use MPI and OpenMP to search in parallel\n   // Hint: use MPI_Reduce to get the result from all ranks\n   // Hint: use MPI_Bcast to broadcast the result to all ranks\n\n   size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // TODO: implement this function\n   // Hint: use MPI and OpenMP to search in parallel\n   // Hint: use MPI_Reduce to get the result from all ranks\n   // Hint: use MPI_Bcast to broadcast the result to all ranks\n\n   if (rank == 0) {\n      last_short_book_index = books.size() - 1;\n      for (int i = 1; i < size; ++i) {\n         int temp;\n         MPI_Recv(&temp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         if (temp < last_short_book_index) {\n            last_short_book_index = temp;\n         }\n      }\n   } else {\n      int temp = books.size() - 1;\n      MPI_Send(&temp, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n   }\n\n   return last_short_book_index;\n}",True,False,0.0030873428,2,0.0,True,False,6.142e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // TODO: implement this function\n   // Hint: use MPI_Scatter and OpenMP to search in parallel\n   // Hint: use MPI_Reduce to get the result from all ranks\n   // Hint: use MPI_Bcast to broadcast the result from rank 0 to all ranks\n   // Hint: use MPI_Finalize to clean up MPI\n\n   return last_short_book_index;\n}",True,False,0.0030811613,3,0.0,True,False,6.212e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   int n = books.size();\n\n   // get the number of pages in the last book\n   int last_book_pages = books[n - 1].pages;\n\n   // get the number of pages in the last book\n   int last_book_index = n - 1;\n\n   // get the number of pages in the last book\n   int last_book_rank = 0;\n\n   // get the number of pages in the last book\n   int last_book_size = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_max = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_min = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_min = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_min = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_min = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_sum = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_prod = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_min_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_min_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_min_max = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_min_max = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_min_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_min_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_min_sum = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_min_sum = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_min_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_index_local_min_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_rank_local_min_prod = 0;\n\n   // get the number of pages in the last book\n   int last_book_size_local_min_prod = 1;\n\n   // get the number of pages in the last book\n   int last_book_pages_local_max_sum = 0",False,False,,4,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   int n = books.size();\n\n   // get the number of pages\n   int pages = 0;\n   for (auto const& book : books) {\n      pages += book.pages;\n   }\n\n   // get the number of pages on each rank\n   int pages_per_rank = pages / size;\n\n   // get the number of pages on the last rank\n   int pages_last_rank = pages - pages_per_rank * (size - 1);\n\n   // get the index of the last book on each rank\n   int last_book_index_per_rank = 0;\n   for (int i = 0; i < rank; i++) {\n      last_book_index_per_rank += books[i].pages;\n   }\n\n   // get the index of the last book on the last rank\n   int last_book_index_last_rank = last_book_index_per_rank + pages_per_rank;\n\n   // get the index of the last book on the last rank\n   int last_book_index = last_book_index_per_rank + pages_last_rank;\n\n   // get the index of the last book on the last rank\n   int last_book_index_local = 0;\n   for (int i = last_book_index_per_rank; i < last_book_index; i++) {\n      last_book_index_local++;\n   }\n\n   // get the index of the last book on the last rank\n   int last_book_index_global = 0;\n   MPI_Reduce(&last_book_index_local, &last_book_index_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank = 0;\n   MPI_Reduce(&last_book_index_last_rank, &last_book_index_global_last_rank, 1, MPI_INT, MPI_SUM, size - 1, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_local = 0;\n   MPI_Reduce(&last_book_index_last_rank, &last_book_index_global_last_rank_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_global = 0;\n   MPI_Reduce(&last_book_index_global_last_rank_local, &last_book_index_global_last_rank_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_global_local = 0;\n   MPI_Reduce(&last_book_index_global_last_rank_global, &last_book_index_global_last_rank_global_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_global_global = 0;\n   MPI_Reduce(&last_book_index_global_last_rank_global_local, &last_book_index_global_last_rank_global_global, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_global_global_local = 0;\n   MPI_Reduce(&last_book_index_global_last_rank_global_global, &last_book_index_global_last_rank_global_global_local, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n   // get the index of the last book on the last rank\n   int last_book_index_global_last_rank_global_global_global = 0;\n   MPI_Reduce(&last_book_index_global_last_rank_global_global_local, &last_book_index_global_last_rank_global_global_global, 1, MPI_INT",False,False,,5,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // divide the work among the ranks\n   int work_per_rank = books.size() / size;\n   int remainder = books.size() % size;\n\n   // rank 0 will search for the last book with pages less than 100\n   if (rank == 0) {\n      int last_book_index = work_per_rank + remainder;\n      for (int i = 1; i < size; ++i) {\n         MPI_Send(&last_book_index, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n      }\n   }\n\n   // every other rank will search for the last book with pages less than 100\n   if (rank > 0) {\n      int last_book_index;\n      MPI_Status status;\n      MPI_Recv(&last_book_index, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);\n\n      // search for the last book with pages less than 100\n      for (int i = work_per_rank; i < books.size(); ++i) {\n         if (books[i].pages < 100) {\n            last_book_index = i;\n         }\n      }\n\n      // send the result back to rank 0\n      MPI_Send(&last_book_index, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n   }\n\n   // rank 0 will receive the results from the other ranks\n   if (rank == 0) {\n      int last_book_index;\n      MPI_Status status;\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&last_book_index, 1, MPI_INT, i, 0, MPI_COMM_WORLD, &status);\n         if (last_book_index > work_per_rank) {\n            work_per_rank = last_book_index;\n         }\n      }\n   }\n\n   return work_per_rank;\n}",True,False,0.0031288338,6,0.0,True,False,5.831e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,0.0,True,True,0.0031367893,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,1.0,True,True,0.0031298624,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,2.0,True,True,0.0031711682,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,3.0,True,True,0.003139587,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,4.0,True,True,0.0032629942,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,5.0,True,True,0.0031634273,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,6.0,True,True,0.0031490143,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,7.0,True,True,0.00315973125,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,8.0,True,True,0.00315661035,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,9.0,True,True,0.0031367681,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,10.0,True,True,0.00316842625,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,11.0,True,True,0.0032444433,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,12.0,True,True,0.00319945385,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,13.0,True,True,0.00330382455,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,14.0,True,True,0.007219294025,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,15.0,True,True,0.003922735025,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,16.0,True,True,0.00392927245,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,17.0,True,True,0.0039613992,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,18.0,True,True,0.004052894625,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,19.0,True,True,0.0040019466,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_index = 0;\n   size_t local_result = 0;\n\n   for (auto const& book : books) {\n      if (book.pages < 100) {\n         local_result = local_index;\n      }\n      local_index++;\n   }\n\n   size_t result = 0;\n   MPI_Reduce(&local_result, &result, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return result;\n}",True,False,0.0027311685,7,20.0,True,True,0.004061146575,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // split the books vector into chunks\n   std::vector<Book> chunks;\n   for (int i = 0; i < size; ++i) {\n      chunks.push_back(books[i * books.size() / size]);\n   }\n\n   // find the last book in the chunk\n   size_t last_book_index = 0;\n   #pragma omp parallel for\n   for (int i = 0; i < size; ++i) {\n      for (int j = 0; j < chunks.size(); ++j) {\n         if (chunks[j].pages < 100) {\n            last_book_index = j;\n         }\n      }\n   }\n\n   // gather the last book index\n   int last_book_index_gathered;\n   MPI_Gather(&last_book_index, 1, MPI_INT, &last_book_index_gathered, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n   // return the last book index\n   return last_book_index_gathered;\n}",True,True,0.0032421622,8,0.0,True,False,1.15133e-05,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0028205988,9,0.0,True,True,0.0031452219,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0028205988,9,1.0,True,True,0.0020963872,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0028205988,9,2.0,True,False,0.002087787,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t lastShortBook = 0;\n   int n = books.size();\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n   int chunk = n / size;\n   int remainder = n % size;\n   int start = rank * chunk;\n   int end = start + chunk;\n   if (rank == size - 1) {\n      end += remainder;\n   }\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   int lastShortBook_global;\n   MPI_Reduce(&lastShortBook, &lastShortBook_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return lastShortBook_global;\n}",True,True,0.0028172235,10,0.0,True,True,0.0031492927,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t lastShortBook = 0;\n   int n = books.size();\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n   int chunk = n / size;\n   int remainder = n % size;\n   int start = rank * chunk;\n   int end = start + chunk;\n   if (rank == size - 1) {\n      end += remainder;\n   }\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   int lastShortBook_global;\n   MPI_Reduce(&lastShortBook, &lastShortBook_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return lastShortBook_global;\n}",True,True,0.0028172235,10,1.0,True,True,0.0021541285,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t lastShortBook = 0;\n   int n = books.size();\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n   int chunk = n / size;\n   int remainder = n % size;\n   int start = rank * chunk;\n   int end = start + chunk;\n   if (rank == size - 1) {\n      end += remainder;\n   }\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n   int lastShortBook_global;\n   MPI_Reduce(&lastShortBook, &lastShortBook_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return lastShortBook_global;\n}",True,True,0.0028172235,10,2.0,True,False,0.0020709272,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,0.0,True,True,0.0031471957,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,1.0,True,True,0.0031384366,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,2.0,True,True,0.0031788479,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,3.0,True,True,0.0032132139,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,4.0,True,True,0.0033104823,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,5.0,True,True,0.0031865967,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,6.0,True,True,0.0031322626,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book_index = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // compute the number of books to search for\n   size_t num_books_to_search = books.size() / size;\n   if (rank == size - 1) {\n      num_books_to_search += books.size() % size;\n   }\n\n   // search for the last short book\n   for (size_t i = 0; i < num_books_to_search; i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   // gather the results\n   int last_short_book_index_local = last_short_book_index;\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,False,0.0027811489,11,7.0,True,False,0.00163267255,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   int last_short_book_index_local = 0;\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027696253,12,0.0,True,True,0.0031642288,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   int last_short_book_index_local = 0;\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027696253,12,1.0,True,True,0.0021355044,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   int last_short_book_index_local = 0;\n\n   #pragma omp parallel for\n   for (int i = 0; i < books.size(); i++) {\n      if (books[i].pages < 100) {\n         last_short_book_index_local = i;\n      }\n   }\n\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0027696253,12,2.0,True,False,0.0020617407,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int chunk_size = books.size() / size;\n   int remainder = books.size() % size;\n\n   if (rank < remainder) {\n      chunk_size++;\n   }\n\n   std::vector<Book> local_books(books.begin() + rank * chunk_size, books.begin() + (rank + 1) * chunk_size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028022287,13,0.0,True,True,0.0269266822,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int chunk_size = books.size() / size;\n   int remainder = books.size() % size;\n\n   if (rank < remainder) {\n      chunk_size++;\n   }\n\n   std::vector<Book> local_books(books.begin() + rank * chunk_size, books.begin() + (rank + 1) * chunk_size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028022287,13,1.0,True,True,0.0253460432,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int chunk_size = books.size() / size;\n   int remainder = books.size() % size;\n\n   if (rank < remainder) {\n      chunk_size++;\n   }\n\n   std::vector<Book> local_books(books.begin() + rank * chunk_size, books.begin() + (rank + 1) * chunk_size);\n\n   #pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028022287,13,2.0,True,False,0.0256056201,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"size_t last_short_book = 0;\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n   // TODO: implement the parallel search\n   // Hint: use MPI_Scatterv to distribute the work\n   // Hint: use OpenMP to parallelize the search\n   // Hint: use MPI_Gatherv to gather the results\n   // Hint: use MPI_Bcast to broadcast the result\n   return last_short_book;\n}",True,False,0.0031520651,14,0.0,True,False,6.943e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int n_per_rank = n / size;\n   int remainder = n % size;\n\n   int start = rank * n_per_rank;\n   int end = start + n_per_rank;\n\n   if (rank < remainder) {\n      end++;\n   }\n\n   int last_short_book = -1;\n\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028820622,15,0.0,True,True,0.0031596162,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int n_per_rank = n / size;\n   int remainder = n % size;\n\n   int start = rank * n_per_rank;\n   int end = start + n_per_rank;\n\n   if (rank < remainder) {\n      end++;\n   }\n\n   int last_short_book = -1;\n\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028820622,15,1.0,True,True,0.0021531983,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int n_per_rank = n / size;\n   int remainder = n % size;\n\n   int start = rank * n_per_rank;\n   int end = start + n_per_rank;\n\n   if (rank < remainder) {\n      end++;\n   }\n\n   int last_short_book = -1;\n\n   #pragma omp parallel for\n   for (int i = start; i < end; i++) {\n      if (books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.0028820622,15,2.0,True,False,0.0021376925,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,0.0,True,True,0.0031489122,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,1.0,True,True,0.0031649269,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,2.0,True,True,0.0031571882,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,3.0,True,True,0.0032077584,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,4.0,True,True,0.0032148111,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,5.0,True,True,0.0031699774,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,6.0,True,True,0.003195476,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,7.0,True,True,0.001622881,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,8.0,True,True,0.0016454662,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,9.0,True,True,0.00164968825,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,10.0,True,True,0.0016386113,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,11.0,True,True,0.00163313545,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,12.0,True,True,0.00167104305,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,13.0,True,True,0.00163829465,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,14.0,True,True,0.0032927181,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,15.0,True,True,0.0017165914,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,16.0,True,True,0.001718780275,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,17.0,True,True,0.001685072425,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,18.0,True,True,0.0017098493,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,19.0,True,True,0.001745686825,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t start = rank * books.size() / size;\n   size_t end = (rank + 1) * books.size() / size;\n\n   size_t result = 0;\n   for (size_t i = start; i < end; ++i) {\n      if (books[i].pages < 100) {\n         result = i;\n      }\n   }\n\n   int result_local = 0;\n   MPI_Reduce(&result, &result_local, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n   return result_local;\n}",True,False,0.0027081043,16,20.0,True,True,0.00175592415,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int num_threads = omp_get_max_threads();\n   int num_books = books.size();\n   int num_books_per_thread = num_books / num_threads;\n   int num_books_last_thread = num_books - num_books_per_thread * (num_threads - 1);\n\n   int start_book_index = rank * num_books_per_thread;\n   int end_book_index = (rank == num_threads - 1)? num_books : (rank + 1) * num_books_per_thread;\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   #pragma omp parallel num_threads(num_threads)\n   {\n      int thread_id = omp_get_thread_num();\n      int start_book_index_local = start_book_index + thread_id * num_books_per_thread;\n      int end_book_index_local = (thread_id == num_threads - 1)? end_book_index : (thread_id + 1) * num_books_per_thread;\n\n      for (int i = start_book_index_local; i < end_book_index_local; i++) {\n         if (books[i].pages < 100) {\n            last_short_book_index_local = i;\n         }\n      }\n   }\n\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0028540387,17,0.0,True,True,0.0031532536,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"// TODO: implement this function\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int num_threads = omp_get_max_threads();\n   int num_books = books.size();\n   int num_books_per_thread = num_books / num_threads;\n   int num_books_last_thread = num_books - num_books_per_thread * (num_threads - 1);\n\n   int start_book_index = rank * num_books_per_thread;\n   int end_book_index = (rank == num_threads - 1)? num_books : (rank + 1) * num_books_per_thread;\n\n   int last_short_book_index = -1;\n   int last_short_book_index_local = -1;\n\n   #pragma omp parallel num_threads(num_threads)\n   {\n      int thread_id = omp_get_thread_num();\n      int start_book_index_local = start_book_index + thread_id * num_books_per_thread;\n      int end_book_index_local = (thread_id == num_threads - 1)? end_book_index : (thread_id + 1) * num_books_per_thread;\n\n      for (int i = start_book_index_local; i < end_book_index_local; i++) {\n         if (books[i].pages < 100) {\n            last_short_book_index_local = i;\n         }\n      }\n   }\n\n   MPI_Reduce(&last_short_book_index_local, &last_short_book_index, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_index;\n}",True,True,0.0028540387,17,1.0,True,False,0.001622258,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int chunk = n / size;\n   int remainder = n % size;\n\n   int start = rank * chunk + std::min(rank, remainder);\n   int end = (rank + 1) * chunk + std::min(rank + 1, remainder);\n\n   std::vector<Book> local_books(books.begin() + start, books.begin() + end);\n\n   int last_short_book = -1;\n\n#pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.002755854,18,0.0,True,True,0.0280735069,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int chunk = n / size;\n   int remainder = n % size;\n\n   int start = rank * chunk + std::min(rank, remainder);\n   int end = (rank + 1) * chunk + std::min(rank + 1, remainder);\n\n   std::vector<Book> local_books(books.begin() + start, books.begin() + end);\n\n   int last_short_book = -1;\n\n#pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.002755854,18,1.0,True,True,0.0266810034,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int n = books.size();\n   int chunk = n / size;\n   int remainder = n % size;\n\n   int start = rank * chunk + std::min(rank, remainder);\n   int end = (rank + 1) * chunk + std::min(rank + 1, remainder);\n\n   std::vector<Book> local_books(books.begin() + start, books.begin() + end);\n\n   int last_short_book = -1;\n\n#pragma omp parallel for\n   for (int i = 0; i < local_books.size(); i++) {\n      if (local_books[i].pages < 100) {\n         last_short_book = i;\n      }\n   }\n\n   int last_short_book_global = -1;\n   MPI_Reduce(&last_short_book, &last_short_book_global, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return last_short_book_global;\n}",True,True,0.002755854,18,2.0,True,False,0.0268492572,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,0.0,True,True,0.0031548341,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,1.0,True,True,0.003142975,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,2.0,True,True,0.0031526231,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,3.0,True,True,0.0032174617,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,4.0,True,True,0.003302347,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,5.0,True,True,0.003169218,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,6.0,True,True,0.0031567997,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,7.0,True,True,0.00161566165,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,8.0,True,True,0.0016381512,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,9.0,True,True,0.0016193975,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,10.0,True,True,0.0016125071,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,11.0,True,True,0.00162612055,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,12.0,True,True,0.00164118395,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,13.0,True,True,0.0016179308,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,14.0,True,True,0.003341406425,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,15.0,True,True,0.0016940942,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,16.0,True,True,0.00167054425,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,17.0,True,True,0.001685041325,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,18.0,True,True,0.00170398475,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,19.0,True,True,0.001770435325,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI and OpenMP to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n	 Example:\n\n   input: [{title=""Green Eggs and Ham"", pages=72}, {title=""gulliver's travels"", pages=362}, {title=""Stories of Your Life"", pages=54}, {title=""Hamilton"", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",35_search_search_for_last_struct_by_key,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   // get the number of books\n   size_t numBooks = books.size();\n\n   // get the number of books per rank\n   size_t numBooksPerRank = numBooks / size;\n\n   // get the remainder\n   size_t remainder = numBooks % size;\n\n   // get the start index of the books for this rank\n   size_t startIndex = rank * numBooksPerRank;\n\n   // get the end index of the books for this rank\n   size_t endIndex = startIndex + numBooksPerRank;\n\n   // if this rank has a remainder, add it to the end index\n   if (rank < remainder) {\n      endIndex++;\n   }\n\n   // search for the last book with pages less than 100\n   size_t lastShortBook = startIndex;\n   for (size_t i = startIndex; i < endIndex; i++) {\n      if (books[i].pages < 100) {\n         lastShortBook = i;\n      }\n   }\n\n   // gather the results from all ranks\n   size_t lastShortBookGlobal;\n   MPI_Reduce(&lastShortBook, &lastShortBookGlobal, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   return lastShortBookGlobal;\n}",True,False,0.0027611781,19,20.0,True,True,0.001753377975,64.0,4.0
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103671414,0,0.0,True,False,1.192e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103289835,1,0.0,True,False,9.02e-08,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,0.0,True,True,0.0220849001,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,1.0,True,True,0.0220942766,2.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,2.0,True,True,0.022066236,4.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,3.0,True,True,0.0220704006,8.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,4.0,True,True,0.0220811498,16.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.extent(0); ++i) {\n    double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0107632769,2,5.0,True,True,0.0221045227,32.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103283389,3,0.0,True,False,1.443e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,0.0,True,True,0.0227281737,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,1.0,True,True,0.022724712,2.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,2.0,True,True,0.022737508,4.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,3.0,True,True,0.0227196508,8.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,4.0,True,True,0.0227421,16.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double closest_distance = std::abs(M_PI - x(0));\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    double distance = std::abs(M_PI - x(i));\n    if (distance < closest_distance) {\n      closest = i;\n      closest_distance = distance;\n    }\n  }\n  return closest;\n},True,True,0.0104000677,4,5.0,True,True,0.0227593633,32.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103249627,5,0.0,True,False,1.042e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.010384725,6,0.0,True,False,1.54e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.010327732,7,0.0,True,False,1.352e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103263682,8,0.0,True,False,1.213e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103314903,9,0.0,True,False,1.514e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103303777,10,0.0,True,False,2.337e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103322086,11,0.0,True,False,1.352e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0104032827,12,0.0,True,False,2.033e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103481364,13,0.0,True,False,2.523e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,0.0,True,True,0.0227249458,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,1.0,True,True,0.0227357672,2.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,2.0,True,True,0.0227221556,4.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,3.0,True,True,0.0227363635,8.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,4.0,True,True,0.0227671642,16.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x(0) - M_PI);\n  for (size_t i = 1; i < x.extent(0); ++i) {\n    const double distance = std::abs(x(i) - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.010396849,14,5.0,True,True,0.022777773,32.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103270907,15,0.0,True,False,1.722e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.0103524314,16,0.0,True,False,1.602e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,"double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  Kokkos::parallel_reduce(\n      ""find_closest_to_pi"", x.extent(0), KOKKOS_LAMBDA(size_t i, double& min_distance, size_t& min_index) {\n        double distance = std::abs(x(i) - M_PI);\n        if (distance < min_distance) {\n          min_distance = distance;\n          min_index = i;\n        }\n      },\n      Kokkos::Min<double>(min_distance, min_index));\n\n  return min_index;\n}",False,True,,17,,,,,,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,True,0.010326184,18,0.0,True,False,1.615e-07,1.0,
"#include <Kokkos_Core.hpp>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(Kokkos::View<const double*> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,kokkos,0.2,0.95,True,1024,True,"double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  Kokkos::parallel_reduce(\n      Kokkos::RangePolicy<Kokkos::DefaultExecutionSpace>(0, x.extent(0)),\n      KOKKOS_LAMBDA(const int i, double& min_distance, size_t& min_index) {\n        double distance = std::abs(x(i) - M_PI);\n        if (distance < min_distance) {\n          min_distance = distance;\n          min_index = i;\n        }\n      },\n      Kokkos::Min<double>(min_distance, min_index));\n  return min_index;\n}",False,True,,19,,,,,,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00134874987416,0,0.0,True,True,0.00195132605731,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00134874987416,0,1.0,True,False,0.00116458123084,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134507785551,1,0.0,True,True,0.00196062747855,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134507785551,1,1.0,True,False,0.00120574303437,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135102688801,2,0.0,True,True,0.0019522214774,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135102688801,2,1.0,True,False,0.00114958933555,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00134894789662,3,0.0,True,True,0.00196326929145,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00134894789662,3,1.0,True,False,0.00116023542359,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,0.0,True,True,0.00137634139974,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,1.0,True,True,0.00136848157272,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,2.0,True,True,0.00135657440405,4.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,3.0,True,True,0.00135851104278,8.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,4.0,True,True,0.00138261748943,16.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,5.0,True,True,0.00137780338991,32.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.00135029859375,4,6.0,True,True,0.00138063959312,64.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,0.0,True,True,0.00136654127855,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,1.0,True,True,0.00136993636843,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,2.0,True,True,0.00136682079174,4.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,3.0,True,True,0.00138016592246,8.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,4.0,True,True,0.00136395124719,16.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,5.0,True,True,0.00138049151283,32.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,False,0.00134829999879,5,6.0,True,True,0.00136418666225,64.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    #pragma omp parallel for reduction(min: min_distance)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,True,0.0013010663446,6,0.0,True,True,0.00131586268544,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    #pragma omp parallel for reduction(min: min_distance)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,True,0.0013010663446,6,1.0,True,False,0.00080397508573,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00134759866633,7,0.0,True,True,0.00195082412101,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00134759866633,7,1.0,True,False,0.0011599245714,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134823177941,8,0.0,True,True,0.00196518399753,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134823177941,8,1.0,True,False,0.00116666941904,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n\n  return closest;\n},True,True,0.00135199292563,9,0.0,True,True,0.00196248991415,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n\n  return closest;\n},True,True,0.00135199292563,9,1.0,True,False,0.00117036513984,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    #pragma omp parallel for reduction(min:min_dist)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.00130072326865,10,0.0,True,True,0.00130532803014,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    #pragma omp parallel for reduction(min:min_dist)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.00130072326865,10,1.0,True,False,0.00082035877276,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00130194884259,11,0.0,True,True,0.0013312098803,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00130194884259,11,1.0,True,False,0.00080063771456,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135762940627,12,0.0,True,True,0.00195285708178,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135762940627,12,1.0,True,False,0.00116370250471,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_value = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_value)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double value = std::abs(x[i] - M_PI);\n        if (value < closest_value) {\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134931684006,13,0.0,True,True,0.00195084200241,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_value = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_value)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double value = std::abs(x[i] - M_PI);\n        if (value < closest_value) {\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,True,0.00134931684006,13,1.0,True,False,0.00117110151332,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:min_distance)\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            closest = i;\n        }\n    }\n    return closest;\n},True,True,0.00134921839926,14,0.0,True,True,0.00196159242187,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:min_distance)\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            closest = i;\n        }\n    }\n    return closest;\n},True,True,0.00134921839926,14,1.0,True,False,0.00115737956949,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00135425094049,15,0.0,True,True,0.00194979305379,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00135425094049,15,1.0,True,False,0.00123071677517,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n    size_t closest_index = 0;\n\n    #pragma omp parallel for reduction(min:min_distance) reduction(max:closest_index)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00130114736967,16,0.0,True,True,0.00136262380984,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n    size_t closest_index = 0;\n\n    #pragma omp parallel for reduction(min:min_distance) reduction(max:closest_index)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            closest_index = i;\n        }\n    }\n\n    return closest_index;\n},True,True,0.00130114736967,16,1.0,True,False,0.00084700032603,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,0.0,True,True,0.00137746594846,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,1.0,True,True,0.00136497416534,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,2.0,True,True,0.00137839065865,4.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,3.0,True,True,0.00137346717529,8.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,4.0,True,True,0.00136036446784,16.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,5.0,True,True,0.00136399941985,32.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t index = 0;\n    double min_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            index = i;\n        }\n    }\n    return index;\n},True,False,0.00133807093371,17,6.0,True,True,0.0013693864923,64.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135069037788,18,0.0,True,True,0.00195829486474,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135069037788,18,1.0,True,False,0.00112475359347,2.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(M_PI - x[0]);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135779359844,19,0.0,True,True,0.00195730894338,1.0,
"#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(M_PI - x[0]);\n  #pragma omp parallel for reduction(min: min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n  return closest;\n},True,True,0.00135779359844,19,1.0,True,False,0.00117089652922,2.0,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n  size_t closest_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,True,0.0013509951,0,0.0,True,True,0.0013539093,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.0013564975,1,0.0,True,True,0.0013583206,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013554885,2,0.0,True,True,0.0013567616,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013573549,3,0.0,True,True,0.0013566976,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013481388,4,0.0,True,True,0.0013503287,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n  size_t index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (std::abs(x[i] - M_PI) < min) {\n      min = std::abs(x[i] - M_PI);\n      index = i;\n    }\n  }\n  return index;\n},True,True,0.0013533505,5,0.0,True,True,0.0013647599,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    for (size_t i = 0; i < x.size(); i++) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.0013550814,6,0.0,True,True,0.0013589828,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,size_t index = 0;\n    double min = std::abs(M_PI - x[0]);\n    for (size_t i = 1; i < x.size(); ++i) {\n        if (std::abs(M_PI - x[i]) < min) {\n            min = std::abs(M_PI - x[i]);\n            index = i;\n        }\n    }\n    return index;\n},True,True,0.0013492044,7,0.0,True,True,0.0013453412,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_diff = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.0013518454,8,0.0,True,True,0.0013554955,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,size_t index = 0;\n  double min_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      index = i;\n    }\n  }\n  return index;\n},True,True,0.0013470424,9,0.0,True,True,0.0013527482,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,size_t index = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    if (std::abs(x[i] - M_PI) < min) {\n      min = std::abs(x[i] - M_PI);\n      index = i;\n    }\n  }\n  return index;\n},True,True,0.0013493375,10,0.0,True,True,0.0013492223,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n\n    return min_index;\n},True,True,0.0013493219,11,0.0,True,True,0.0013559302,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,size_t index = 0;\n  double min_diff = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min_diff) {\n      min_diff = diff;\n      index = i;\n    }\n  }\n  return index;\n},True,True,0.0013320632,12,0.0,True,True,0.0013389001,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_diff = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013497263,13,0.0,True,True,0.0013501793,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,True,0.0013476947,14,0.0,True,True,0.0013509196,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_diff = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013496153,15,0.0,True,True,0.0013508094,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n  size_t index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (std::abs(x[i] - M_PI) < min) {\n      min = std::abs(x[i] - M_PI);\n      index = i;\n    }\n  }\n  return index;\n},True,True,0.0013500005,16,0.0,True,True,0.0013631071,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_diff = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.0013465597,17,0.0,True,True,0.0013554866,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,True,0.0013487954,18,0.0,True,True,0.0013617525,,
"/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,serial,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,True,0.0013521452,19,0.0,True,True,0.0013475349,,
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    size_t n = x.size();\n\n    // calculate the number of elements each process will handle\n    size_t n_per_proc = n / world_size;\n\n    // calculate the start and end indices of the elements handled by this process\n    size_t start = n_per_proc * world_rank;\n    size_t end = start + n_per_proc;\n\n    // if this is the last process, handle the remaining elements\n    if (world_rank == world_size - 1) {\n        end = n;\n    }\n\n    // calculate the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    size_t min_dist_index = 0;\n\n    // loop over the elements handled by this process\n    for (size_t i = start; i < end; ++i) {\n        // calculate the distance\n        double dist = std::abs(x[i] - M_PI);\n\n        // if this distance is smaller than the current minimum, update the minimum\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // reduce the minimum distance to rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the minimum distance index to rank 0\n    size_t min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the minimum distance index\n    return min_dist_index_global;\n}",True,True,0.0013466819,0,0.0,True,True,0.0013064521,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    size_t n = x.size();\n\n    // calculate the number of elements each process will handle\n    size_t n_per_proc = n / world_size;\n\n    // calculate the start and end indices of the elements handled by this process\n    size_t start = n_per_proc * world_rank;\n    size_t end = start + n_per_proc;\n\n    // if this is the last process, handle the remaining elements\n    if (world_rank == world_size - 1) {\n        end = n;\n    }\n\n    // calculate the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    size_t min_dist_index = 0;\n\n    // loop over the elements handled by this process\n    for (size_t i = start; i < end; ++i) {\n        // calculate the distance\n        double dist = std::abs(x[i] - M_PI);\n\n        // if this distance is smaller than the current minimum, update the minimum\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // reduce the minimum distance to rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the minimum distance index to rank 0\n    size_t min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the minimum distance index\n    return min_dist_index_global;\n}",True,True,0.0013466819,0,1.0,True,False,0.000682898,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will have\n  int n_per_process = n / world_size;\n\n  // get the start index of the process\n  int start_index = n_per_process * world_rank;\n\n  // get the end index of the process\n  int end_index = start_index + n_per_process;\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + start_index, x.begin() + end_index);\n\n  // find the index of the value in the vector that is closest to PI\n  size_t closest_index = 0;\n  double closest_distance = std::abs(M_PI - local_x[0]);\n  for (size_t i = 1; i < local_x.size(); ++i) {\n    double distance = std::abs(M_PI - local_x[i]);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n\n  // find the global index of the closest value\n  int global_closest_index;\n  MPI_Reduce(&closest_index, &global_closest_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the global index of the closest value\n  return global_closest_index + start_index;\n}",True,True,0.0013536489,1,0.0,True,True,0.0022454275,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will have\n  int n_per_process = n / world_size;\n\n  // get the start index of the process\n  int start_index = n_per_process * world_rank;\n\n  // get the end index of the process\n  int end_index = start_index + n_per_process;\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + start_index, x.begin() + end_index);\n\n  // find the index of the value in the vector that is closest to PI\n  size_t closest_index = 0;\n  double closest_distance = std::abs(M_PI - local_x[0]);\n  for (size_t i = 1; i < local_x.size(); ++i) {\n    double distance = std::abs(M_PI - local_x[i]);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n\n  // find the global index of the closest value\n  int global_closest_index;\n  MPI_Reduce(&closest_index, &global_closest_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the global index of the closest value\n  return global_closest_index + start_index;\n}",True,True,0.0013536489,1,1.0,True,False,0.00115884475,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will work with\n  int n_local = n / world_size;\n\n  // get the start and end indices of the local vector\n  int start = n_local * world_rank;\n  int end = n_local * (world_rank + 1);\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + start, x.begin() + end);\n\n  // get the local minimum\n  double min = *std::min_element(local_x.begin(), local_x.end());\n\n  // get the global minimum\n  double global_min;\n  MPI_Reduce(&min, &global_min, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the local minimum\n  int min_index = std::distance(local_x.begin(), std::min_element(local_x.begin(), local_x.end()));\n\n  // get the global index of the local minimum\n  int global_min_index;\n  MPI_Reduce(&min_index, &global_min_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the global index of the local minimum\n  return global_min_index + start;\n}",True,True,0.0013480587,2,0.0,True,True,0.0029469319,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process will work with\n  int n_local = n / world_size;\n\n  // get the start and end indices of the local vector\n  int start = n_local * world_rank;\n  int end = n_local * (world_rank + 1);\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + start, x.begin() + end);\n\n  // get the local minimum\n  double min = *std::min_element(local_x.begin(), local_x.end());\n\n  // get the global minimum\n  double global_min;\n  MPI_Reduce(&min, &global_min, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the local minimum\n  int min_index = std::distance(local_x.begin(), std::min_element(local_x.begin(), local_x.end()));\n\n  // get the global index of the local minimum\n  int global_min_index;\n  MPI_Reduce(&min_index, &global_min_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the global index of the local minimum\n  return global_min_index + start;\n}",True,True,0.0013480587,2,1.0,True,False,0.00149081835,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process should search\n  int n_per_proc = n / world_size;\n\n  // get the start and end index of the search range\n  int start = n_per_proc * world_rank;\n  int end = n_per_proc * (world_rank + 1);\n\n  // get the minimum distance\n  double min_dist = std::numeric_limits<double>::max();\n  size_t min_dist_idx = 0;\n\n  // search in the range of the process\n  for (int i = start; i < end; i++) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_dist_idx = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_dist_global;\n  MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_dist_idx_global;\n  MPI_Reduce(&min_dist_idx, &min_dist_idx_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_dist_idx_global;\n}",True,True,0.0013470959,3,0.0,True,True,0.0019553631,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements each process should search\n  int n_per_proc = n / world_size;\n\n  // get the start and end index of the search range\n  int start = n_per_proc * world_rank;\n  int end = n_per_proc * (world_rank + 1);\n\n  // get the minimum distance\n  double min_dist = std::numeric_limits<double>::max();\n  size_t min_dist_idx = 0;\n\n  // search in the range of the process\n  for (int i = start; i < end; i++) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_dist_idx = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_dist_global;\n  MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_dist_idx_global;\n  MPI_Reduce(&min_dist_idx, &min_dist_idx_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_dist_idx_global;\n}",True,True,0.0013470959,3,1.0,True,False,0.00100764135,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,0.0,True,True,0.0013523296,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,1.0,True,True,0.0013915075,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,2.0,True,True,0.00141209015,,4.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,3.0,True,True,0.001514912775,,8.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,4.0,True,True,0.0015223905125,,16.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,5.0,True,True,0.00154450064687,,32.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,6.0,True,True,0.0018603518375,,64.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,7.0,True,True,0.00238786644844,,128.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,8.0,True,True,0.00304668396133,,256.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n    double min_distance = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            result = i;\n        }\n    }\n    return result;\n},True,False,0.0012987102,4,9.0,True,True,0.00636961127598,,512.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements each rank will process\n  size_t n = x.size() / size;\n  // calculate the number of elements that will be left over\n  size_t n_remainder = x.size() % size;\n\n  // calculate the start and end indices for this rank\n  size_t start = n * rank;\n  size_t end = start + n;\n  // if this is the last rank, add the remainder to the end\n  if (rank == size - 1) {\n    end += n_remainder;\n  }\n\n  // calculate the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop over the elements in this rank's vector\n  for (size_t i = start; i < end; i++) {\n    // calculate the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n    // if the distance is less than the minimum distance, update the minimum distance and index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // reduce the minimum distance to rank 0\n  double min_distance_global;\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // reduce the minimum index to rank 0\n  size_t min_index_global;\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index\n  return min_index_global;\n}",True,True,0.0013483823,5,0.0,True,True,0.0013039189,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // calculate the number of elements each rank will process\n  size_t n = x.size() / size;\n  // calculate the number of elements that will be left over\n  size_t n_remainder = x.size() % size;\n\n  // calculate the start and end indices for this rank\n  size_t start = n * rank;\n  size_t end = start + n;\n  // if this is the last rank, add the remainder to the end\n  if (rank == size - 1) {\n    end += n_remainder;\n  }\n\n  // calculate the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop over the elements in this rank's vector\n  for (size_t i = start; i < end; i++) {\n    // calculate the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n    // if the distance is less than the minimum distance, update the minimum distance and index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // reduce the minimum distance to rank 0\n  double min_distance_global;\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // reduce the minimum index to rank 0\n  size_t min_index_global;\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index\n  return min_index_global;\n}",True,True,0.0013483823,5,1.0,True,False,0.00068100675,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in x\n  int n = x.size();\n\n  // get the number of elements each process will handle\n  int n_per_process = n / world_size;\n\n  // get the starting index of the process\n  int start = n_per_process * world_rank;\n\n  // get the ending index of the process\n  int end = start + n_per_process;\n\n  // if the process is the last one, it will handle the remaining elements\n  if (world_rank == world_size - 1) {\n    end = n;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop through the elements of the process\n  for (int i = start; i < end; i++) {\n    // get the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is smaller than the minimum distance, update the minimum distance and the index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_distance_global;\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_index_global;\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.0013484964,6,0.0,True,True,0.0013063087,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in x\n  int n = x.size();\n\n  // get the number of elements each process will handle\n  int n_per_process = n / world_size;\n\n  // get the starting index of the process\n  int start = n_per_process * world_rank;\n\n  // get the ending index of the process\n  int end = start + n_per_process;\n\n  // if the process is the last one, it will handle the remaining elements\n  if (world_rank == world_size - 1) {\n    end = n;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop through the elements of the process\n  for (int i = start; i < end; i++) {\n    // get the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is smaller than the minimum distance, update the minimum distance and the index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_distance_global;\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_index_global;\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.0013484964,6,1.0,True,False,0.0006843036,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int n = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int size;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements each process will handle\n  int n_per_proc = n / size;\n\n  // get the remainder\n  int remainder = n % size;\n\n  // get the start and end index of the vector handled by the process\n  int start = rank * n_per_proc;\n  int end = start + n_per_proc;\n\n  // if the process has a remainder, add it to the end index\n  if (rank < remainder) {\n    end += 1;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop over the vector\n  for (int i = start; i < end; i++) {\n    // get the distance between the current value and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is smaller than the current minimum distance, update the minimum distance\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from the root process\n  double min_distance_root;\n  MPI_Reduce(&min_distance, &min_distance_root, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the minimum index from the root process\n  size_t min_index_root;\n  MPI_Reduce(&min_index, &min_index_root, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index from the root process\n  return min_index_root;\n}",True,True,0.0013459838,7,0.0,True,True,0.0013066222,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int n = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int size;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // get the number of elements each process will handle\n  int n_per_proc = n / size;\n\n  // get the remainder\n  int remainder = n % size;\n\n  // get the start and end index of the vector handled by the process\n  int start = rank * n_per_proc;\n  int end = start + n_per_proc;\n\n  // if the process has a remainder, add it to the end index\n  if (rank < remainder) {\n    end += 1;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n\n  // loop over the vector\n  for (int i = start; i < end; i++) {\n    // get the distance between the current value and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is smaller than the current minimum distance, update the minimum distance\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from the root process\n  double min_distance_root;\n  MPI_Reduce(&min_distance, &min_distance_root, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the minimum index from the root process\n  size_t min_index_root;\n  MPI_Reduce(&min_index, &min_index_root, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index from the root process\n  return min_index_root;\n}",True,True,0.0013459838,7,1.0,True,False,0.0006795361,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int nproc;\n    MPI_Comm_size(MPI_COMM_WORLD, &nproc);\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the number of elements in the vector\n    size_t n = x.size();\n\n    // get the number of elements each process will handle\n    size_t n_per_proc = n / nproc;\n\n    // get the index of the first element handled by the process\n    size_t first_index = rank * n_per_proc;\n\n    // get the index of the last element handled by the process\n    size_t last_index = first_index + n_per_proc - 1;\n\n    // if the process is not the last one, then it will handle one more element\n    if (rank!= nproc - 1) {\n        last_index += 1;\n    }\n\n    // the process with rank 0 will store the index of the closest value to PI\n    size_t closest_index = 0;\n\n    // the process with rank 0 will store the value of the closest value to PI\n    double closest_value = std::numeric_limits<double>::max();\n\n    // loop over the elements handled by the process\n    for (size_t i = first_index; i <= last_index; i++) {\n        // get the value of the element\n        double value = x[i];\n\n        // check if the value is closer to PI than the current closest value\n        if (std::abs(value - M_PI) < std::abs(closest_value - M_PI)) {\n            // if it is, then update the closest value and the index\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n\n    // broadcast the index of the closest value to the other processes\n    MPI_Bcast(&closest_index, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n\n    // return the index of the closest value to PI\n    return closest_index;\n}",True,True,0.0013461851,8,0.0,True,True,0.0052102967,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int nproc;\n    MPI_Comm_size(MPI_COMM_WORLD, &nproc);\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the number of elements in the vector\n    size_t n = x.size();\n\n    // get the number of elements each process will handle\n    size_t n_per_proc = n / nproc;\n\n    // get the index of the first element handled by the process\n    size_t first_index = rank * n_per_proc;\n\n    // get the index of the last element handled by the process\n    size_t last_index = first_index + n_per_proc - 1;\n\n    // if the process is not the last one, then it will handle one more element\n    if (rank!= nproc - 1) {\n        last_index += 1;\n    }\n\n    // the process with rank 0 will store the index of the closest value to PI\n    size_t closest_index = 0;\n\n    // the process with rank 0 will store the value of the closest value to PI\n    double closest_value = std::numeric_limits<double>::max();\n\n    // loop over the elements handled by the process\n    for (size_t i = first_index; i <= last_index; i++) {\n        // get the value of the element\n        double value = x[i];\n\n        // check if the value is closer to PI than the current closest value\n        if (std::abs(value - M_PI) < std::abs(closest_value - M_PI)) {\n            // if it is, then update the closest value and the index\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n\n    // broadcast the index of the closest value to the other processes\n    MPI_Bcast(&closest_index, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n\n    // return the index of the closest value to PI\n    return closest_index;\n}",True,True,0.0013461851,8,1.0,True,False,0.0026049352,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_per_process = n / world_size;\n\n  // get the starting index of the process\n  int start = n_per_process * world_rank;\n\n  // get the ending index of the process\n  int end = start + n_per_process;\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  size_t min_index = 0;\n\n  // loop through the elements in the process\n  for (int i = start; i < end; i++) {\n    // get the distance between the element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is less than the minimum distance\n    if (distance < min_distance) {\n      // set the minimum distance and the index\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_distance_global;\n  MPI_Allreduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_index_global;\n  MPI_Allreduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.0013326287,9,0.0,True,True,0.0019506813,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements per process\n  int n_per_process = n / world_size;\n\n  // get the starting index of the process\n  int start = n_per_process * world_rank;\n\n  // get the ending index of the process\n  int end = start + n_per_process;\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  size_t min_index = 0;\n\n  // loop through the elements in the process\n  for (int i = start; i < end; i++) {\n    // get the distance between the element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is less than the minimum distance\n    if (distance < min_distance) {\n      // set the minimum distance and the index\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance from all processes\n  double min_distance_global;\n  MPI_Allreduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  // get the index of the minimum distance from all processes\n  size_t min_index_global;\n  MPI_Allreduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.0013326287,9,1.0,True,False,0.00100849835,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int n = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the number of elements each process will handle\n  int n_per_process = n / world_size;\n\n  // get the index of the first element that this process will handle\n  int first_element = rank * n_per_process;\n\n  // get the index of the last element that this process will handle\n  int last_element = (rank + 1) * n_per_process;\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + first_element, x.begin() + last_element);\n\n  // get the index of the closest value to pi\n  size_t closest_index = 0;\n  double closest_value = std::abs(local_x[0] - M_PI);\n  for (size_t i = 1; i < local_x.size(); ++i) {\n    double current_value = std::abs(local_x[i] - M_PI);\n    if (current_value < closest_value) {\n      closest_index = i;\n      closest_value = current_value;\n    }\n  }\n\n  // get the index of the closest value to pi in the global vector\n  int global_closest_index;\n  MPI_Reduce(&closest_index, &global_closest_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the closest value to pi in the global vector\n  size_t global_closest_value;\n  MPI_Reduce(&closest_value, &global_closest_value, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the closest value to pi in the global vector\n  return global_closest_index + first_element;\n}",True,True,0.0013464658,10,0.0,True,True,0.0022481663,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int n = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // get the number of elements each process will handle\n  int n_per_process = n / world_size;\n\n  // get the index of the first element that this process will handle\n  int first_element = rank * n_per_process;\n\n  // get the index of the last element that this process will handle\n  int last_element = (rank + 1) * n_per_process;\n\n  // get the local vector\n  std::vector<double> local_x(x.begin() + first_element, x.begin() + last_element);\n\n  // get the index of the closest value to pi\n  size_t closest_index = 0;\n  double closest_value = std::abs(local_x[0] - M_PI);\n  for (size_t i = 1; i < local_x.size(); ++i) {\n    double current_value = std::abs(local_x[i] - M_PI);\n    if (current_value < closest_value) {\n      closest_index = i;\n      closest_value = current_value;\n    }\n  }\n\n  // get the index of the closest value to pi in the global vector\n  int global_closest_index;\n  MPI_Reduce(&closest_index, &global_closest_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // get the index of the closest value to pi in the global vector\n  size_t global_closest_value;\n  MPI_Reduce(&closest_value, &global_closest_value, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the closest value to pi in the global vector\n  return global_closest_index + first_element;\n}",True,True,0.0013464658,10,1.0,True,False,0.0011465719,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // calculate the number of elements each rank will have\n    int n = x.size() / size;\n\n    // calculate the start and end index of the current rank\n    int start = rank * n;\n    int end = start + n;\n\n    // calculate the minimum distance to pi\n    double min_distance = std::numeric_limits<double>::max();\n    int min_index = 0;\n\n    // loop through the elements of the current rank\n    for (int i = start; i < end; i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n\n    // reduce the minimum distance to pi to rank 0\n    double global_min_distance;\n    MPI_Reduce(&min_distance, &global_min_distance, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the index of the minimum distance to pi to rank 0\n    int global_min_index;\n    MPI_Reduce(&min_index, &global_min_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance to pi on rank 0\n    return global_min_index;\n}",True,True,0.0013342127,11,0.0,True,True,0.0013096506,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // calculate the number of elements each rank will have\n    int n = x.size() / size;\n\n    // calculate the start and end index of the current rank\n    int start = rank * n;\n    int end = start + n;\n\n    // calculate the minimum distance to pi\n    double min_distance = std::numeric_limits<double>::max();\n    int min_index = 0;\n\n    // loop through the elements of the current rank\n    for (int i = start; i < end; i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n\n    // reduce the minimum distance to pi to rank 0\n    double global_min_distance;\n    MPI_Reduce(&min_distance, &global_min_distance, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the index of the minimum distance to pi to rank 0\n    int global_min_index;\n    MPI_Reduce(&min_index, &global_min_index, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance to pi on rank 0\n    return global_min_index;\n}",True,True,0.0013342127,11,1.0,True,False,0.0006815042,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,0.0,True,True,0.0013053917,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,1.0,True,True,0.001328643,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,2.0,True,True,0.001343056375,,4.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,3.0,True,True,0.0014548022375,,8.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,4.0,True,True,0.00139727671875,,16.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,5.0,True,True,0.00157431006562,,32.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,6.0,True,True,0.00210257455469,,64.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,7.0,True,True,0.00218787451016,,128.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,8.0,True,True,0.00337560802188,,256.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double diff = std::abs(x[i] - M_PI);\n    if (diff < min) {\n      min = diff;\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013001529,12,9.0,True,True,0.00639015102285,,512.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // get the number of elements each process will process\n    int n_per_proc = n / world_size;\n\n    // get the number of elements that will be left over\n    int n_left = n % world_size;\n\n    // get the start index of the elements that this process will process\n    int start = n_per_proc * world_rank;\n\n    // get the end index of the elements that this process will process\n    int end = start + n_per_proc;\n\n    // if this process has elements left over, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // get the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n\n    // get the index of the minimum distance\n    size_t min_dist_index = 0;\n\n    // loop through the elements that this process will process\n    for (int i = start; i < end; i++) {\n        // get the distance between the element and PI\n        double dist = std::abs(x[i] - M_PI);\n\n        // if the distance is less than the minimum distance, update the minimum distance and index\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // get the minimum distance from rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance from rank 0\n    size_t min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance\n    return min_dist_index_global;\n}",True,True,0.0013471592,13,0.0,True,True,0.0013039753,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // get the number of elements each process will process\n    int n_per_proc = n / world_size;\n\n    // get the number of elements that will be left over\n    int n_left = n % world_size;\n\n    // get the start index of the elements that this process will process\n    int start = n_per_proc * world_rank;\n\n    // get the end index of the elements that this process will process\n    int end = start + n_per_proc;\n\n    // if this process has elements left over, add them to the end\n    if (world_rank < n_left) {\n        end++;\n    }\n\n    // get the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n\n    // get the index of the minimum distance\n    size_t min_dist_index = 0;\n\n    // loop through the elements that this process will process\n    for (int i = start; i < end; i++) {\n        // get the distance between the element and PI\n        double dist = std::abs(x[i] - M_PI);\n\n        // if the distance is less than the minimum distance, update the minimum distance and index\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // get the minimum distance from rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance from rank 0\n    size_t min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance\n    return min_dist_index_global;\n}",True,True,0.0013471592,13,1.0,True,False,0.000681877,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // calculate the number of elements each rank will have\n    int n_local = n / size;\n\n    // calculate the start and end index of the local vector\n    int start = n_local * rank;\n    int end = start + n_local;\n\n    // calculate the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    int min_dist_index = -1;\n\n    // calculate the distance to the math constant PI\n    for (int i = start; i < end; i++) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // reduce the minimum distance to rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the index of the minimum distance to rank 0\n    int min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance\n    return min_dist_index_global;\n}",True,True,0.0013541604,14,0.0,True,True,0.0013094434,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // calculate the number of elements each rank will have\n    int n_local = n / size;\n\n    // calculate the start and end index of the local vector\n    int start = n_local * rank;\n    int end = start + n_local;\n\n    // calculate the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    int min_dist_index = -1;\n\n    // calculate the distance to the math constant PI\n    for (int i = start; i < end; i++) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_dist_index = i;\n        }\n    }\n\n    // reduce the minimum distance to rank 0\n    double min_dist_global;\n    MPI_Reduce(&min_dist, &min_dist_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // reduce the index of the minimum distance to rank 0\n    int min_dist_index_global;\n    MPI_Reduce(&min_dist_index, &min_dist_index_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance\n    return min_dist_index_global;\n}",True,True,0.0013541604,14,1.0,True,False,0.0006859236,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // get the number of elements each process should work on\n    int n_per_process = n / world_size;\n\n    // get the start and end indices of the vector that this process should work on\n    int start = n_per_process * world_rank;\n    int end = start + n_per_process;\n\n    // find the minimum distance from the vector elements to the value of PI\n    double min_distance = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    for (int i = start; i < end; ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n\n    // get the minimum distance from all processes\n    double min_distance_global;\n    MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance from all processes\n    size_t min_index_global;\n    MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance from all processes\n    return min_index_global;\n}",True,True,0.0013484076,15,0.0,True,True,0.0019544254,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // get the number of elements each process should work on\n    int n_per_process = n / world_size;\n\n    // get the start and end indices of the vector that this process should work on\n    int start = n_per_process * world_rank;\n    int end = start + n_per_process;\n\n    // find the minimum distance from the vector elements to the value of PI\n    double min_distance = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    for (int i = start; i < end; ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n\n    // get the minimum distance from all processes\n    double min_distance_global;\n    MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance from all processes\n    size_t min_index_global;\n    MPI_Reduce(&min_index, &min_index_global, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance from all processes\n    return min_index_global;\n}",True,True,0.0013484076,15,1.0,True,False,0.00102312865,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the rank of the process\n    int world_rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    // get the number of elements in the vector\n    int n = x.size();\n\n    // calculate the number of elements each process will handle\n    int n_per_proc = n / world_size;\n\n    // calculate the start and end indices of the elements handled by this process\n    int start = n_per_proc * world_rank;\n    int end = start + n_per_proc;\n\n    // calculate the number of elements that are smaller than PI\n    int n_smaller = 0;\n    for (int i = start; i < end; i++) {\n        if (x[i] < M_PI) {\n            n_smaller++;\n        }\n    }\n\n    // calculate the number of elements that are larger than PI\n    int n_larger = 0;\n    for (int i = start; i < end; i++) {\n        if (x[i] > M_PI) {\n            n_larger++;\n        }\n    }\n\n    // calculate the number of elements that are equal to PI\n    int n_equal = 0;\n    for (int i = start; i < end; i++) {\n        if (x[i] == M_PI) {\n            n_equal++;\n        }\n    }\n\n    // calculate the number of elements that are smaller than PI\n    int n_smaller_total;\n    MPI_Reduce(&n_smaller, &n_smaller_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are larger than PI\n    int n_larger_total;\n    MPI_Reduce(&n_larger, &n_larger_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are equal to PI\n    int n_equal_total;\n    MPI_Reduce(&n_equal, &n_equal_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the total number of elements that are smaller than PI\n    int n_smaller_total_total;\n    MPI_Reduce(&n_smaller_total, &n_smaller_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the total number of elements that are larger than PI\n    int n_larger_total_total;\n    MPI_Reduce(&n_larger_total, &n_larger_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the total number of elements that are equal to PI\n    int n_equal_total_total;\n    MPI_Reduce(&n_equal_total, &n_equal_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the total number of elements\n    int n_total;\n    MPI_Reduce(&n, &n_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are smaller than PI\n    int n_smaller_total_total_total;\n    MPI_Reduce(&n_smaller_total_total, &n_smaller_total_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are larger than PI\n    int n_larger_total_total_total;\n    MPI_Reduce(&n_larger_total_total, &n_larger_total_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are equal to PI\n    int n_equal_total_total_total;\n    MPI_Reduce(&n_equal_total_total, &n_equal_total_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are smaller than PI\n    int n_smaller_total_total_total_total;\n    MPI_Reduce(&n_smaller_total_total_total, &n_smaller_total_total_total_total, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    // calculate the number of elements that are larger than",False,True,,16,,,,,,
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // find the index of the value in the vector x that is closest to the math constant PI\n  // use M_PI for the value of PI\n  // use MPI to search in parallel\n  // assume MPI has already been initialized\n  // every rank has a complete copy of x\n  // return the result on rank 0\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements that each rank will have\n  int n_per_rank = n / size;\n\n  // get the starting index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // get the ending index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  int min_index = 0;\n\n  // loop through the elements in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    // get the current element\n    double current_element = x[i];\n\n    // get the distance between the current element and the math constant PI\n    double distance = std::abs(current_element - M_PI);\n\n    // if the distance is less than the minimum distance\n    if (distance < min_distance) {\n      // set the minimum distance to the current distance\n      min_distance = distance;\n\n      // set the minimum index to the current index\n      min_index = i;\n    }\n  }\n\n  // get the minimum index on rank 0\n  int min_index_on_rank_0;\n  MPI_Reduce(&min_index, &min_index_on_rank_0, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index on rank 0\n  return min_index_on_rank_0;\n}",True,True,0.0013459755,17,0.0,True,True,0.0019549252,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  // find the index of the value in the vector x that is closest to the math constant PI\n  // use M_PI for the value of PI\n  // use MPI to search in parallel\n  // assume MPI has already been initialized\n  // every rank has a complete copy of x\n  // return the result on rank 0\n\n  // get the number of elements in the vector\n  int n = x.size();\n\n  // get the number of elements that each rank will have\n  int n_per_rank = n / size;\n\n  // get the starting index of the current rank\n  int start_index = rank * n_per_rank;\n\n  // get the ending index of the current rank\n  int end_index = start_index + n_per_rank;\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  int min_index = 0;\n\n  // loop through the elements in the current rank\n  for (int i = start_index; i < end_index; i++) {\n    // get the current element\n    double current_element = x[i];\n\n    // get the distance between the current element and the math constant PI\n    double distance = std::abs(current_element - M_PI);\n\n    // if the distance is less than the minimum distance\n    if (distance < min_distance) {\n      // set the minimum distance to the current distance\n      min_distance = distance;\n\n      // set the minimum index to the current index\n      min_index = i;\n    }\n  }\n\n  // get the minimum index on rank 0\n  int min_index_on_rank_0;\n  MPI_Reduce(&min_index, &min_index_on_rank_0, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the minimum index on rank 0\n  return min_index_on_rank_0;\n}",True,True,0.0013459755,17,1.0,True,False,0.0010048603,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int size = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int num_procs;\n  MPI_Comm_size(MPI_COMM_WORLD, &num_procs);\n\n  // get the number of elements each process should search\n  int num_elements = size / num_procs;\n\n  // get the remainder of the division\n  int remainder = size % num_procs;\n\n  // get the starting index of the process\n  int start_index = rank * num_elements;\n\n  // get the ending index of the process\n  int end_index = start_index + num_elements;\n\n  // if the process has a remainder, add it to the end index\n  if (rank < remainder) {\n    end_index++;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  int min_index = -1;\n\n  // loop through the vector\n  for (int i = start_index; i < end_index; i++) {\n    // get the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is less than the minimum distance, set the minimum distance and index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance\n  double min_distance_global;\n\n  // get the index of the minimum distance\n  int min_index_global;\n\n  // gather the minimum distance and index from all processes\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.001345539,18,0.0,True,True,0.0019547176,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n  int size = x.size();\n\n  // get the rank of the process\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  // get the number of processes\n  int num_procs;\n  MPI_Comm_size(MPI_COMM_WORLD, &num_procs);\n\n  // get the number of elements each process should search\n  int num_elements = size / num_procs;\n\n  // get the remainder of the division\n  int remainder = size % num_procs;\n\n  // get the starting index of the process\n  int start_index = rank * num_elements;\n\n  // get the ending index of the process\n  int end_index = start_index + num_elements;\n\n  // if the process has a remainder, add it to the end index\n  if (rank < remainder) {\n    end_index++;\n  }\n\n  // get the minimum distance\n  double min_distance = std::numeric_limits<double>::max();\n\n  // get the index of the minimum distance\n  int min_index = -1;\n\n  // loop through the vector\n  for (int i = start_index; i < end_index; i++) {\n    // get the distance between the current element and PI\n    double distance = std::abs(x[i] - M_PI);\n\n    // if the distance is less than the minimum distance, set the minimum distance and index\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n\n  // get the minimum distance\n  double min_distance_global;\n\n  // get the index of the minimum distance\n  int min_index_global;\n\n  // gather the minimum distance and index from all processes\n  MPI_Reduce(&min_distance, &min_distance_global, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&min_index, &min_index_global, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  // return the index of the minimum distance\n  return min_index_global;\n}",True,True,0.001345539,18,1.0,True,False,0.00100612415,,2.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n    int n = x.size();\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the number of elements each process should work on\n    int n_per_rank = n / world_size;\n\n    // get the number of elements each process should skip\n    int skip = n % world_size;\n\n    // get the start and end index of the process\n    int start = rank * n_per_rank + std::min(rank, skip);\n    int end = start + n_per_rank + (rank < skip? 1 : 0);\n\n    // get the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    // loop over the elements of the process\n    for (int i = start; i < end; ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n\n    // get the minimum distance on rank 0\n    double min_dist_0;\n    MPI_Reduce(&min_dist, &min_dist_0, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance on rank 0\n    size_t min_index_0;\n    MPI_Reduce(&min_index, &min_index_0, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance on rank 0\n    return min_index_0;\n}",True,True,0.0013465429,19,0.0,True,True,0.0013045131,,1.0
"#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi,0.2,0.95,True,1024,True,"// get the size of the vector\n    int n = x.size();\n\n    // get the rank of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    // get the number of processes\n    int world_size;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n    // get the number of elements each process should work on\n    int n_per_rank = n / world_size;\n\n    // get the number of elements each process should skip\n    int skip = n % world_size;\n\n    // get the start and end index of the process\n    int start = rank * n_per_rank + std::min(rank, skip);\n    int end = start + n_per_rank + (rank < skip? 1 : 0);\n\n    // get the minimum distance\n    double min_dist = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    // loop over the elements of the process\n    for (int i = start; i < end; ++i) {\n        double dist = std::abs(x[i] - M_PI);\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_index = i;\n        }\n    }\n\n    // get the minimum distance on rank 0\n    double min_dist_0;\n    MPI_Reduce(&min_dist, &min_dist_0, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // get the index of the minimum distance on rank 0\n    size_t min_index_0;\n    MPI_Reduce(&min_index, &min_index_0, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    // return the index of the minimum distance on rank 0\n    return min_index_0;\n}",True,True,0.0013465429,19,1.0,True,False,0.00068079395,,2.0
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013531709,0,0.0,True,False,1.655999981e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013524423,1,0.0,True,False,1.625920003e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013518922,2,0.0,True,False,1.534079975e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013503546,3,0.0,True,False,1.309440015e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    int index = blockIdx.x * blockDim.x + threadIdx.x;\n    if (index < N) {\n        double diff = fabs(x[index] - M_PI);\n        if (diff < 1e-6) {\n            *closestToPiIndex = index;\n        }\n    }\n},True,True,0.0013528681,4,0.0,True,False,2.223360017e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n},True,True,0.001353888,5,0.0,True,False,1.667520003e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013504157,6,0.0,True,False,1.38815999e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    // hint: use the CUDA atomicMin function\n},True,True,0.0013524986,7,0.0,True,False,1.646080008e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    // hint: use the CUDA atomicMin function to find the index of the closest value to PI\n    // hint: use the CUDA atomicAdd function to increment the number of threads that have found the closest value to PI\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if the closest value to PI has been found by another thread\n    // hint: use the CUDA atomicCAS function to check if,False,True,,8,,,,,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013530826,9,0.0,True,False,1.572480006e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid < N) {\n        double diff = fabs(x[tid] - M_PI);\n        if (diff < fabs(x[closestToPiIndex[0]] - M_PI)) {\n            closestToPiIndex[0] = tid;\n        }\n    }\n},True,True,0.0013508042,10,0.0,True,False,2.956799977e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013526105,11,0.0,True,False,1.657919986e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013475751,12,0.0,True,False,1.846079975e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    // TODO: use the following function to get the index of the value in the vector x that is closest to the math constant PI\n    // double closestToPi = __ldg(&M_PI);\n    // TODO: use the following function to get the index of the value in the vector x that is closest to the math constant PI\n    // size_t closestToPiIndex = 0;\n    // TODO: return the index of the value in the vector x that is closest to the math constant PI\n    // return closestToPiIndex;\n},True,True,0.0013541565,13,0.0,True,False,1.356800022e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013550293,14,0.0,True,False,1.818559989e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n    // TODO: store the index of the closest value in closestToPiIndex\n},True,True,0.0013536549,15,0.0,True,False,1.53248e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013506001,16,0.0,True,False,1.526399981e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement this function\n    // hint: use the CUDA atomicMin function\n},True,True,0.001352212,17,0.0,True,False,1.774400016e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,// TODO: implement the kernel\n},True,True,0.0013528482,18,0.0,True,False,1.679680031e-05,,
"/* Find the index of the value in the vector x that is closest to the math constant PI. Store the index in closestToPiIndex.\n   Use M_PI for the value of PI.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\n__global__ void findClosestToPi(const double *x, size_t N, size_t *closestToPiIndex) {",37_search_find_the_closest_number_to_pi,search,cpp,cuda,0.2,0.95,True,1024,True,int tid = blockIdx.x * blockDim.x + threadIdx.x;\n  double min = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,False,True,,19,,,,,,
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  // Hint: use MPI and OpenMP\n},True,False,,0,0.0,False,,,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n\n  #pragma omp parallel for reduction(min: closest_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n\n  return closest_index;\n},True,False,0.00129994,1,0.0,True,True,0.0013065493,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n\n  #pragma omp parallel for reduction(min: closest_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n\n  return closest_index;\n},True,False,0.00129994,1,1.0,True,False,0.0008123227,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t result = 0;\n    double min = std::numeric_limits<double>::max();\n\n    #pragma omp parallel for reduction(min:min)\n    for (size_t i = 0; i < x.size(); i++) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            result = i;\n        }\n    }\n\n    return result;\n},True,False,0.0013473128,2,0.0,True,True,0.0013042439,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t result = 0;\n    double min = std::numeric_limits<double>::max();\n\n    #pragma omp parallel for reduction(min:min)\n    for (size_t i = 0; i < x.size(); i++) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            result = i;\n        }\n    }\n\n    return result;\n},True,False,0.0013473128,2,1.0,True,False,0.0008206193,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,0.0,True,True,0.0013145914,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,1.0,True,True,0.0012995609,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,2.0,True,True,0.0013000302,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,3.0,True,True,0.0013034694,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,4.0,True,True,0.0013066155,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,5.0,True,True,0.0013036949,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,6.0,True,True,0.0013047619,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,7.0,True,True,0.00132743135,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,8.0,True,True,0.0013273458,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,9.0,True,True,0.0013275747,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,10.0,True,True,0.00133253135,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,11.0,True,True,0.0013284825,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,12.0,True,True,0.001326189,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,13.0,True,True,0.00132807345,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,14.0,True,True,0.001341290175,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,15.0,True,True,0.0013410822,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,16.0,True,True,0.001338800775,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,17.0,True,True,0.00134037955,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,18.0,True,True,0.00134060905,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,19.0,True,True,0.001340687,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012980182,3,20.0,True,True,0.0013406644,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012998868,4,0.0,True,True,0.001305362,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min: closest_distance)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012998868,4,1.0,True,False,0.0008124007,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::numeric_limits<double>::max();\n  #pragma omp parallel for reduction(min:min)\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (std::abs(x[i] - M_PI) < min) {\n      min = std::abs(x[i] - M_PI);\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013461477,5,0.0,True,True,0.0013027871,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t result = 0;\n  double min = std::numeric_limits<double>::max();\n  #pragma omp parallel for reduction(min:min)\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (std::abs(x[i] - M_PI) < min) {\n      min = std::abs(x[i] - M_PI);\n      result = i;\n    }\n  }\n  return result;\n},True,False,0.0013461477,5,1.0,True,False,0.0008080105,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for reduction(min:min_dist)\n  for (size_t i = 0; i < x.size(); i++) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,False,0.0013482405,6,0.0,True,True,0.0013033223,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,double min_dist = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for reduction(min:min_dist)\n  for (size_t i = 0; i < x.size(); i++) {\n    double dist = std::abs(x[i] - M_PI);\n    if (dist < min_dist) {\n      min_dist = dist;\n      min_index = i;\n    }\n  }\n  return min_index;\n},True,False,0.0013482405,6,1.0,True,False,0.0008228134,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,0.0,True,True,0.0013044132,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,1.0,True,True,0.0013063126,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,2.0,True,True,0.0013018374,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,3.0,True,True,0.0013022122,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,4.0,True,True,0.0013034654,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,5.0,True,True,0.0013024917,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,6.0,True,True,0.0013002984,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,7.0,True,True,0.0013266188,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,8.0,True,True,0.0013335815,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,9.0,True,True,0.00132633665,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,10.0,True,True,0.00132789875,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,11.0,True,True,0.0013249183,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,12.0,True,True,0.00132815425,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,13.0,True,True,0.001327532,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,14.0,True,True,0.001341860475,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,15.0,True,True,0.001339874575,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,16.0,True,True,0.001341505075,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,17.0,True,True,0.001340814925,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,18.0,True,True,0.001340885975,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,19.0,True,True,0.00134139585,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n    size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); i++) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_distance = distance;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012992096,7,20.0,True,True,0.00134000145,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(M_PI - x[0]);\n\n  #pragma omp parallel for reduction(min:closest_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n\n  return closest_index;\n},True,False,0.0013011022,8,0.0,True,True,0.0013079179,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(M_PI - x[0]);\n\n  #pragma omp parallel for reduction(min:closest_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n\n  return closest_index;\n},True,False,0.0013011022,8,1.0,True,False,0.0008209718,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  return 0;\n},True,False,0.0013520668,9,0.0,True,False,1.212e-07,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(M_PI - x[0]);\n\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n\n  return closest;\n},True,False,0.0012994639,10,0.0,True,True,0.0013044133,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest = 0;\n  double min_distance = std::abs(M_PI - x[0]);\n\n  #pragma omp parallel for reduction(min:min_distance)\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(M_PI - x[i]);\n    if (distance < min_distance) {\n      min_distance = distance;\n      closest = i;\n    }\n  }\n\n  return closest;\n},True,False,0.0012994639,10,1.0,True,False,0.0008147572,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,0.0,True,True,0.0013035336,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,1.0,True,True,0.0013044525,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,2.0,True,True,0.0013018894,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,3.0,True,True,0.0013056986,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,4.0,True,True,0.0013051584,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,5.0,True,True,0.0013028643,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,6.0,True,True,0.0013022334,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,7.0,True,True,0.00132828395,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,8.0,True,True,0.0013273953,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,9.0,True,True,0.00132919915,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,10.0,True,True,0.00133361305,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,11.0,True,True,0.0013288351,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,12.0,True,True,0.00132778865,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,13.0,True,True,0.00132742505,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,14.0,True,True,0.00134493115,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,15.0,True,True,0.0013432848,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,16.0,True,True,0.00134069615,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,17.0,True,True,0.001339742625,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,18.0,True,True,0.0013408689,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,19.0,True,True,0.001340774925,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985823,11,20.0,True,True,0.00133911655,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    #pragma omp parallel for reduction(min:min)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,False,0.0013463871,12,0.0,True,True,0.0013033923,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,double min = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n    #pragma omp parallel for reduction(min:min)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (std::abs(x[i] - M_PI) < min) {\n            min = std::abs(x[i] - M_PI);\n            min_index = i;\n        }\n    }\n    return min_index;\n},True,False,0.0013463871,12,1.0,True,False,0.0007987672,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,0.0,True,True,0.0013060974,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,1.0,True,True,0.0013013999,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,2.0,True,True,0.0013021792,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,3.0,True,True,0.0013052491,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,4.0,True,True,0.0013076621,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,5.0,True,True,0.0013029686,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,6.0,True,True,0.0012992897,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,7.0,True,True,0.00132900035,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,8.0,True,True,0.00132803465,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,9.0,True,True,0.0013298,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,10.0,True,True,0.00133026965,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,11.0,True,True,0.0013272925,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,12.0,True,True,0.00132846935,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,13.0,True,True,0.001326402,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,14.0,True,True,0.001341167475,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,15.0,True,True,0.00134206595,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,16.0,True,True,0.001340169725,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,17.0,True,True,0.00133869975,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,18.0,True,True,0.001340596475,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,19.0,True,True,0.001340784575,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012984951,13,20.0,True,True,0.001340891275,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,"double min_distance = std::numeric_limits<double>::max();\n    size_t min_index = 0;\n\n    #pragma omp parallel for reduction(min: min_distance, min_index)\n    for (size_t i = 0; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < min_distance) {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n\n    return min_index;\n}",True,False,0.0013002896,14,0.0,True,False,0.0013549531,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,0.0,True,True,0.001305377,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,1.0,True,True,0.001303596,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,2.0,True,True,0.0013062317,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,3.0,True,True,0.0013019525,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,4.0,True,True,0.0013025959,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,5.0,True,True,0.0013008087,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,6.0,True,True,0.0013019866,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,7.0,True,True,0.0013308292,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,8.0,True,True,0.00132853045,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,9.0,True,True,0.00132642945,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,10.0,True,True,0.00132860945,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,11.0,True,True,0.00132901535,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,12.0,True,True,0.00132751505,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,13.0,True,True,0.00132898525,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,14.0,True,True,0.00134021615,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,15.0,True,True,0.00134010345,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,16.0,True,True,0.001337784125,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,17.0,True,True,0.0013435847,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,18.0,True,True,0.001340245275,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,19.0,True,True,0.001340915675,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_distance = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        double distance = std::abs(x[i] - M_PI);\n        if (distance < closest_distance) {\n            closest_index = i;\n            closest_distance = distance;\n        }\n    }\n    return closest_index;\n},True,False,0.0012984826,15,20.0,True,True,0.0013411309,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,0.0,True,True,0.0013056157,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,1.0,True,True,0.0013072574,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,2.0,True,True,0.0013059471,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,3.0,True,True,0.0013069152,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,4.0,True,True,0.0013042029,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,5.0,True,True,0.0013070703,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,6.0,True,True,0.0013020439,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,7.0,True,True,0.00132763675,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,8.0,True,True,0.0013278882,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,9.0,True,True,0.0013343589,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,10.0,True,True,0.0013287816,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,11.0,True,True,0.00132891855,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,12.0,True,True,0.00132668895,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,13.0,True,True,0.00132956185,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,14.0,True,True,0.00134196355,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,15.0,True,True,0.0013393857,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,16.0,True,True,0.00133964165,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,17.0,True,True,0.001341225975,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,18.0,True,True,0.001342166725,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,19.0,True,True,0.001339712025,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,// TODO: implement this function\n  size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); i++) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n  return closest_index;\n},True,False,0.0012986997,16,20.0,True,True,0.001339320125,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,0.0,True,True,0.0013016039,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,1.0,True,True,0.0013048812,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,2.0,True,True,0.0013027902,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,3.0,True,True,0.0013089388,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,4.0,True,True,0.0013060323,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,5.0,True,True,0.0013069052,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,6.0,True,True,0.0013028323,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,7.0,True,True,0.00132876185,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,8.0,True,True,0.0013276984,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,9.0,True,True,0.00132637395,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,10.0,True,True,0.0013274985,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,11.0,True,True,0.00133063935,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,12.0,True,True,0.00133802485,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,13.0,True,True,0.0013434369,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,14.0,True,True,0.0013427635,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,15.0,True,True,0.00133872005,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,16.0,True,True,0.0013410443,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,17.0,True,True,0.00134113825,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,18.0,True,True,0.001340562225,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,19.0,True,True,0.001339509125,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_distance = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < closest_distance) {\n      closest_index = i;\n      closest_distance = distance;\n    }\n  }\n  return closest_index;\n},True,False,0.0012982297,17,20.0,True,True,0.00133986605,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,0.0,True,True,0.0013056764,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,1.0,True,True,0.00130645,2.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,2.0,True,True,0.0013036429,4.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,3.0,True,True,0.0013043052,8.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,4.0,True,True,0.0013051915,16.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,5.0,True,True,0.001302836,32.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,6.0,True,True,0.0013031731,64.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,7.0,True,True,0.0013355079,1.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,8.0,True,True,0.00132762275,2.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,9.0,True,True,0.0013383614,4.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,10.0,True,True,0.0013264409,8.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,11.0,True,True,0.00132891865,16.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,12.0,True,True,0.00132975155,32.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,13.0,True,True,0.00132854705,64.0,2.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,14.0,True,True,0.001342815625,1.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,15.0,True,True,0.0013402546,2.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,16.0,True,True,0.001339666425,4.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,17.0,True,True,0.001341760075,8.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,18.0,True,True,0.0013406381,16.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,19.0,True,True,0.0013407939,32.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n  double closest_value = std::abs(x[0] - M_PI);\n  for (size_t i = 1; i < x.size(); ++i) {\n    double value = std::abs(x[i] - M_PI);\n    if (value < closest_value) {\n      closest_index = i;\n      closest_value = value;\n    }\n  }\n  return closest_index;\n},True,False,0.0012985434,18,20.0,True,True,0.001340272575,64.0,4.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_value = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_value)\n    for (size_t i = 1; i < x.size(); i++) {\n        double value = std::abs(x[i] - M_PI);\n        if (value < closest_value) {\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012997635,19,0.0,True,True,0.0013060773,1.0,1.0
"#include <mpi.h>\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI and OpenMP to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",37_search_find_the_closest_number_to_pi,search,cpp,mpi+omp,0.2,0.95,True,1024,True,size_t closest_index = 0;\n    double closest_value = std::abs(x[0] - M_PI);\n    #pragma omp parallel for reduction(min:closest_value)\n    for (size_t i = 1; i < x.size(); i++) {\n        double value = std::abs(x[i] - M_PI);\n        if (value < closest_value) {\n            closest_value = value;\n            closest_index = i;\n        }\n    }\n    return closest_index;\n},True,False,0.0012997635,19,1.0,True,False,0.0008153724,2.0,1.0
