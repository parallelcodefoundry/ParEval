[
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "12_geometry_smallest_triangle",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {",
        "translation_prompt": "// Serial implementation of smallestArea\n// struct Point {\n// \tdouble x, y;\n// };\n// \n// double triangleArea(Point const& A, Point const& B, Point const& C) {\n//   return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n// }\n// \n// /* Return the area of the smallest triangle that can be formed by any 3 points.\n//    Example:\n// \n//    input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n//    output: 5.5\n// */\n// double smallestArea(std::vector<Point> const& points) {\n// double minArea = std::numeric_limits<double>::max();\n//   for (int i = 0; i < points.size(); ++i) {\n//     for (int j = i + 1; j < points.size(); ++j) {\n//       for (int k = j + 1; k < points.size(); ++k) {\n//         double area = triangleArea(points[i], points[j], points[k]);\n//         if (area < minArea) {\n//           minArea = area;\n//         }\n//       }\n//     }\n//   }\n//   return minArea;\n// }\n\n// OpenMP implementation of smallestArea\n#include <omp.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {\ndouble minArea = std::numeric_limits<double>::max();\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}",
        "translation_function_name": "smallestArea",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        #pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n",
            "\n  double minArea = std::numeric_limits<double>::max();\n#pragma omp parallel for\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n#pragma omp critical\n        {\n          if (area < minArea) {\n            minArea = area;\n          }\n        }\n      }\n    }\n  }\n  return minArea;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of closestPair\n// double distance(double x1, double x2) {\n// \treturn std::abs(x1 - x2);\n// }\n// \n// /* Return the distance between the closest two elements in the vector x.\n//    Example: \n// \n//    input: [7, 3, 9, 12, 31, 1]\n//    output: 2\n// */\n// double closestPair(std::vector<double> const& x) {\n// double min_dist = std::numeric_limits<double>::max();\n// \tfor (size_t i = 0; i < x.size(); ++i) {\n// \t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n// \t\t\tdouble dist = distance(x[i], x[j]);\n// \t\t\tif (dist < min_dist) {\n// \t\t\t\tmin_dist = dist;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn min_dist;\n// }\n\n// OpenMP implementation of closestPair\n#include <omp.h>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {\ndouble min_dist = std::numeric_limits<double>::max();\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}",
        "translation_function_name": "closestPair",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\ndouble min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "13_geometry_closest_pair_2d",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {",
        "translation_prompt": "// Serial implementation of closestPair\n// struct Point {\n// \tdouble x, y;\n// };\n// \n// double distance(Point const& p1, Point const& p2) {\n// \treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n// }\n// \n// /* Return the distance between the closest two points in the vector points.\n//    Example: \n// \n//    input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n//    output: 1.41421\n// */\n// double closestPair(std::vector<Point> const& points) {\n// if (points.size() < 2) {\n// \t\treturn 0;\n// \t}\n// \tdouble min_dist = std::numeric_limits<double>::max();\n// \tfor (int i = 0; i < points.size(); ++i) {\n// \t\tfor (int j = i + 1; j < points.size(); ++j) {\n// \t\t\tdouble dist = distance(points[i], points[j]);\n// \t\t\tif (dist < min_dist) {\n// \t\t\t\tmin_dist = dist;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn min_dist;\n// }\n\n// OpenMP implementation of closestPair\n#include <omp.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use OpenMP to compute in parallel.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {\nif (points.size() < 2) {\n\t\treturn 0;\n\t}\n\tdouble min_dist = std::numeric_limits<double>::max();\n\tfor (int i = 0; i < points.size(); ++i) {\n\t\tfor (int j = i + 1; j < points.size(); ++j) {\n\t\t\tdouble dist = distance(points[i], points[j]);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}",
        "translation_function_name": "closestPair",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n#pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n\t\treturn 0;\n\t}\n\tdouble min_dist = std::numeric_limits<double>::max();\n\t#pragma omp parallel for\n\tfor (int i = 0; i < points.size(); ++i) {\n\t\tfor (int j = i + 1; j < points.size(); ++j) {\n\t\t\tdouble dist = distance(points[i], points[j]);\n\t\t\t#pragma omp critical\n\t\t\t{\n\t\t\t\tif (dist < min_dist) {\n\t\t\t\t\tmin_dist = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n#pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n#pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n#pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n#pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n#pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n    return min_dist;\n}\n",
            "\n    if (points.size() < 2) {\n        return 0;\n    }\n    double min_dist = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            #pragma omp critical\n            {\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n    return min_dist;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "16_graph_largest_component",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of largestComponent\n// /* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n//    output: 2\n// */\n// int largestComponent(std::vector<int> const& A, size_t N) {\n// std::vector<bool> visited(N, false);\n//   std::vector<int> component(N, 0);\n//   int max_component = 0;\n// \n//   for (size_t i = 0; i < N; i++) {\n//     if (!visited[i]) {\n//       int size = 0;\n//       std::queue<int> q;\n//       q.push(i);\n//       visited[i] = true;\n//       while (!q.empty()) {\n//         int v = q.front();\n//         q.pop();\n//         size++;\n//         for (size_t j = 0; j < N; j++) {\n//           if (A[v * N + j] == 1 &&!visited[j]) {\n//             q.push(j);\n//             visited[j] = true;\n//           }\n//         }\n//       }\n//       component[i] = size;\n//       max_component = std::max(max_component, size);\n//     }\n//   }\n// \n//   return max_component;\n// }\n\n// OpenMP implementation of largestComponent\n#include <omp.h>\n\n/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {\nstd::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 &&!visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}",
        "translation_function_name": "largestComponent",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for shared(A, N, visited, component, max_component) private(i, j, size, q, v)\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for shared(A, N, visited, component, max_component) private(i, size, q, v, j)\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for shared(A, N, visited, component, max_component) private(i, j, size, q, v)\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for shared(A, N, visited, component, max_component) private(i, j, size, q, v)\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for shared(A, N, visited, component, max_component) private(i, j, size, q, v)\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      {\n        max_component = std::max(max_component, size);\n      }\n    }\n  }\n\n  return max_component;\n}\n",
            "\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      #pragma omp critical\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "18_graph_count_components",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of componentCount\n// /* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n//    output: 2\n// */\n// int componentCount(std::vector<int> const& A, size_t N) {\n// std::vector<bool> visited(N, false);\n//     int count = 0;\n// \n//     for (size_t i = 0; i < N; ++i) {\n//         if (!visited[i]) {\n//             ++count;\n//             std::stack<size_t> stack;\n//             stack.push(i);\n//             visited[i] = true;\n// \n//             while (!stack.empty()) {\n//                 size_t node = stack.top();\n//                 stack.pop();\n// \n//                 for (size_t j = 0; j < N; ++j) {\n//                     if (A[node * N + j] &&!visited[j]) {\n//                         stack.push(j);\n//                         visited[j] = true;\n//                     }\n//                 }\n//             }\n//         }\n//     }\n// \n//     return count;\n// }\n\n// OpenMP implementation of componentCount\n#include <omp.h>\n\n/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {\nstd::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] &&!visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}",
        "translation_function_name": "componentCount",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp atomic\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp atomic\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack, node)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp atomic\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack, node)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack, node) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp critical\n            {\n                ++count;\n            }\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n",
            "\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    #pragma omp parallel for shared(A, N, visited, count) private(i, j, stack)\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            #pragma omp atomic\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                #pragma omp parallel for shared(A, N, visited, stack) private(j)\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        #pragma omp critical\n                        {\n                            stack.push(j);\n                            visited[j] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "15_graph_edge_count",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of edgeCount\n// /* Count the number of edges in the directed graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// int edgeCount(std::vector<int> const& A, size_t N) {\n// int count = 0;\n//   for (size_t i = 0; i < N; ++i) {\n//     for (size_t j = 0; j < N; ++j) {\n//       if (A[i * N + j] == 1) {\n//         ++count;\n//       }\n//     }\n//   }\n//   return count;\n// }\n\n// OpenMP implementation of edgeCount\n#include <omp.h>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {\nint count = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}",
        "translation_function_name": "edgeCount",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n",
            "\nint count = 0;\n#pragma omp parallel for reduction(+:count)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "17_graph_highest_degree",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of maxDegree\n// /* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// int maxDegree(std::vector<int> const& A, size_t N) {\n// int max_degree = 0;\n//   for (size_t i = 0; i < N; ++i) {\n//     int degree = 0;\n//     for (size_t j = 0; j < N; ++j) {\n//       if (A[i * N + j] == 1) {\n//         ++degree;\n//       }\n//     }\n//     if (degree > max_degree) {\n//       max_degree = degree;\n//     }\n//   }\n//   return max_degree;\n// }\n\n// OpenMP implementation of maxDegree\n#include <omp.h>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {\nint max_degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}",
        "translation_function_name": "maxDegree",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nint max_degree = 0;\n#pragma omp parallel for reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\n  int max_degree = 0;\n  #pragma omp parallel for reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\nint max_degree = 0;\n#pragma omp parallel for shared(A, N) reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
            "\n  int max_degree = 0;\n  #pragma omp parallel for reduction(max:max_degree)\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {",
        "translation_prompt": "// Serial implementation of shortestPathLength\n// /* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n//    output: 2\n// */\n// int shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n// std::vector<int> dist(N, INT_MAX);\n// \tstd::vector<int> prev(N, -1);\n// \tstd::queue<int> q;\n// \tq.push(source);\n// \tdist[source] = 0;\n// \twhile (!q.empty()) {\n// \t\tint u = q.front();\n// \t\tq.pop();\n// \t\tfor (int v = 0; v < N; ++v) {\n// \t\t\tif (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n// \t\t\t\tdist[v] = dist[u] + 1;\n// \t\t\t\tprev[v] = u;\n// \t\t\t\tq.push(v);\n// \t\t\t}\n// \t\t}\n// \t}\n// \tif (dist[dest] == INT_MAX) {\n// \t\treturn -1;\n// \t}\n// \tint path_len = 0;\n// \twhile (prev[dest]!= -1) {\n// \t\tpath_len++;\n// \t\tdest = prev[dest];\n// \t}\n// \treturn path_len;\n// }\n\n// OpenMP implementation of shortestPathLength\n#include <omp.h>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use OpenMP to compute in parallel.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\nstd::vector<int> dist(N, INT_MAX);\n\tstd::vector<int> prev(N, -1);\n\tstd::queue<int> q;\n\tq.push(source);\n\tdist[source] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int v = 0; v < N; ++v) {\n\t\t\tif (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\tprev[v] = u;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[dest] == INT_MAX) {\n\t\treturn -1;\n\t}\n\tint path_len = 0;\n\twhile (prev[dest]!= -1) {\n\t\tpath_len++;\n\t\tdest = prev[dest];\n\t}\n\treturn path_len;\n}",
        "translation_function_name": "shortestPathLength",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                #pragma omp critical\n                {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest] != -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n\n    #pragma omp parallel\n    {\n        while (!q.empty()) {\n            int u;\n            #pragma omp critical\n            {\n                u = q.front();\n                q.pop();\n            }\n            #pragma omp for\n            for (int v = 0; v < N; ++v) {\n                if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    #pragma omp critical\n                    {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest] != -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                #pragma omp critical\n                {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                #pragma omp critical\n                {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                #pragma omp critical\n                {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n\n    #pragma omp parallel\n    {\n        while (!q.empty()) {\n            int u;\n            #pragma omp critical\n            {\n                u = q.front();\n                q.pop();\n            }\n            #pragma omp for\n            for (int v = 0; v < N; ++v) {\n                if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                    dist[v] = dist[u] + 1;\n                    prev[v] = u;\n                    #pragma omp critical\n                    {\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest] != -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n",
            "\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n    q.push(source);\n    dist[source] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        #pragma omp parallel for\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n    if (dist[dest] == INT_MAX) {\n        return -1;\n    }\n    int path_len = 0;\n    while (prev[dest]!= -1) {\n        path_len++;\n        dest = prev[dest];\n    }\n    return path_len;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "28_reduce_smallest_odd_number",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {",
        "translation_prompt": "// Serial implementation of smallestOdd\n// /* Return the value of the smallest odd number in the vector x.\n//    Examples:\n// \n//    input: [7, 9, 5, 2, 8, 16, 4, 1]\n//    output: 1\n// \n//    input: [8, 36, 7, 2, 11]\n//    output: 7\n// */\n// int smallestOdd(std::vector<int> const& x) {\n// int smallest = x[0];\n//   for (int i = 1; i < x.size(); i++) {\n//     if (x[i] % 2 == 1 && x[i] < smallest) {\n//       smallest = x[i];\n//     }\n//   }\n//   return smallest;\n// }\n\n// OpenMP implementation of smallestOdd\n#include <omp.h>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the value of the smallest odd number in the vector x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {\nint smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  return smallest;\n}",
        "translation_function_name": "smallestOdd",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\nint smallest = x[0];\n#pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\nint smallest = x[0];\n#pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\nint smallest = x[0];\n#pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1) {\n      #pragma omp critical\n      {\n        if (x[i] < smallest) {\n          smallest = x[i];\n        }\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n",
            "\n  int smallest = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); i++) {\n    #pragma omp critical\n    {\n      if (x[i] % 2 == 1 && x[i] < smallest) {\n        smallest = x[i];\n      }\n    }\n  }\n  return smallest;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "26_reduce_product_of_inverses",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use OpenMP to compute product in parallel.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of productWithInverses\n// /* Return the product of the vector x with every odd indexed element inverted.\n//    i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n//    Example:\n// \n//    input: [4, 2, 10, 4, 5]\n//    output: 25\n// */\n// double productWithInverses(std::vector<double> const& x) {\n// double result = 1;\n//   for (int i = 0; i < x.size(); i++) {\n//     if (i % 2 == 0) {\n//       result *= x[i];\n//     } else {\n//       result *= 1 / x[i];\n//     }\n//   }\n//   return result;\n// }\n\n// OpenMP implementation of productWithInverses\n#include <omp.h>\n\n/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use OpenMP to compute product in parallel.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {\ndouble result = 1;\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}",
        "translation_function_name": "productWithInverses",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n",
            "\n  double result = 1;\n  #pragma omp parallel for reduction(*:result)\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "29_reduce_sum_of_min_of_pairs",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use OpenMP to sum in parallel.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {",
        "translation_prompt": "// Serial implementation of sumOfMinimumElements\n// /* Return the sum of the minimum value at each index of vectors x and y for all indices.\n//    i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n//    Example:\n// \n//    input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n//    output: 10\n// */\n// double sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n// double sum = 0;\n//   for (int i = 0; i < x.size(); i++) {\n//     sum += std::min(x[i], y[i]);\n//   }\n//   return sum;\n// }\n\n// OpenMP implementation of sumOfMinimumElements\n#include <omp.h>\n\n/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use OpenMP to sum in parallel.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\ndouble sum = 0;\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}",
        "translation_function_name": "sumOfMinimumElements",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n#pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n#pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n",
            "\n  double sum = 0;\n  #pragma omp parallel for reduction(+:sum)\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the average of the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of average\n// /* Return the average of the vector x.\n//    Examples:\n// \t\t\n// \t input: [1, 8, 4, 5, 1]\n//    output: 3.8\n// \n//    input: [2, 2, 2, 3]\n//    output: 2.25\n// */\n// double average(std::vector<double> const& x) {\n// double sum = 0;\n// \tfor (double i : x) {\n// \t\tsum += i;\n// \t}\n// \treturn sum / x.size();\n// }\n\n// OpenMP implementation of average\n#include <omp.h>\n\n/* Return the average of the vector x.\n   Use OpenMP to compute in parallel.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {\ndouble sum = 0;\n\tfor (double i : x) {\n\t\tsum += i;\n\t}\n\treturn sum / x.size();\n}",
        "translation_function_name": "average",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); i++) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n",
            "\n    double sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); ++i) {\n        sum += x[i];\n    }\n    return sum / x.size();\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "25_reduce_xor",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the logical XOR reduction of the vector of bools x.\n   Use OpenMP to reduce in parallel.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {",
        "translation_prompt": "// Serial implementation of reduceLogicalXOR\n// /* Return the logical XOR reduction of the vector of bools x.\n//    Example:\n// \n//    input: [false, false, false, true]\n//    output: true\n// */\n// bool reduceLogicalXOR(std::vector<bool> const& x) {\n// bool result = false;\n//   for (auto const& i : x) {\n//     result ^= i;\n//   }\n//   return result;\n// }\n\n// OpenMP implementation of reduceLogicalXOR\n#include <omp.h>\n\n/* Return the logical XOR reduction of the vector of bools x.\n   Use OpenMP to reduce in parallel.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {\nbool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}",
        "translation_function_name": "reduceLogicalXOR",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n  bool result = false;\n#pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n    bool result = false;\n    #pragma omp parallel for reduction(^:result)\n    for (auto const& i : x) {\n        result ^= i;\n    }\n    return result;\n}\n",
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n",
            "\n  bool result = false;\n  #pragma omp parallel for reduction(^:result)\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "32_scan_sum_of_prefix_sum_array",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of sumOfPrefixSum\n// /* Compute the prefix sum array of the vector x and return its sum.\n//    Example:\n// \n//    input: [-7, 2, 1, 9, 4, 8]\n//    output: 15\n// */\n// double sumOfPrefixSum(std::vector<double> const& x) {\n// double sum = 0;\n//     std::vector<double> prefix_sum(x.size());\n// \n//     for (size_t i = 0; i < x.size(); ++i) {\n//         if (i == 0) {\n//             prefix_sum[i] = x[i];\n//         } else {\n//             prefix_sum[i] = prefix_sum[i - 1] + x[i];\n//         }\n//         sum += prefix_sum[i];\n//     }\n// \n//     return sum;\n// }\n\n// OpenMP implementation of sumOfPrefixSum\n#include <omp.h>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {\ndouble sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}",
        "translation_function_name": "sumOfPrefixSum",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n",
            "\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {",
        "translation_prompt": "// Serial implementation of partialMinimums\n// /* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n//    Examples:\n// \n//    input: [8, 6, -1, 7, 3, 4, 4]\n//    output: [8, 6, -1, -1, -1, -1, -1]\n// \n//    input: [5, 4, 6, 4, 3, 6, 1, 1]\n//    output: [5, 4, 4, 4, 3, 3, 1, 1]\n// */\n// void partialMinimums(std::vector<float> &x) {\n// float min = x[0];\n//     for (int i = 0; i < x.size(); i++) {\n//         if (x[i] < min) {\n//             min = x[i];\n//         }\n//         x[i] = min;\n//     }\n// }\n\n// OpenMP implementation of partialMinimums\n#include <omp.h>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {\nfloat min = x[0];\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n}",
        "translation_function_name": "partialMinimums",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        float min = x[0];\n        for (int j = 0; j <= i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}\n",
            "\n    float min = x[0];\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < min) {\n            #pragma omp critical\n            {\n                if (x[i] < min) {\n                    min = x[i];\n                }\n            }\n        }\n        #pragma omp critical\n        {\n            x[i] = min;\n        }\n    }\n}\n",
            "\n    float min = x[0];\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < min) {\n            #pragma omp critical\n            {\n                if (x[i] < min) {\n                    min = x[i];\n                }\n            }\n        }\n        #pragma omp critical\n        {\n            x[i] = min;\n        }\n    }\n}\n",
            "\n    float min = x[0];\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < min) {\n            #pragma omp critical\n            {\n                if (x[i] < min) {\n                    min = x[i];\n                }\n            }\n        }\n        #pragma omp critical\n        {\n            x[i] = min;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "30_scan_prefix_sum",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {",
        "translation_prompt": "// Serial implementation of prefixSum\n// /* Compute the prefix sum of the vector x into output.\n//    Example:\n//    \n//    input: [1, 7, 4, 6, 6, 2]\n//    output: [1, 8, 12, 18, 24, 26]\n// */\n// void prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n// output.resize(x.size());\n//   output[0] = x[0];\n//   for (int i = 1; i < x.size(); ++i) {\n//     output[i] = output[i-1] + x[i];\n//   }\n// }\n\n// OpenMP implementation of prefixSum\n#include <omp.h>\n\n/* Compute the prefix sum of the vector x into output.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the prefix sum of the vector x into output.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\noutput.resize(x.size());\n  output[0] = x[0];\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}",
        "translation_function_name": "prefixSum",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n",
            "\n  output.resize(x.size());\n  output[0] = x[0];\n  #pragma omp parallel for\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "56_transform_negate_odds",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of negateOddsAndHalveEvens\n// /* In the vector x negate the odd values and divide the even values by 2.\n//    Example:\n// \n//    input: [16, 11, 12, 14, 1, 0, 5]\n//    output: [8, -11, 6, 7, -1, 0, -5]\n// */\n// void negateOddsAndHalveEvens(std::vector<int> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         if (x[i] % 2 == 0) {\n//             x[i] /= 2;\n//         } else {\n//             x[i] = -x[i];\n//         }\n//     }\n// }\n\n// OpenMP implementation of negateOddsAndHalveEvens\n#include <omp.h>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}",
        "translation_function_name": "negateOddsAndHalveEvens",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "59_transform_map_function",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {",
        "translation_prompt": "// Serial implementation of mapPowersOfTwo\n// bool isPowerOfTwo(int x) {\n// \treturn (x > 0) && !(x & (x - 1));\n// }\n// \n// /* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n//    Example:\n// \n//    input: [8, 0, 9, 7, 15, 64, 3]\n//    output: [true, false, false, false, false, true, false]\n// */\n// void mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n// for (int i = 0; i < x.size(); i++) {\n// \t\tmask[i] = isPowerOfTwo(x[i]);\n// \t}\n// }\n\n// OpenMP implementation of mapPowersOfTwo\n#include <omp.h>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\nfor (int i = 0; i < x.size(); i++) {\n\t\tmask[i] = isPowerOfTwo(x[i]);\n\t}\n}",
        "translation_function_name": "mapPowersOfTwo",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n\t\tmask[i] = isPowerOfTwo(x[i]);\n\t}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    mask[i] = isPowerOfTwo(x[i]);\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n\t\tmask[i] = isPowerOfTwo(x[i]);\n\t}\n}"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "57_transform_inverse_offset",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {",
        "translation_prompt": "// Serial implementation of oneMinusInverse\n// /* Replace every element of the vector x with 1-1/x.\n//    Example:\n// \n//    input: [2, 4, 1, 12, -2]\n//    output: [0.5, 0.75, 0, 0.91666666, 1.5]\n// */\n// void oneMinusInverse(std::vector<double> &x) {\n// for (auto &e : x) {\n//     e = 1.0 - 1.0 / e;\n//   }\n// }\n\n// OpenMP implementation of oneMinusInverse\n#include <omp.h>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Replace every element of the vector x with 1-1/x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {\nfor (auto &e : x) {\n    e = 1.0 - 1.0 / e;\n  }\n}",
        "translation_function_name": "oneMinusInverse",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); i++) {\n    x[i] = 1.0 - 1.0 / x[i];\n  }\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {",
        "translation_prompt": "// Serial implementation of relu\n// /* Compute the ReLU function on every element of x. Elements less than zero become zero,\n//    while elements greater than zero stay the same.\n//    Example:\n// \n//    input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n//    output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n// */\n// void relu(std::vector<double> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         if (x[i] < 0) {\n//             x[i] = 0;\n//         }\n//     }\n// }\n\n// OpenMP implementation of relu\n#include <omp.h>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}",
        "translation_function_name": "relu",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] < 0) {\n        x[i] = 0;\n    }\n}\n}"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "58_transform_squaring",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Replace every element of x with the square of its value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of squareEach\n// /* Replace every element of x with the square of its value.\n//    Example:\n// \n//    input: [5, 1, 2, -4, 8]\n//    output: [25, 1, 4, 16, 64]\n// */\n// void squareEach(std::vector<int> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         x[i] = x[i] * x[i];\n//     }\n// }\n\n// OpenMP implementation of squareEach\n#include <omp.h>\n\n/* Replace every element of x with the square of its value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Replace every element of x with the square of its value.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
        "translation_function_name": "squareEach",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    x[i] = x[i] * x[i];\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    x[i] = x[i] * x[i];\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    x[i] = x[i] * x[i];\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use OpenMP to parallelize.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {",
        "translation_prompt": "// Serial implementation of spmv\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n//    and A is a sparse matrix stored in COO format.\n//    A has dimensions MxN, x has N values, and y has M values.\n//    Example:\n// \n//    input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n//    output: y=[2, 3]\n// */\n// void spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//       y[i] *= beta;\n//    }\n// \n//    for (size_t i = 0; i < A.size(); ++i) {\n//       y[A[i].row] += alpha * A[i].value * x[A[i].column];\n//    }\n// }\n\n// OpenMP implementation of spmv\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use OpenMP to parallelize.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}",
        "translation_function_name": "spmv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "46_sparse_la_spmm",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// Serial implementation of spmm\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n//    X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n//    Example:\n// \n//    input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n//    output: Y=[{-1,-4}, {1,0}]\n// */\n// void spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n// std::vector<double> Ytemp(M*N, 0.0);\n//    for (auto const& a : A) {\n//       for (auto const& x : X) {\n//          if (a.column == x.row) {\n//             Ytemp[a.row*N + x.column] += a.value * x.value;\n//          }\n//       }\n//    }\n//    Y = std::move(Ytemp);\n// }\n\n// OpenMP implementation of spmm\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\nstd::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}",
        "translation_function_name": "spmm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n#pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n#pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n#pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n",
            "\n   std::vector<double> Ytemp(M*N, 0.0);\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      for (size_t j = 0; j < X.size(); ++j) {\n         if (A[i].column == X[j].row) {\n            #pragma omp atomic\n            Ytemp[A[i].row*N + X[j].column] += A[i].value * X[j].value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "49_sparse_la_sparse_lu_decomp",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {",
        "translation_prompt": "// Serial implementation of luFactorize\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n//    A is a sparse NxN matrix stored in COO format.\n//    Example:\n// \n//    input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n//    output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n// */\n// void luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n// \n// // Assuming A is sorted by row and then by column\n// L.clear();\n// U.clear();\n// \n// // Initialize L and U with zeros\n// L.resize(N * N, 0);\n// U.resize(N * N, 0);\n// \n// // Create a map for quick access to A's elements\n// std::map<std::pair<size_t, size_t>, double> A_map;\n// for (const auto& elem : A) {\n//     A_map[{elem.row, elem.column}] = elem.value;\n// }\n// \n// // LU decomposition algorithm\n// for (size_t i = 0; i < N; ++i) {\n//     // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n//     for (size_t k = i; k < N; ++k) {\n//         double sum = 0.0;\n//         for (size_t j = 0; j < i; ++j) {\n//             sum += L[i * N + j] * U[j * N + k];\n//         }\n//         U[i * N + k] = A_map[{i, k}] - sum;\n//     }\n// \n//     // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n//     for (size_t k = i + 1; k < N; ++k) {\n//         double sum = 0.0;\n//         for (size_t j = 0; j < i; ++j) {\n//             sum += L[k * N + j] * U[j * N + i];\n//         }\n//         L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n//     }\n// \n//     // L(i, i) = 1\n//     L[i * N + i] = 1.0;\n// }\n// }\n\n// OpenMP implementation of luFactorize\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n\n// Assuming A is sorted by row and then by column\nL.clear();\nU.clear();\n\n// Initialize L and U with zeros\nL.resize(N * N, 0);\nU.resize(N * N, 0);\n\n// Create a map for quick access to A's elements\nstd::map<std::pair<size_t, size_t>, double> A_map;\nfor (const auto& elem : A) {\n    A_map[{elem.row, elem.column}] = elem.value;\n}\n\n// LU decomposition algorithm\nfor (size_t i = 0; i < N; ++i) {\n    // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n    for (size_t k = i; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[i * N + j] * U[j * N + k];\n        }\n        U[i * N + k] = A_map[{i, k}] - sum;\n    }\n\n    // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n    for (size_t k = i + 1; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[k * N + j] * U[j * N + i];\n        }\n        L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n    }\n\n    // L(i, i) = 1\n    L[i * N + i] = 1.0;\n}\n}",
        "translation_function_name": "luFactorize",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\nL.clear();\nU.clear();\n\nL.resize(N * N, 0);\nU.resize(N * N, 0);\n\nstd::map<std::pair<size_t, size_t>, double> A_map;\nfor (const auto& elem : A) {\n    A_map[{elem.row, elem.column}] = elem.value;\n}\n\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n    for (size_t k = i; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[i * N + j] * U[j * N + k];\n        }\n        U[i * N + k] = A_map[{i, k}] - sum;\n    }\n\n    for (size_t k = i + 1; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[k * N + j] * U[j * N + i];\n        }\n        L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n    }\n\n    L[i * N + i] = 1.0;\n}\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n",
            "\n    L.clear();\n    U.clear();\n\n    L.resize(N * N, 0);\n    U.resize(N * N, 0);\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        #pragma omp parallel for\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "23_histogram_first_letter_counts",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {",
        "translation_prompt": "// Serial implementation of firstLetterCounts\n// /* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n//    Assume all strings are in lower case. Store the output in `bins` array.\n//    Example:\n// \n//    input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n//    output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n// */\n// void firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n// for (auto const& str : s) {\n//         bins[str[0] - 'a']++;\n//     }\n// }\n\n// OpenMP implementation of firstLetterCounts\n#include <omp.h>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\nfor (auto const& str : s) {\n        bins[str[0] - 'a']++;\n    }\n}",
        "translation_function_name": "firstLetterCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < s.size(); i++) {\n        #pragma omp atomic\n        bins[s[i][0] - 'a']++;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "21_histogram_bin_0-100",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {",
        "translation_prompt": "// Serial implementation of binsBy10Count\n// /* Vector x contains values between 0 and 100, inclusive. Count the number of\n//    values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n//    Example:\n// \n//    input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n//    output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n// */\n// void binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n// for (auto const& value : x) {\n//     if (value < 10) {\n//       bins[0]++;\n//     } else if (value < 20) {\n//       bins[1]++;\n//     } else if (value < 30) {\n//       bins[2]++;\n//     } else if (value < 40) {\n//       bins[3]++;\n//     } else if (value < 50) {\n//       bins[4]++;\n//     } else if (value < 60) {\n//       bins[5]++;\n//     } else if (value < 70) {\n//       bins[6]++;\n//     } else if (value < 80) {\n//       bins[7]++;\n//     } else if (value < 90) {\n//       bins[8]++;\n//     } else {\n//       bins[9]++;\n//     }\n//   }\n// }\n\n// OpenMP implementation of binsBy10Count\n#include <omp.h>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\nfor (auto const& value : x) {\n    if (value < 10) {\n      bins[0]++;\n    } else if (value < 20) {\n      bins[1]++;\n    } else if (value < 30) {\n      bins[2]++;\n    } else if (value < 40) {\n      bins[3]++;\n    } else if (value < 50) {\n      bins[4]++;\n    } else if (value < 60) {\n      bins[5]++;\n    } else if (value < 70) {\n      bins[6]++;\n    } else if (value < 80) {\n      bins[7]++;\n    } else if (value < 90) {\n      bins[8]++;\n    } else {\n      bins[9]++;\n    }\n  }\n}",
        "translation_function_name": "binsBy10Count",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    #pragma omp atomic\n    if (value < 10) {\n      bins[0]++;\n    } else if (value < 20) {\n      bins[1]++;\n    } else if (value < 30) {\n      bins[2]++;\n    } else if (value < 40) {\n      bins[3]++;\n    } else if (value < 50) {\n      bins[4]++;\n    } else if (value < 60) {\n      bins[5]++;\n    } else if (value < 70) {\n      bins[6]++;\n    } else if (value < 80) {\n      bins[7]++;\n    } else if (value < 90) {\n      bins[8]++;\n    } else {\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < x.size(); i++) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double value = x[i];\n    if (value < 10) {\n      #pragma omp atomic\n      bins[0]++;\n    } else if (value < 20) {\n      #pragma omp atomic\n      bins[1]++;\n    } else if (value < 30) {\n      #pragma omp atomic\n      bins[2]++;\n    } else if (value < 40) {\n      #pragma omp atomic\n      bins[3]++;\n    } else if (value < 50) {\n      #pragma omp atomic\n      bins[4]++;\n    } else if (value < 60) {\n      #pragma omp atomic\n      bins[5]++;\n    } else if (value < 70) {\n      #pragma omp atomic\n      bins[6]++;\n    } else if (value < 80) {\n      #pragma omp atomic\n      bins[7]++;\n    } else if (value < 90) {\n      #pragma omp atomic\n      bins[8]++;\n    } else {\n      #pragma omp atomic\n      bins[9]++;\n    }\n  }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {",
        "translation_prompt": "// Serial implementation of countQuadrants\n// struct Point {\n//    double x, y;\n// };\n// \n// /* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n//    Store the counts in `bins`.\n//    Example:\n// \n//    input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n//    output: [3, 1, 0, 2]\n// */\n// void countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n// for (auto const& point : points) {\n//       if (point.x > 0 && point.y > 0) {\n//          bins[0]++;\n//       } else if (point.x < 0 && point.y > 0) {\n//          bins[1]++;\n//       } else if (point.x < 0 && point.y < 0) {\n//          bins[2]++;\n//       } else {\n//          bins[3]++;\n//       }\n//    }\n// }\n\n// OpenMP implementation of countQuadrants\n#include <omp.h>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\nfor (auto const& point : points) {\n      if (point.x > 0 && point.y > 0) {\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         bins[2]++;\n      } else {\n         bins[3]++;\n      }\n   }\n}",
        "translation_function_name": "countQuadrants",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (size_t i = 0; i < points.size(); i++) {\n      auto const& point = points[i];\n      if (point.x > 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         #pragma omp atomic\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         #pragma omp atomic\n         bins[2]++;\n      } else {\n         #pragma omp atomic\n         bins[3]++;\n      }\n   }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "24_histogram_count_quartile",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {",
        "translation_prompt": "// Serial implementation of countQuartiles\n// /* Count the number of doubles in the vector x that have a fractional part \n//    in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n//    Examples:\n// \n//    input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n//    output: [2, 1, 2, 2]\n// \n//    input: [1.9, 0.2, 0.6, 10.1, 7.4]\n//    output: [2, 1, 1, 1]\n// */\n// void countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n// for (double num : x) {\n//         double fractional_part = num - std::floor(num);\n//         if (fractional_part < 0.25) {\n//             bins[0]++;\n//         } else if (fractional_part < 0.5) {\n//             bins[1]++;\n//         } else if (fractional_part < 0.75) {\n//             bins[2]++;\n//         } else {\n//             bins[3]++;\n//         }\n//     }\n// }\n\n// OpenMP implementation of countQuartiles\n#include <omp.h>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\nfor (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            bins[2]++;\n        } else {\n            bins[3]++;\n        }\n    }\n}",
        "translation_function_name": "countQuartiles",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            #pragma omp atomic\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            #pragma omp atomic\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            #pragma omp atomic\n            bins[2]++;\n        } else {\n            #pragma omp atomic\n            bins[3]++;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "20_histogram_pixel_histogram",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {",
        "translation_prompt": "// Serial implementation of pixelCounts\n// /* Count the number of pixels in image with each grayscale intensity.\n//    The vector `image` is a grayscale image with values 0-255.\n//    Store the results in `bins`.\n//    Example:\n//    \n//    input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n//    output: [0, 0, 2, 0, 1, ...]\n// */\n//  void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n// for (auto const& pixel : image) {\n//         bins[pixel]++;\n//     }\n// }\n\n// OpenMP implementation of pixelCounts\n#include <omp.h>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use OpenMP to count in parallel.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\nfor (auto const& pixel : image) {\n        bins[pixel]++;\n    }\n}",
        "translation_function_name": "pixelCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); i++) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); i++) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); ++i) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < image.size(); i++) {\n        #pragma omp atomic\n        bins[image[i]]++;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "38_search_find_the_first_even_number",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",
        "translation_prompt": "// Serial implementation of findFirstEven\n// /* Return the index of the first even number in the vector x.\n//    Examples:\n// \n//    input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n//    output: 6\n// \n//    input: [3, 8, 9, 9, 3, 4, 8, 6]\n//    output: 1\n// */\n// size_t findFirstEven(std::vector<int> const& x) {\n// for (size_t i = 0; i < x.size(); ++i) {\n//     if (x[i] % 2 == 0) {\n//       return i;\n//     }\n//   }\n//   return x.size();\n// }\n\n// OpenMP implementation of findFirstEven\n#include <omp.h>\n\n/* Return the index of the first even number in the vector x.\n   Use OpenMP to parallelize the search.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {\nfor (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}",
        "translation_function_name": "findFirstEven",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",
        "translation_prompt": "// Serial implementation of contains\n// /* Return true if the vector x contains the value `target`. Return false otherwise.\n//    Examples:\n// \n//    input: x=[1, 8, 2, 6, 4, 6], target=3\n//    output: false\n//    \n//    input: x=[1, 8, 2, 6, 4, 6], target=8\n//    output: true\n// */\n// bool contains(std::vector<int> const& x, int target) {\n// return std::find(x.begin(), x.end(), target)!= x.end();\n// }\n\n// OpenMP implementation of contains\n#include <omp.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {\nreturn std::find(x.begin(), x.end(), target)!= x.end();\n}",
        "translation_function_name": "contains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); ++i) {\n    if (x[i] == target) {\n        return true;\n    }\n}\nreturn false;\n}"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "39_search_xor_contains",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",
        "translation_prompt": "// Serial implementation of xorContains\n// /* Return true if `val` is only in one of vectors x or y.\n//    Return false if it is in both or neither.\n//    Examples:\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n//    output: true\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n//    output: false\n// */\n// bool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n// return std::find(x.begin(), x.end(), val)!= x.end() ^\n//          std::find(y.begin(), y.end(), val)!= y.end();\n// }\n\n// OpenMP implementation of xorContains\n#include <omp.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use OpenMP to search in parallel.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\nreturn std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",
        "translation_function_name": "xorContains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    bool foundInX = false;\n    bool foundInY = false;\n#pragma omp parallel sections\n    {\n#pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n#pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n    return foundInX ^ foundInY;\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x ^ contains_y;\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x != contains_y;\n}",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n#pragma omp parallel sections\n    {\n#pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n#pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool containsX = false;\n    bool containsY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                containsX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                containsY = true;\n            }\n        }\n    }\n\n    return (containsX && !containsY) || (!containsX && containsY);\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x ^ contains_y;\n}\n",
            "\n    bool containsInX = false;\n    bool containsInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                containsInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                containsInY = true;\n            }\n        }\n    }\n\n    return containsInX ^ containsInY;\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x ^ contains_y;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool containsX = false;\n    bool containsY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                containsX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                containsY = true;\n            }\n        }\n    }\n\n    return containsX ^ containsY;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n    return foundInX ^ foundInY;\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x ^ contains_y;\n}\n",
            "\n#pragma omp parallel\n{\n    bool inX = false;\n    bool inY = false;\n    #pragma omp for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == val) {\n            inX = true;\n            break;\n        }\n    }\n    #pragma omp for\n    for (int i = 0; i < y.size(); i++) {\n        if (y[i] == val) {\n            inY = true;\n            break;\n        }\n    }\n    return inX ^ inY;\n}\n}",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n#pragma omp parallel sections\n{\n    #pragma omp section\n    {\n        if (std::find(x.begin(), x.end(), val) != x.end()) {\n            #pragma omp atomic\n            contains_x = true;\n        }\n    }\n    #pragma omp section\n    {\n        if (std::find(y.begin(), y.end(), val) != y.end()) {\n            #pragma omp atomic\n            contains_y = true;\n        }\n    }\n}\nreturn contains_x ^ contains_y;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n",
            "\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            if (std::find(x.begin(), x.end(), val) != x.end()) {\n                foundInX = true;\n            }\n        }\n        #pragma omp section\n        {\n            if (std::find(y.begin(), y.end(), val) != y.end()) {\n                foundInY = true;\n            }\n        }\n    }\n\n    return (foundInX && !foundInY) || (!foundInX && foundInY);\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "35_search_search_for_last_struct_by_key",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",
        "translation_prompt": "// Serial implementation of findLastShortBook\n// struct Book {\n//    std::string title;\n//    int pages;\n// };\n// \n// /* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n// \t Example:\n// \n//    input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n//    output: 2\n// */\n// size_t findLastShortBook(std::vector<Book> const& books) {\n// size_t last_short_book_index = 0;\n//    for (size_t i = 0; i < books.size(); ++i) {\n//       if (books[i].pages < 100) {\n//          last_short_book_index = i;\n//       }\n//    }\n//    return last_short_book_index;\n// }\n\n// OpenMP implementation of findLastShortBook\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use OpenMP to search in parallel.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {\nsize_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
        "translation_function_name": "findLastShortBook",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\n   size_t last_short_book_index = 0;\n   #pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n",
            "\nsize_t last_short_book_index = 0;\n#pragma omp parallel for\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         #pragma omp critical\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "37_search_find_the_closest_number_to_pi",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of findClosestToPi\n// /* Return the index of the value in the vector x that is closest to the math constant PI.\n//    Use M_PI for the value of PI.\n//    Example:\n// \n//    input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n//    output: 1\n// */\n// size_t findClosestToPi(std::vector<double> const& x) {\n// double min_distance = std::numeric_limits<double>::max();\n//   size_t min_index = 0;\n//   for (size_t i = 0; i < x.size(); ++i) {\n//     double distance = std::abs(x[i] - M_PI);\n//     if (distance < min_distance) {\n//       min_distance = distance;\n//       min_index = i;\n//     }\n//   }\n//   return min_index;\n// }\n\n// OpenMP implementation of findClosestToPi\n#include <omp.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use OpenMP to search in parallel.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {\ndouble min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n  return min_index;\n}",
        "translation_function_name": "findClosestToPi",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  size_t min_index = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  size_t min_index = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  size_t min_index = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  size_t min_index = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  size_t min_index = 0;\n  double min_distance = std::numeric_limits<double>::max();\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n",
            "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  #pragma omp parallel for\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    #pragma omp critical\n    {\n      if (distance < min_distance) {\n        min_distance = distance;\n        min_index = i;\n      }\n    }\n  }\n  return min_index;\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "08_fft_split_fft",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {",
        "translation_prompt": "// Serial implementation of fft\n// /* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n// */\n// void fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n// int n = x.size();\n//     if (n == 0) return;\n//     if (n == 1) {\n//         r[0] = x[0].real();\n//         i[0] = x[0].imag();\n//         return;\n//     }\n//     std::vector<std::complex<double>> x_even(n / 2);\n//     std::vector<std::complex<double>> x_odd(n / 2);\n//     for (int i = 0; i < n / 2; i++) {\n//         x_even[i] = x[2 * i];\n//         x_odd[i] = x[2 * i + 1];\n//     }\n//     std::vector<double> r_even(n / 2);\n//     std::vector<double> i_even(n / 2);\n//     std::vector<double> r_odd(n / 2);\n//     std::vector<double> i_odd(n / 2);\n//     fft(x_even, r_even, i_even);\n//     fft(x_odd, r_odd, i_odd);\n//     for (int k = 0; k < n / 2; k++) {\n//         std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n//         r[k] = r_even[k] + z.real();\n//         i[k] = i_even[k] + z.imag();\n//         r[k + n / 2] = r_even[k] - z.real();\n//         i[k + n / 2] = i_even[k] - z.imag();\n//     }\n// }\n\n// OpenMP implementation of fft\n#include <omp.h>\n\n/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\nint n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}",
        "translation_function_name": "fft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp task\n    fft(x_even, r_even, i_even);\n    #pragma omp task\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp taskwait\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        fft(x_even, r_even, i_even);\n        #pragma omp section\n        fft(x_odd, r_odd, i_odd);\n    }\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n",
            "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    #pragma omp parallel for\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    #pragma omp parallel for\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "07_fft_fft_conjugate",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of fftConjugate\n// /* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n// */\n// void fftConjugate(std::vector<std::complex<double>> &x) {\n// int n = x.size();\n//     int m = 0;\n//     for (int i = 0; i < n; i++) {\n//         int j = i;\n//         for (int k = 0; k < m; k++) {\n//             j = j ^ (1 << k);\n//         }\n//         if (i < j) {\n//             std::complex<double> temp = x[i];\n//             x[i] = x[j];\n//             x[j] = temp;\n//         }\n//         m = std::max(m, __builtin_ctz(j));\n//     }\n//     for (int i = 1; i < n; i *= 2) {\n//         std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n//         for (int j = 0; j < n; j += 2 * i) {\n//             for (int k = 0; k < i; k++) {\n//                 std::complex<double> u = x[j + k];\n//                 std::complex<double> t = w * x[j + k + i];\n//                 x[j + k] = u + t;\n//                 x[j + k + i] = u - t;\n//             }\n//             w = w * w;\n//         }\n//     }\n// }\n\n// OpenMP implementation of fftConjugate\n#include <omp.h>\n\n/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\nint n = x.size();\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}",
        "translation_function_name": "fftConjugate",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) default(none)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) default(none)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) private(i, j, k, temp, w)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) private(i, w)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) private(i, j, k, temp, w)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) private(i, w)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) private(i, j, k, temp, w)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) private(i, w)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) default(none)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) default(none)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x, n, m) private(i, j, k, temp, w)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x, n) private(i, w)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n",
            "\n    int n = x.size();\n    int m = 0;\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    #pragma omp parallel for shared(x) private(m)\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        #pragma omp for\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "05_fft_inverse_fft",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of ifft\n// /* forward declare fft. computes fourier transform in-place */\n// void fft(std::vector<std::complex<double>> &x);\n// \n// /* Compute the inverse fourier transform of x in-place.\n//    Example:\n//    \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n// */\n// void ifft(std::vector<std::complex<double>> &x) {\n// \n// // Take conjugate of the complex numbers\n// for (auto &elem : x) {\n//     elem = std::conj(elem);\n// }\n// \n// // Apply fft\n// fft(x);\n// \n// // Take conjugate again\n// for (auto &elem : x) {\n//     elem = std::conj(elem);\n// }\n// \n// // Scale the numbers\n// for (auto &elem : x) {\n//     elem /= static_cast<double>(x.size());\n// }\n// }\n\n// OpenMP implementation of ifft\n#include <omp.h>\n\n/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {\n\n// Take conjugate of the complex numbers\nfor (auto &elem : x) {\n    elem = std::conj(elem);\n}\n\n// Apply fft\nfft(x);\n\n// Take conjugate again\nfor (auto &elem : x) {\n    elem = std::conj(elem);\n}\n\n// Scale the numbers\nfor (auto &elem : x) {\n    elem /= static_cast<double>(x.size());\n}\n}",
        "translation_function_name": "ifft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        fft(x);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel\n    {\n        #pragma omp for\n        for (int i = 0; i < x.size(); i++) {\n            fft(x);\n        }\n\n        #pragma omp for\n        for (int i = 0; i < x.size(); i++) {\n            x[i] = std::conj(x[i]);\n        }\n\n        #pragma omp for\n        for (int i = 0; i < x.size(); i++) {\n            x[i] /= static_cast<double>(x.size());\n        }\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n",
            "\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    fft(x);\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        x[i] /= static_cast<double>(x.size());\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "06_fft_dft",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {",
        "translation_prompt": "// Serial implementation of dft\n// /* Compute the discrete fourier transform of x. Store the result in output.\n//    Example:\n// \n//    input: [1, 4, 9, 16]\n//    output: [30+0i, -8-12i, -10-0i, -8+12i]\n// */\n// void dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n// // TODO: implement this function\n//     output.resize(x.size());\n//     for (int i = 0; i < x.size(); i++) {\n//         output[i] = 0;\n//         for (int j = 0; j < x.size(); j++) {\n//             output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n//         }\n//     }\n// }\n\n// OpenMP implementation of dft\n#include <omp.h>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n// TODO: implement this function\n    output.resize(x.size());\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}",
        "translation_function_name": "dft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n",
            "\n    output.resize(x.size());\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "translation_prompt": "// Serial implementation of fft\n// /* Compute the fourier transform of x. Store the result in output.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n// */\n// void fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n// int n = x.size();\n//     output.resize(n);\n// \n//     // base case\n//     if (n == 1) {\n//         output[0] = x[0];\n//         return;\n//     }\n// \n//     // radix 2 Cooley-Tukey FFT\n//     // decompose x into even and odd parts\n//     std::vector<std::complex<double>> x_even(n/2);\n//     std::vector<std::complex<double>> x_odd(n/2);\n//     for (int k = 0; k < n/2; k++) {\n//         x_even[k] = x[2*k];\n//         x_odd[k] = x[2*k + 1];\n//     }\n// \n//     // recursively compute FFTs of even and odd parts\n//     std::vector<std::complex<double>> y_even(n/2);\n//     std::vector<std::complex<double>> y_odd(n/2);\n//     fft(x_even, y_even);\n//     fft(x_odd, y_odd);\n// \n//     // combine results\n//     for (int k = 0; k < n/2; k++) {\n//         double kth = -2 * M_PI * k / n;\n//         output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n//         output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n//     }\n// }\n\n// OpenMP implementation of fft\n#include <omp.h>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\nint n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}",
        "translation_function_name": "fft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
            "\n    int n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    #pragma omp task\n    fft(x_even, y_even);\n    #pragma omp task\n    fft(x_odd, y_odd);\n    #pragma omp taskwait\n\n    // combine results\n    #pragma omp parallel for\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "03_dense_la_axpy",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {",
        "translation_prompt": "// Serial implementation of axpy\n// /* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n//    Example:\n//    \n//    input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n//    output: z=[2, -6, 5, 17]\n// */\n// void axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n// for (int i = 0; i < x.size(); ++i) {\n//     z[i] = alpha*x[i] + y[i];\n//   }\n// }\n\n// OpenMP implementation of axpy\n#include <omp.h>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\nfor (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}",
        "translation_function_name": "axpy",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "01_dense_la_solve",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "translation_prompt": "// Serial implementation of solveLinearSystem\n// /* Solve the linear system Ax=b for x.\n//    A is an NxN matrix in row-major. x and b have N elements.\n//    Example:\n//    \n//    input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n//    output: x=[3, 1, 2]\n// */\n// void solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n// // check if the input is valid\n//     if (A.size()!= N * N) {\n//         throw std::invalid_argument(\"A must be a NxN matrix\");\n//     }\n//     if (b.size()!= N) {\n//         throw std::invalid_argument(\"b must have N elements\");\n//     }\n//     // create a copy of A\n//     std::vector<double> A_copy(A);\n//     // create a copy of b\n//     std::vector<double> b_copy(b);\n//     // perform Gaussian elimination\n//     for (size_t i = 0; i < N; i++) {\n//         // find the pivot row and swap it with the current row\n//         size_t pivot_row = i;\n//         for (size_t j = i + 1; j < N; j++) {\n//             if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n//                 pivot_row = j;\n//             }\n//         }\n//         if (pivot_row!= i) {\n//             // swap the current row with the pivot row\n//             for (size_t j = 0; j < N; j++) {\n//                 std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n//             }\n//             std::swap(b_copy[i], b_copy[pivot_row]);\n//         }\n//         // eliminate the current row\n//         for (size_t j = i + 1; j < N; j++) {\n//             double factor = A_copy[j * N + i] / A_copy[i * N + i];\n//             for (size_t k = 0; k < N; k++) {\n//                 A_copy[j * N + k] -= factor * A_copy[i * N + k];\n//             }\n//             b_copy[j] -= factor * b_copy[i];\n//         }\n//     }\n//     // back substitution\n//     x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n//     for (size_t i = N - 2; i < N; i--) {\n//         double sum = 0;\n//         for (size_t j = i + 1; j < N; j++) {\n//             sum += A_copy[i * N + j] * x[j];\n//         }\n//         x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n//     }\n// }\n\n// OpenMP implementation of solveLinearSystem\n#include <omp.h>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n// check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}",
        "translation_function_name": "solveLinearSystem",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination in parallel\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution in parallel\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 1; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    #pragma omp parallel for shared(A_copy, b_copy) default(none)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none)\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination in parallel\n    #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for shared(A_copy, b_copy) default(none) schedule(static)\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution in parallel\n    #pragma omp parallel for shared(A_copy, b_copy, x) default(none) schedule(static)\n    for (size_t i = N - 1; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n",
            "\n    // check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination in parallel\n    #pragma omp parallel for\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        #pragma omp parallel for\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution in parallel\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    #pragma omp parallel for\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "02_dense_la_gemm",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// Serial implementation of gemm\n// /* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n//    A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n//    output: C=[[9, 5], [4, 2]]\n// */\n// void gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             double sum = 0;\n//             for (size_t k = 0; k < K; ++k) {\n//                 sum += A[i * K + k] * B[k * N + j];\n//             }\n//             C[i * N + j] = sum;\n//         }\n//     }\n// }\n\n// OpenMP implementation of gemm\n#include <omp.h>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}",
        "translation_function_name": "gemm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        double sum = 0;\n        #pragma omp parallel for reduction(+:sum)\n        for (size_t k = 0; k < K; ++k) {\n            sum += A[i * K + k] * B[k * N + j];\n        }\n        C[i * N + j] = sum;\n    }\n}\n}",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        double sum = 0;\n        for (size_t k = 0; k < K; ++k) {\n            sum += A[i * K + k] * B[k * N + j];\n        }\n        C[i * N + j] = sum;\n    }\n}\n}",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        double sum = 0;\n        #pragma omp parallel for reduction(+:sum)\n        for (size_t k = 0; k < K; ++k) {\n            sum += A[i * K + k] * B[k * N + j];\n        }\n        C[i * N + j] = sum;\n    }\n}\n}",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < M; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        double sum = 0;\n        for (size_t k = 0; k < K; ++k) {\n            sum += A[i * K + k] * B[k * N + j];\n        }\n        C[i * N + j] = sum;\n    }\n}\n}",
            "\n#pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            #pragma omp parallel for reduction(+:sum)\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "04_dense_la_gemv",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {",
        "translation_prompt": "// Serial implementation of gemv\n// /* Multiply the matrix A by the vector x. Store the results in the vector y.\n//    A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n//    output: y=[1, -3]\n// */\n// void gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//         double sum = 0;\n//         for (size_t j = 0; j < N; ++j) {\n//             sum += A[i * N + j] * x[j];\n//         }\n//         y[i] = sum;\n//     }\n// }\n\n// OpenMP implementation of gemv\n#include <omp.h>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}",
        "translation_function_name": "gemv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n    double sum = 0;\n    for (size_t j = 0; j < N; ++j) {\n        sum += A[i * N + j] * x[j];\n    }\n    y[i] = sum;\n}\n}",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "00_dense_la_lu_decomp",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {",
        "translation_prompt": "// Serial implementation of luFactorize\n// /* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n//    Store the results for L and U into the original matrix A. \n//    A is an NxN matrix stored in row-major.\n//    Example:\n// \n//    input: [[4, 3], [6, 3]]\n//    output: [[4, 3], [1.5, -1.5]]\n// */\n// void luFactorize(std::vector<double> &A, size_t N) {\n// for (size_t i = 0; i < N; i++) {\n//     for (size_t j = i + 1; j < N; j++) {\n//       A[j * N + i] = A[j * N + i] / A[i * N + i];\n//       for (size_t k = i + 1; k < N; k++) {\n//         A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n//       }\n//     }\n//   }\n// }\n\n// OpenMP implementation of luFactorize\n#include <omp.h>\n\n/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {\nfor (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}",
        "translation_function_name": "luFactorize",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "42_sort_sorted_ranks",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {",
        "translation_prompt": "// Serial implementation of ranks\n// /* For each value in the vector x compute its index in the sorted vector.\n//    Store the results in `ranks`.\n//    Examples:\n// \n//    input: [3.1, 2.8, 9.1, 0.4, 3.14]\n//    output: [2, 1, 4, 0, 3]\n//  \n//    input: [100, 7.6, 16.1, 18, 7.6]\n//    output: [4, 0, 1, 2, 3]\n// */\n// void ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n// std::vector<float> sorted = x;\n//     std::sort(sorted.begin(), sorted.end());\n//     ranks.resize(x.size());\n//     for (size_t i = 0; i < x.size(); ++i) {\n//         ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n//     }\n// }\n\n// OpenMP implementation of ranks\n#include <omp.h>\n\n/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use OpenMP to compute in parallel.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\nstd::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}",
        "translation_function_name": "ranks",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n",
            "\n    std::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "44_sort_sort_non-zero_elements",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use OpenMP to sort x in parallel. \n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of sortIgnoreZero\n// /* Sort the vector x in ascending order ignoring elements with value 0.\n//    Leave zero valued elements in-place.\n//    Example:\n// \n// \t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n//    output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n// */\n// void sortIgnoreZero(std::vector<int> &x) {\n// int n = x.size();\n//   int i = 0;\n//   int j = 0;\n//   int k = 0;\n// \n//   while (i < n) {\n//     if (x[i] == 0) {\n//       i++;\n//     } else {\n//       j = i + 1;\n//       while (j < n) {\n//         if (x[j] == 0) {\n//           j++;\n//         } else {\n//           if (x[i] > x[j]) {\n//             k = x[i];\n//             x[i] = x[j];\n//             x[j] = k;\n//           }\n//           j++;\n//         }\n//       }\n//       i++;\n//     }\n//   }\n// }\n\n// OpenMP implementation of sortIgnoreZero\n#include <omp.h>\n\n/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use OpenMP to sort x in parallel. \n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place.\n   Example:\n\n\t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {\nint n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < n) {\n    if (x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < n) {\n        if (x[j] == 0) {\n          j++;\n        } else {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n}",
        "translation_function_name": "sortIgnoreZero",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x, n)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x, n)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0 && x[i] > x[j]) {\n          k = x[i];\n          x[i] = x[j];\n          x[j] = k;\n        }\n      }\n    }\n  }\n}\n",
            "\n  int n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  #pragma omp parallel for private(i, j, k) shared(x)\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      for (j = i + 1; j < n; j++) {\n        if (x[j] != 0) {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n        }\n      }\n    }\n  }\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "41_sort_k-th_smallest_element",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Find the k-th smallest element of the vector x.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {",
        "translation_prompt": "// Serial implementation of findKthSmallest\n// /* Find the k-th smallest element of the vector x.\n//    Example:\n//    \n//    input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n//    output: 6\n// */\n// int findKthSmallest(std::vector<int> const& x, int k) {\n// int n = x.size();\n//     std::vector<int> y(x);\n//     std::sort(y.begin(), y.end());\n//     return y[k-1];\n// }\n\n// OpenMP implementation of findKthSmallest\n#include <omp.h>\n\n/* Find the k-th smallest element of the vector x.\n   Use OpenMP to compute in parallel.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {\nint n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n    return y[k-1];\n}",
        "translation_function_name": "findKthSmallest",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        y[i] = x[i];\n    }\n    std::sort(y.begin(), y.end());\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n",
            "\n    int n = x.size();\n    std::vector<int> y(x);\n    #pragma omp parallel for\n    for (int i = 0; i < n; i++) {\n        std::sort(y.begin(), y.end());\n    }\n    return y[k-1];\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "43_sort_sort_an_array_of_structs_by_key",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {",
        "translation_prompt": "// Serial implementation of sortByStartTime\n// struct Result {\n//    int startTime, duration;\n//    float value;\n// };\n// \n// /* Sort vector of Result structs by start time in ascending order.\n//    Example:\n//    \n//    input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n//    output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n// */\n// void sortByStartTime(std::vector<Result> &results) {\n// std::sort(results.begin(), results.end(), [](const Result &a, const Result &b) {\n//       return a.startTime < b.startTime;\n//    });\n// }\n\n// OpenMP implementation of sortByStartTime\n#include <omp.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {\nstd::sort(results.begin(), results.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n}",
        "translation_function_name": "sortByStartTime",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      #pragma omp for\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      #pragma omp for\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}\n",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}",
            "\n#pragma omp parallel for\n   for (int i = 0; i < results.size(); i++) {\n      for (int j = i + 1; j < results.size(); j++) {\n         if (results[i].startTime > results[j].startTime) {\n            std::swap(results[i], results[j]);\n         }\n      }\n   }\n}"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "40_sort_sort_an_array_of_complex_numbers_by_magnitude",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of sortComplexByMagnitude\n// /* Sort the vector x of complex numbers by their magnitude in ascending order.\n//    Example:\n//    \n//    input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n//    output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n// */\n// void sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n// std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n//         return std::abs(a) < std::abs(b);\n//     });\n// }\n\n// OpenMP implementation of sortComplexByMagnitude\n#include <omp.h>\n\n/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use OpenMP to sort in parallel.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\nstd::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n}",
        "translation_function_name": "sortComplexByMagnitude",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        for (int j = i + 1; j < x.size(); j++) {\n            if (std::abs(x[j]) < std::abs(x[i])) {\n                std::swap(x[i], x[j]);\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        for (int j = i + 1; j < x.size(); j++) {\n            if (std::abs(x[j]) < std::abs(x[i])) {\n                std::swap(x[i], x[j]);\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        for (int j = i + 1; j < x.size(); j++) {\n            if (std::abs(x[j]) < std::abs(x[i])) {\n                std::swap(x[i], x[j]);\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    #pragma omp critical\n    {\n        std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for\nfor (int i = 0; i < x.size(); i++) {\n    for (int j = i + 1; j < x.size(); j++) {\n        if (std::abs(x[j]) < std::abs(x[i])) {\n            std::swap(x[i], x[j]);\n        }\n    }\n}\n}"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of cellsXOR\n// /* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n//    Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n//    input and output are NxN grids of ints in row-major.\n//    Example:\n// \n//    input: [[0, 1, 1, 0],\n//            [1, 0, 0, 0],\n//            [0, 0, 0, 0],\n//            [0, 1, 0, 0]\n//    output: [[0, 0, 1, 1],\n//             [1, 0, 0, 1],\n//             [0, 0, 1, 0],\n//             [1, 0, 1, 0]]\n// */\n// void cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n// for (size_t i = 0; i < N; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             int count = 0;\n//             if (i > 0 && input[i - 1 + j * N] == 1) {\n//                 ++count;\n//             }\n//             if (i < N - 1 && input[i + 1 + j * N] == 1) {\n//                 ++count;\n//             }\n//             if (j > 0 && input[i + (j - 1) * N] == 1) {\n//                 ++count;\n//             }\n//             if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n//                 ++count;\n//             }\n//             if (count == 1) {\n//                 output[i + j * N] = 1;\n//             } else {\n//                 output[i + j * N] = 0;\n//             }\n//         }\n//     }\n// }\n\n// OpenMP implementation of cellsXOR\n#include <omp.h>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}",
        "translation_function_name": "cellsXOR",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(input, output, N)\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(input, output, N)\nfor (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        int count = 0;\n        if (i > 0 && input[i - 1 + j * N] == 1) {\n            ++count;\n        }\n        if (i < N - 1 && input[i + 1 + j * N] == 1) {\n            ++count;\n        }\n        if (j > 0 && input[i + (j - 1) * N] == 1) {\n            ++count;\n        }\n        if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n            ++count;\n        }\n        if (count == 1) {\n            output[i + j * N] = 1;\n        } else {\n            output[i + j * N] = 0;\n        }\n    }\n}\n}",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "54_stencil_game_of_life",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of gameOfLife\n// /* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n//    A cell is 1 if it is alive and 0 if it is dead.\n//    If a live cell has fewer than 2 live neighbors then it dies.\n//    If a live cell has 2 or 3 live neighbors then it lives on.\n//    If a live cell has more than 3 live neighbords then it dies.\n//    If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Example:\n// \n//    input:  [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 0, 0, 0],\n//             [0, 1, 1, 0, 0],\n//             [0, 0, 1, 1, 0],\n//             [0, 1, 0, 0, 0]]\n//    output: [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 1, 0, 0],\n//             [0, 1, 0, 1, 0],\n//             [0, 0, 0, 1, 0],\n//             [0, 0, 1, 0, 0]]\n// */\n// void gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n// std::vector<int> next(input.size(), 0);\n//   for (size_t i = 0; i < N; ++i) {\n//     for (size_t j = 0; j < N; ++j) {\n//       int count = 0;\n//       for (int x = -1; x <= 1; ++x) {\n//         for (int y = -1; y <= 1; ++y) {\n//           if (x == 0 && y == 0) {\n//             continue;\n//           }\n//           size_t r = (i + x + N) % N;\n//           size_t c = (j + y + N) % N;\n//           count += input[r * N + c];\n//         }\n//       }\n//       if (input[i * N + j] == 1) {\n//         next[i * N + j] = (count == 2 || count == 3);\n//       } else {\n//         next[i * N + j] = (count == 3);\n//       }\n//     }\n//   }\n//   output = next;\n// }\n\n// OpenMP implementation of gameOfLife\n#include <omp.h>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\nstd::vector<int> next(input.size(), 0);\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}",
        "translation_function_name": "gameOfLife",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2) shared(input, next, output)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2) shared(input, next, output)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for collapse(2) shared(input, next, output)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n#pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n",
            "\n  std::vector<int> next(input.size(), 0);\n  #pragma omp parallel for collapse(2)\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "52_stencil_1d_jacobi_3-point_stencil",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {",
        "translation_prompt": "// Serial implementation of jacobi1D\n// /* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n//    i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n//    Replace with 0 when reading past the boundaries of `input`.\n//    Example:\n// \n//    input: [9, -6, -1, 2, 3]\n//    output: [1, 2/3, -5/3, 4/3, 5/3]\n// */\n// void jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n// // YOUR CODE HERE\n//     for (int i = 1; i < input.size() - 1; i++) {\n//         output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n//     }\n// }\n\n// OpenMP implementation of jacobi1D\n#include <omp.h>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n// YOUR CODE HERE\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
        "translation_function_name": "jacobi1D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "51_stencil_edge_kernel",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {",
        "translation_prompt": "// Serial implementation of convolveKernel\n// const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n// \n// /* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n//    the dot product of itself and its neighbors with the edge kernel.\n//    Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n//    imageIn and imageOut are NxN grayscale images stored in row-major.\n//    Store the output of the computation in imageOut.\n//    Example:\n// \n//    input: [[112, 118, 141, 152],\n//            [93, 101, 119, 203],\n//            [45, 17, 16, 232],\n//            [82, 31, 49, 101]]\n//    output: [[255, 255, 255, 255],\n//             [255, 147, 0, 255],\n//             [36, 0, 0, 255],\n//             [255, 39, 0, 255]]\n// */\n// void convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n// for (size_t i = 0; i < N; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             int sum = 0;\n//             for (int k = -1; k <= 1; ++k) {\n//                 for (int l = -1; l <= 1; ++l) {\n//                     int x = i + k;\n//                     int y = j + l;\n//                     if (x >= 0 && x < N && y >= 0 && y < N) {\n//                         sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n//                     }\n//                 }\n//             }\n//             imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n//         }\n//     }\n// }\n\n// OpenMP implementation of convolveKernel\n#include <omp.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}",
        "translation_function_name": "convolveKernel",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(imageIn, imageOut, N, edgeKernel)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            #pragma omp critical\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(imageIn, imageOut, N, edgeKernel)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(imageIn, imageOut, N, edgeKernel)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            #pragma omp critical\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(imageIn, imageOut, N, edgeKernel)\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            #pragma omp critical\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}\n",
            "\n#pragma omp parallel for collapse(2) shared(imageIn, imageOut, N, edgeKernel)\nfor (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n        int sum = 0;\n        for (int k = -1; k <= 1; ++k) {\n            for (int l = -1; l <= 1; ++l) {\n                int x = i + k;\n                int y = j + l;\n                if (x >= 0 && x < N && y >= 0 && y < N) {\n                    sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                }\n            }\n        }\n        #pragma omp critical\n        imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n    }\n}\n}"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "53_stencil_2d_jacobi_5-point_stencil",
        "parallelism_model": "omp",
        "prompt": "#include <omp.h>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of jacobi2D\n// /* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n//    i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n//    Replace with 0 when reading past the boundaries of `input`.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Example:\n// \n//    input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n//    output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n// */\n// void jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n// for (size_t i = 1; i < N - 1; ++i) {\n//     for (size_t j = 1; j < N - 1; ++j) {\n//       output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n//     }\n//   }\n// }\n\n// OpenMP implementation of jacobi2D\n#include <omp.h>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use OpenMP to compute in parallel.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "omp",
        "translation_src_example": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}",
        "translation_function_name": "jacobi2D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for collapse(2)\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\n  for (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n",
            "\n#pragma omp parallel for\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}\n"
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "12_geometry_smallest_triangle",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {",
        "translation_prompt": "// Serial implementation of smallestArea\n// struct Point {\n// \tdouble x, y;\n// };\n// \n// double triangleArea(Point const& A, Point const& B, Point const& C) {\n//   return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n// }\n// \n// /* Return the area of the smallest triangle that can be formed by any 3 points.\n//    Example:\n// \n//    input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n//    output: 5.5\n// */\n// double smallestArea(std::vector<Point> const& points) {\n// double minArea = std::numeric_limits<double>::max();\n//   for (int i = 0; i < points.size(); ++i) {\n//     for (int j = i + 1; j < points.size(); ++j) {\n//       for (int k = j + 1; k < points.size(); ++k) {\n//         double area = triangleArea(points[i], points[j], points[k]);\n//         if (area < minArea) {\n//           minArea = area;\n//         }\n//       }\n//     }\n//   }\n//   return minArea;\n// }\n\n// MPI implementation of smallestArea\n#include <mpi.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n  return 0.5 * std::abs( A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {\ndouble minArea = std::numeric_limits<double>::max();\n  for (int i = 0; i < points.size(); ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n  return minArea;\n}",
        "translation_function_name": "smallestArea",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  double minArea = std::numeric_limits<double>::max();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int chunkSize = points.size() / size;\n  int start = rank * chunkSize;\n  int end = (rank == size - 1) ? points.size() : start + chunkSize;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029585598,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036088258,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032182097,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00240928485,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00236741545,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019162416,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00548448649375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014046073875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021351072375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00872108320078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00560186843437,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Reduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return globalMinArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029520594,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036012532,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018535318,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110168795,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001745498025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017573811,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009941236875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002662581,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00041645199687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037065772891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024091604766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_n = points.size() / size;\n  int start = rank * local_n;\n  int end = (rank == size - 1) ? points.size() : start + local_n;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029569768,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036158788,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031427677,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026257956,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00225402275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001885250725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00523174075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00149469657188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00212198965,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00992358761719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00680582960547,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Reduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_minArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029551792,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037699704,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018485942,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109148665,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00171388495,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019626022125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011231861125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029954152813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00040451939531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029122022969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024028275195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Reduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return globalMinArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029532324,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003610597,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018930782,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109393535,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001694485825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018743427125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00100095050625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000477956325,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00053033555156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049343794922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027049474063,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Reduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_minArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002955226,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036203756,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001807766,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107346285,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001712155925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001677826275,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010076355875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027533775625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00050460615,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025452279219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025187400391,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Reduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_minArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002952751,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036281542,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018254578,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111244985,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018398042,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189989405,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010222824375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00048972167813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00044417024219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00040697726172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00023603709883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Reduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_minArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029514508,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036160372,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019046589,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110513035,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001687772125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002003206475,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009634869375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028437480937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046263283594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039638963516,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00022292573789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double minArea = std::numeric_limits<double>::max();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int chunkSize = points.size() / size;\n  int start = rank * chunkSize;\n  int end = (rank == size - 1) ? points.size() : start + chunkSize;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029618566,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036128392,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032233826,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0024493407,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00232259905,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0025531477875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00452801780625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162784677813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039558163375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01877354352266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607305655977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Reduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return globalMinArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029532522,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037756596,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018311887,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00108354675,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001814340775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037585936875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00094881938125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030984318438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00058138718906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00069900600312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00023629258828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_n = points.size() / size;\n  int start = rank * local_n;\n  int end = (rank == size - 1) ? points.size() : start + local_n;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029590726,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038336904,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003215131,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00262812885,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002209455225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019122525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00551461311875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00193485335312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034027768875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00603989773672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00676827277578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Reduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_minArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029523578,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003630869,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018082527,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010696788,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001795094675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00193621575,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095887859375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030590030313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00045563471875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00045431654062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00023576045898,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double minArea = std::numeric_limits<double>::max();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int chunkSize = points.size() / size;\n  int start = rank * chunkSize;\n  int end = (rank == size - 1) ? points.size() : start + chunkSize;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029602164,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036190348,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033010664,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00233938255,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00239237335,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019410007875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0048422107,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00195453238438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00203030891563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01082349586641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00713672099102,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029592812,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038549502,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032010284,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00237149795,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002235504225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020595716375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047811559875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00145463869687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00218802416406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01055881876953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00689574157539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double global_minArea;\n  MPI_Allreduce(&minArea, &global_minArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_minArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029563058,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036159626,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032864829,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00231576755,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00239755665,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019288088875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046107177375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153645681875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192260251094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00756408200547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00564215274492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_n = points.size() / size;\n  int start = rank * local_n;\n  int end = (rank == size - 1) ? points.size() : start + local_n;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029580322,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036157766,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031465218,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022902432,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0024366262,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017556152375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00541099910625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196087281562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00252234691875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01523488727109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00725265214648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double minArea = std::numeric_limits<double>::max();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  int chunkSize = points.size() / size;\n  int start = rank * chunkSize;\n  int end = (rank == size - 1) ? points.size() : start + chunkSize;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029601888,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036182432,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00319437,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00242329255,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002316099675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020683206625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00544257214375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017023198625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00224235701875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00966304712812,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00718960616914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_n = points.size() / size;\n  int start = rank * local_n;\n  int end = (rank == size - 1) ? points.size() : start + local_n;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029573248,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036140776,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031452733,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022825726,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00247115285,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018909083,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052441451625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00181531765938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00225942991719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01152832739609,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00670401314219,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_n = points.size() / size;\n  int start = rank * local_n;\n  int end = (rank == size - 1) ? points.size() : start + local_n;\n\n  for (int i = start; i < end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Allreduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n  return globalMinArea;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029575076,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037726236,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003170014,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00237913875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002289498375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001922121125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005269630375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00187294689375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017276367625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00500199368984,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00636187088789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double minArea = std::numeric_limits<double>::max();\n  int local_start = rank * (points.size() / size);\n  int local_end = (rank + 1) * (points.size() / size);\n  if (rank == size - 1) {\n    local_end = points.size();\n  }\n\n  for (int i = local_start; i < local_end; ++i) {\n    for (int j = i + 1; j < points.size(); ++j) {\n      for (int k = j + 1; k < points.size(); ++k) {\n        double area = triangleArea(points[i], points[j], points[k]);\n        if (area < minArea) {\n          minArea = area;\n        }\n      }\n    }\n  }\n\n  double globalMinArea;\n  MPI_Reduce(&minArea, &globalMinArea, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return globalMinArea;\n  } else {\n    return 0.0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029574442,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036011228,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018929395,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00126366715,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001751305175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016376051625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009512048625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024961267187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039756807187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038004658828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024989478086,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of closestPair\n// double distance(double x1, double x2) {\n// \treturn std::abs(x1 - x2);\n// }\n// \n// /* Return the distance between the closest two elements in the vector x.\n//    Example: \n// \n//    input: [7, 3, 9, 12, 31, 1]\n//    output: 2\n// */\n// double closestPair(std::vector<double> const& x) {\n// double min_dist = std::numeric_limits<double>::max();\n// \tfor (size_t i = 0; i < x.size(); ++i) {\n// \t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n// \t\t\tdouble dist = distance(x[i], x[j]);\n// \t\t\tif (dist < min_dist) {\n// \t\t\t\tmin_dist = dist;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn min_dist;\n// }\n\n// MPI implementation of closestPair\n#include <mpi.h>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {\ndouble min_dist = std::numeric_limits<double>::max();\n\tfor (size_t i = 0; i < x.size(); ++i) {\n\t\tfor (size_t j = i + 1; j < x.size(); ++j) {\n\t\t\tdouble dist = distance(x[i], x[j]);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}",
        "translation_function_name": "closestPair",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831870954,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247812058,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0634841407,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323787758,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0172812755,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009590711725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00868121820625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00337045410313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00550383072031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01405421022891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01381296787539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831826294,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248493352,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624461584,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0324493477,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017376899925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009801341225,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00861565865625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003419515175,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00423080711875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00558606672344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00614192503359,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831981306,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1262060714,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0633309877,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03218120875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017343895675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0104087582625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00842554268125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00349706324062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00461808046719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01236105773203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00781447913594,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.083185277,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247812584,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624475239,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0321511178,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017355326425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010434615325,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00867860396875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00347203411875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00447529314375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00882643529063,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00768418034297,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831557128,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247322742,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624453544,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323875803,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017009195725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009403186425,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00856354971875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00343565788125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00432029592344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01198100374141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00761613688047,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831946418,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248123246,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624932986,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03237203915,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017518874475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0119136057625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0084425333,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00315772150938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00485471535,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00643371135547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00568719053672,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831790834,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247667412,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624558221,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0324132165,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01735892415,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0096379146375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00814071611875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00342113680625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00643572942031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00905915128125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00709005394023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0832267028,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248336624,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.063531054,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0321793184,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017007879075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009711604625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082878240625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036582128875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00457265261094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00221517657734,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00763021919023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.083194953,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1289482306,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0640180668,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0320709195,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017305080725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0102020715875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0083662618375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00402441346875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004024396775,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02121940458359,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00797693358984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0832177354,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.125986403,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0631324863,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0320932026,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017444751725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0094634426375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00896576270625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00337406130313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045182995875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00894565315625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00605969937031,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831148802,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1265812324,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624832127,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03238718255,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017188147475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0097742391375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00865078925,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00338612434063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00471512411406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00984812434453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00753132225156,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831857434,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248367924,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0630321441,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323095646,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017379372425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0095280940125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0086740512,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003331510725,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00503236456563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01163870509687,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00693391519063,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831916588,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247781284,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624267115,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323197779,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017313025825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0116428571,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085626835375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035599781875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00443836725313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01154197724922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01157761055586,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831818862,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1259394828,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0634459361,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0321138771,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0171696766,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098833793375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0083063573625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00367668781875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00433700835781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01256702272891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00655091840898,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double min_dist = std::numeric_limits<double>::max();\n    int local_n = x.size() / size;\n    int local_start = rank * local_n;\n    int local_end = (rank == size - 1) ? x.size() : local_start + local_n;\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        for (size_t j = 0; j < x.size(); ++j) {\n            if (i != j) {\n                double dist = distance(x[i], x[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0617647976,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1665351502,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.088048895,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0449823392,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02253484575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012268371725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0097995995375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004273842225,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00507705221094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01223007975,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00727931510938,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0837989992,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1263079618,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0635623667,
                        "num_procs": 2
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 4
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0.0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0621448176,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.124803875,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0624399349,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03171943825,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016910353575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0086882019,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049086473625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00227226076562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00117404595938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00074265735625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046610434648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831839148,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1247700118,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0623960932,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03265113165,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0175332379,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0094935024,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00863814423125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00308357059063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00451144740781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00896941397969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00736962468945,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.083183797,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248199976,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0629458128,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0324971727,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01699328765,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0097760118375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00844811765625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00304384160937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00432795542031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00685190201797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00819959804492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (size_t i = rank; i < x.size(); i += size) {\n        for (size_t j = i + 1; j < x.size(); ++j) {\n            double dist = distance(x[i], x[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Allreduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n\n    return global_min_dist;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831346654,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1248154452,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0634551865,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0325571409,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017459408225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009809651775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00864468333125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00330156512813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00469315302656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01777204031094,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00620039950586,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "13_geometry_closest_pair_2d",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of points. The final result is returned on rank 0.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {",
        "translation_prompt": "// Serial implementation of closestPair\n// struct Point {\n// \tdouble x, y;\n// };\n// \n// double distance(Point const& p1, Point const& p2) {\n// \treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n// }\n// \n// /* Return the distance between the closest two points in the vector points.\n//    Example: \n// \n//    input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n//    output: 1.41421\n// */\n// double closestPair(std::vector<Point> const& points) {\n// if (points.size() < 2) {\n// \t\treturn 0;\n// \t}\n// \tdouble min_dist = std::numeric_limits<double>::max();\n// \tfor (int i = 0; i < points.size(); ++i) {\n// \t\tfor (int j = i + 1; j < points.size(); ++j) {\n// \t\t\tdouble dist = distance(points[i], points[j]);\n// \t\t\tif (dist < min_dist) {\n// \t\t\t\tmin_dist = dist;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn min_dist;\n// }\n\n// MPI implementation of closestPair\n#include <mpi.h>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of points. The final result is returned on rank 0.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::sqrt(std::pow(p2.x-p1.x, 2) + std::pow(p2.y-p1.y, 2));\n}\n\n/* Return the distance between the closest two points in the vector points.\n   Example: \n\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {\nif (points.size() < 2) {\n\t\treturn 0;\n\t}\n\tdouble min_dist = std::numeric_limits<double>::max();\n\tfor (int i = 0; i < points.size(); ++i) {\n\t\tfor (int j = i + 1; j < points.size(); ++j) {\n\t\t\tdouble dist = distance(points[i], points[j]);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist;\n}",
        "translation_function_name": "closestPair",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.372582517,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7482837358,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3742809601,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1882119999,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094758874175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047614989975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02433361715625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01204877819375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00601215862656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00336617490859,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00175534758984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3726427276,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3742008618,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1871315203,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09415833885,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0479359251,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242798276,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01256070044375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00606165364687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00307403944688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00184063753672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00093779682969,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (points.size() < 2) {\n        return 0;\n    }\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3734405972,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3741872924,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1874129116,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0940594158,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047877158925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242439256625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0124087746,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607286440938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00305363027969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00179302378672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00090320112305,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3720965282,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7477656604,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3739521984,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1875734077,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094891875775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04774328685,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0241159387375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01189997063125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00598030228437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00322281139063,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168886137031,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3722201968,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3735971148,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1872231033,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09397234855,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04794828085,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0243390331,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012536569975,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00603209505938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00305043298906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00183355786484,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095608485195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3726905208,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.37418865,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1872120122,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09409769425,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04782802275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0282820847125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01242697086875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00605097196875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00308151831406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00197048918594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110797848594,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (points.size() < 2) {\n        return 0;\n    }\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3736483648,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3741762788,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1872784302,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0941396056,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.048007205825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02427807705,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01259694985,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00604566937188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00307692856875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00174572608906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00096232010898,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3725101998,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7487345938,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.374882893,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18772023775,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094747062475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0479526835625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242715742125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01194718492813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00600413123594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00315174047656,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166378944453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.372352315,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7483011622,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3745333044,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18756239795,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09470284195,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0517421205,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02413184953125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01194451813125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00600814171563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00314129197266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166011297383,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3723699582,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7483352664,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3743389857,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1875917233,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094729512525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047671043375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242375136125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0119233429625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00599683099687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00320800388906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168853898906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3727364468,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7497957028,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.374872383,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18781919705,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.095079123475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0477543119125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242780412625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01193098300937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607594396719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00320550069453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00173132057617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.372522061,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7489352636,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3743785475,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18772999275,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0946313659,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0475438620875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242640040625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01191764665,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00596526620625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00316522430078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017116586207,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3726495848,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7488887142,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3743923383,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1875537713,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094641250675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0476742315875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0241876358375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01192989629687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00600900727969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00323567391641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016658847625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (points.size() < 2) {\n        return 0;\n    }\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3740827018,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3744174928,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1893010098,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.094028239,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047907359075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242060038375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01266023851875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00606490255937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00306095099844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00183432167422,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00087542264375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = 0; j < points.size(); ++j) {\n            if (i != j) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.372735213,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.7485750308,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3741435546,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1877234937,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0948473007,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047702933525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.024274924325,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0118986298625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00599262943125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00312650624375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00170390197461,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.372659096,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3747716736,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1872229798,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0940610226,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0480724008,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242116146,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01243419286875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00603845461875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00307980227344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00176134398672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00091219677695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (points.size() < 2) {\n        return 0;\n    }\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3737293328,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3742393336,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1873708746,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0940537285,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.048049840425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0242483910625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012496346075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00605817830937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00305417378125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162045007266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00091269357031,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3723651076,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.373794305,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1872316253,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09404508245,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04793321085,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0240758112125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0125475331125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607213656875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00305477257187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00175022611562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009209053125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (points.size() < 2) {\n        return 0;\n    }\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3733836506,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3737584468,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.187821003,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09427159425,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04806342425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0244118002625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126329620625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006050400575,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00305121013906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00167476830156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088496397852,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double min_dist = std::numeric_limits<double>::max();\n    for (int i = rank; i < points.size(); i += size) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            double dist = distance(points[i], points[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n    }\n\n    double global_min_dist;\n    MPI_Reduce(&min_dist, &global_min_dist, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_min_dist;\n    } else {\n        return 0.0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.3726003588,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3858052142,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1913070029,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0943620591,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0479225148,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02422878055,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126164420875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00605736393437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00304474358281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00183597903047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092840145234,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "16_graph_largest_component",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of largestComponent\n// /* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n//    output: 2\n// */\n// int largestComponent(std::vector<int> const& A, size_t N) {\n// std::vector<bool> visited(N, false);\n//   std::vector<int> component(N, 0);\n//   int max_component = 0;\n// \n//   for (size_t i = 0; i < N; i++) {\n//     if (!visited[i]) {\n//       int size = 0;\n//       std::queue<int> q;\n//       q.push(i);\n//       visited[i] = true;\n//       while (!q.empty()) {\n//         int v = q.front();\n//         q.pop();\n//         size++;\n//         for (size_t j = 0; j < N; j++) {\n//           if (A[v * N + j] == 1 &&!visited[j]) {\n//             q.push(j);\n//             visited[j] = true;\n//           }\n//         }\n//       }\n//       component[i] = size;\n//       max_component = std::max(max_component, size);\n//     }\n//   }\n// \n//   return max_component;\n// }\n\n// MPI implementation of largestComponent\n#include <mpi.h>\n\n/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the number of vertices in the largest component of the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {\nstd::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = 0; i < N; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 &&!visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  return max_component;\n}",
        "translation_function_name": "largestComponent",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821122736,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0781082696,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780886382,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08111419975,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08013572975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0787371198375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07981321296875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08041117205938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07968075362969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07984132514219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08129318421562,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0820851044,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077774086,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0792301973,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0809381988,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080160575075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0786958731375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07999417694375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07894097159688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07955709758125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08093896870469,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08126023608086,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 &&!visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821298288,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07972196,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780667414,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08127440815,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080021332375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0789916871375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080066889275,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07889592671875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07986781789375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08002051497266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0811796104918,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821795646,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0791850576,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0803432726,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.081647033,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08046392685,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0790531272625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07967969626875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0791112502125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07944677998125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08000357579453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08071431529766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.082173377,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078693169,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780613211,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0810408954,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07983722855,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078813975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07954424623125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07894042415312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07965692483906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07997495519844,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08090201542539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.082172211,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778266456,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779703701,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08084763995,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080255580925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078839365075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08012256869375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.082192795275,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07949364715312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08070568501484,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08127816475859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0823991236,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0783888234,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0782664345,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08098034515,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080126212475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0792353657875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07991887215625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07964525543437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07951706525312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08013613728984,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08107282766484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.082088504,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778294122,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779357688,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0811733293,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080185560475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078920748775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07966169859375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.079066634575,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08022999126406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07975048304141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08088426606602,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821078904,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0802240142,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0798512036,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0809075039,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08020805585,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078920268,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07992701785625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07897113681562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07977755842813,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08006907739922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08114764329375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0820956714,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0782470864,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778193154,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808531179,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080099864,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078802578375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07999029314375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08449332538125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07964902143437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07998257401328,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0820322125625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821181016,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077800241,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779905525,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808948189,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080463450175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0787244048125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07994693170625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07902752698125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07947873328438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07993394371641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08074637030078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821383828,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07783044,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0785797267,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807166467,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080317734225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.079050135925,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07967695764375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.081201350425,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07968344827344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07996738786797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08099963313125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  int local_max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      local_max_component = std::max(local_max_component, size);\n    }\n  }\n\n  MPI_Reduce(&local_max_component, &max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821462336,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0783952404,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780175166,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08063734405,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0797162807,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07878166605,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07985901673125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07941833970937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07938680907969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08000386020234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08130346303477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0820508904,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0784392972,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078000959,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0810703989,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080134050525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0786670717125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07963324246875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07981349267813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07931604270313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08005125483281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08082099199687,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0824657284,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077884973,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0788098807,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807901919,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080160570875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07894891445,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07997635228125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08125964628125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.079524649825,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07943833976406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08076870897344,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  size_t local_start = rank * (N / size);\n  size_t local_end = (rank == size - 1) ? N : (rank + 1) * (N / size);\n\n  for (size_t i = local_start; i < local_end; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0820920198,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0756246162,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0756792173,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07829387165,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077729244775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0765001489125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07757879313125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07703654209375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07727811753594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07770802526016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0792288875582,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 &&!visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.08218905,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780267456,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0784086564,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0809881659,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0798582759,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078945463325,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07968181258125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07907642843437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07948347163594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08051193715469,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808718751832,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  size_t local_start = rank * (N / size);\n  size_t local_end = (rank == size - 1) ? N : (rank + 1) * (N / size);\n\n  for (size_t i = local_start; i < local_end; i++) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0824843612,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07545158,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0756058737,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07879220295,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077790406825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0764306389875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07773006888125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07696640646875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07673066862031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07767601555156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07905414690469,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 && !visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821376958,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778401108,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0793022543,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08120009715,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080806559625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0789456682375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0799393147,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07892618745938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.079080186025,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08016880284062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08083700361719,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<bool> visited(N, false);\n  std::vector<int> component(N, 0);\n  int max_component = 0;\n\n  for (size_t i = rank; i < N; i += size) {\n    if (!visited[i]) {\n      int size = 0;\n      std::queue<int> q;\n      q.push(i);\n      visited[i] = true;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        size++;\n        for (size_t j = 0; j < N; j++) {\n          if (A[v * N + j] == 1 &&!visited[j]) {\n            q.push(j);\n            visited[j] = true;\n          }\n        }\n      }\n      component[i] = size;\n      max_component = std::max(max_component, size);\n    }\n  }\n\n  int global_max_component;\n  MPI_Reduce(&max_component, &global_max_component, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_max_component;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0821093486,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778225298,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0785485364,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08101913015,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08026448765,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0788906124875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0800659963125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07924024091875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07930220884844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07982445842891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08105970708438,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "18_graph_count_components",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The component count is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of componentCount\n// /* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n//    output: 2\n// */\n// int componentCount(std::vector<int> const& A, size_t N) {\n// std::vector<bool> visited(N, false);\n//     int count = 0;\n// \n//     for (size_t i = 0; i < N; ++i) {\n//         if (!visited[i]) {\n//             ++count;\n//             std::stack<size_t> stack;\n//             stack.push(i);\n//             visited[i] = true;\n// \n//             while (!stack.empty()) {\n//                 size_t node = stack.top();\n//                 stack.pop();\n// \n//                 for (size_t j = 0; j < N; ++j) {\n//                     if (A[node * N + j] &&!visited[j]) {\n//                         stack.push(j);\n//                         visited[j] = true;\n//                     }\n//                 }\n//             }\n//         }\n//     }\n// \n//     return count;\n// }\n\n// MPI implementation of componentCount\n#include <mpi.h>\n\n/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n\t Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The component count is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Count the number of connected components in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint componentCount(std::vector<int> const& A, size_t N) {\nstd::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] &&!visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}",
        "translation_function_name": "componentCount",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0859202188,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.084535418,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.083437244,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821384966,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818530238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0820065094,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int globalCount;\n    MPI_Reduce(&count, &globalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return globalCount;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082115325,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.081938426,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0818879188,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082129125,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.083964022,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0822143795,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821143572,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818836714,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0820388777,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082112149,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818898192,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0821786243,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0862268568,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0843350952,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0834545185,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int globalCount;\n    MPI_Reduce(&count, &globalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return globalCount;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0820940284,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0819422478,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0822318812,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082178488,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0819307986,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0827368598,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int globalCount;\n    MPI_Reduce(&count, &globalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return globalCount;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821667038,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0821292874,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0820046667,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.083162331,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.084429026,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.082079099,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0830755198,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.082200986,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0828767879,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0882003322,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0820406266,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0858752342,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0867293396,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0884975328,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0836591074,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int globalCount;\n    MPI_Reduce(&count, &globalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return globalCount;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082136535,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.089546661,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0819375345,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821157176,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818648628,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0820202235,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821308182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818780876,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0821112991,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821739914,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0818748992,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0835768167,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int count = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++count;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int global_count;\n    MPI_Reduce(&count, &global_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_count;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0855904888,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0848239578,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0837322322,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<bool> visited(N, false);\n    int localCount = 0;\n\n    for (size_t i = rank; i < N; i += size) {\n        if (!visited[i]) {\n            ++localCount;\n            std::stack<size_t> stack;\n            stack.push(i);\n            visited[i] = true;\n\n            while (!stack.empty()) {\n                size_t node = stack.top();\n                stack.pop();\n\n                for (size_t j = 0; j < N; ++j) {\n                    if (A[node * N + j] && !visited[j]) {\n                        stack.push(j);\n                        visited[j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int globalCount;\n    MPI_Reduce(&localCount, &globalCount, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return globalCount;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821445056,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0819097664,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0832931274,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "15_graph_edge_count",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of edgeCount\n// /* Count the number of edges in the directed graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// int edgeCount(std::vector<int> const& A, size_t N) {\n// int count = 0;\n//   for (size_t i = 0; i < N; ++i) {\n//     for (size_t j = 0; j < N; ++j) {\n//       if (A[i * N + j] == 1) {\n//         ++count;\n//       }\n//     }\n//   }\n//   return count;\n// }\n\n// MPI implementation of edgeCount\n#include <mpi.h>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A represents a directed graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {\nint count = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}",
        "translation_function_name": "edgeCount",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\nint count = 0;\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint localCount = 0;\nfor (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n        if (A[i * N + j] == 1) {\n            ++localCount;\n        }\n    }\n}\n\nMPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\nif (rank == 0) {\n    return count;\n} else {\n    return 0;\n}\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0032951876,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639373344,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.032326532,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01947111775,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0097567647,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045508571375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046623909625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00149197620938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00133347536719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00108682742813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00097438428633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  return count;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0033968808,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639541134,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0647123486,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  return count;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0037885786,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.065513264,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0642847667,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int localCount = 0;\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0036104462,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0654462324,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.032835605,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190602271,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0165082021,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004558141375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031362301,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00507437314063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00164740029375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00108295146016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00125156139648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int localCount = 0;\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0033552822,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639983136,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0322851094,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01944922875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01037163405,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045862362375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00486519103125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168196099375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002144001175,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00106242803828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00105228854961,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int localCount = 0;\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00334248,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639685636,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323954629,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0192526151,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01017575205,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056527391875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031297962,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158388625625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00123004474375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013896777625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00103938620664,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\nint count = 0;\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint localCount = 0;\nfor (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n        if (A[i * N + j] == 1) {\n            ++localCount;\n        }\n    }\n}\n\nMPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\nif (rank == 0) {\n    return count;\n} else {\n    return 0;\n}\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0043966938,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0654252796,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0322920319,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01887368785,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01021799675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004870719675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00350761045,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00257255046562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00315777996094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102902020391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00105836486758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  return count;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0032110852,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639876092,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0640795863,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return count;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int count = 0;\n  int localCount = 0;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++localCount;\n      }\n    }\n  }\n  MPI_Reduce(&localCount, &count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n  return count;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0043504286,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0639765306,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0646932086,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "17_graph_highest_degree",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {",
        "translation_prompt": "// Serial implementation of maxDegree\n// /* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// int maxDegree(std::vector<int> const& A, size_t N) {\n// int max_degree = 0;\n//   for (size_t i = 0; i < N; ++i) {\n//     int degree = 0;\n//     for (size_t j = 0; j < N; ++j) {\n//       if (A[i * N + j] == 1) {\n//         ++degree;\n//       }\n//     }\n//     if (degree > max_degree) {\n//       max_degree = degree;\n//     }\n//   }\n//   return max_degree;\n// }\n\n// MPI implementation of maxDegree\n#include <mpi.h>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The result is returned on rank 0.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {\nint max_degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++degree;\n      }\n    }\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}",
        "translation_function_name": "maxDegree",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0116939534,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0203937106,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0108261521,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019504512,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0194632861,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174867129,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02419175733125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030057976725,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04042012598906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05131226177578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.087823739125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0107109804,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0123721128,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0122967724,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0158847423,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01938392685,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01629537315,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02163623739375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0264599733,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03351496164531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05090057239922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08797668762656,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0112211356,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0119233228,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0111317376,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0155714928,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016781095925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190169636625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019660882825,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02884312219063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03786467224844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05066933244297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08820689457148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0098626798,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0112131416,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0105367572,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0175415105,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0154900885,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0163080082875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02347108770625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02597105343438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03860438838594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05179733647891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08801884051445,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0108606056,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0113922164,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016152091,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01628659835,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0170405716,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0231247591875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02159107534375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0316288614,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03857233558125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05003135740312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08772068155781,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0105735578,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.013429674,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0107314754,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190283071,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0214073746,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0217569197875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02254378761875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02699574777813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03227029155469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04950300072422,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08783677025625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    MPI_Reduce(&local_degree, &degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n    if (degree > max_degree) {\n      max_degree = degree;\n    }\n  }\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0109082848,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.261511399,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.259608733,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26475700725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.262242416125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.260294384075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.262604612625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26382680535625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26414173722656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26535946671562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26777034541445,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0108250018,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0108979472,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0104909715,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0162158296,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0177478701,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0168222998375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01999801823125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03271020602188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03684975184219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05124355590234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08784275057891,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0108400712,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010839442,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0204777737,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01936107465,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.021090256375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0145513207125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01982099933125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02968443539062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03247447161875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05208914598125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08816773258125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0114758652,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0153566864,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0123195231,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0158981421,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02108982755,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0168647545375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0237675212,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02560756470313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03079364174844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05296460231719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08757238701055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0112944232,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012869387,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0130718027,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0163944586,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0178547614,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132772533375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020638242425,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02713767027188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03314867230938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05115848528516,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08755025288555,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0128197636,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012642396,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0110237181,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016692733,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017136891025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0167924462375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02640212283125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0313958370625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.037486453475,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05296350439453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08812128767383,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0120498484,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0142451712,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0145845069,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01640790725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017860319175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018580044175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01892411561875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03015114072812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04491588978594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05155628601641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08838557742695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0137664244,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193156488,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133709841,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01605222965,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0197268429,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0209088751625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02200050169375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0284052575,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03463058078438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0532794165625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08822072406602,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0123880462,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0165679214,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011829809,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01736766605,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159427468,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015469823675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0213808280375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0250805214,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03337581924687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05025543626016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08775424162969,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0138153942,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014587828,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0112768682,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01956429475,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016394956475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0204014758375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02446481749375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03216919087188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03816612878594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0505769605,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08777141445313,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0143033686,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0206724828,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014757655,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174351217,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017077173825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0156313327875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02854479238125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270537157625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0332259685625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04939311957031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08902547935508,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0130977536,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0143637548,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01571514,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0168606172,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016665823,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0185205706,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02316153895,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.031559395425,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03659622889844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05084503661094,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08790308843359,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0132229528,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0234369838,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0134970484,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01795840645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02310342895,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017214881425,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0271921015125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02732391781562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03687161188281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05027513744766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08804421676523,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int max_degree = 0;\n  int degree = 0;\n  for (size_t i = 0; i < N; ++i) {\n    int local_degree = 0;\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i * N + j] == 1) {\n        ++local_degree;\n      }\n    }\n    if (local_degree > degree) {\n      degree = local_degree;\n    }\n  }\n  MPI_Reduce(&degree, &max_degree, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  return max_degree;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0159786386,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015005416,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0204193561,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02041921535,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018930433625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0182431793625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0253253460875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02848010654687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03486267067812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05150839973359,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08897885586523,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The shortest path length is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {",
        "translation_prompt": "// Serial implementation of shortestPathLength\n// /* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Example:\n// \n// \t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n//    output: 2\n// */\n// int shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n// std::vector<int> dist(N, INT_MAX);\n// \tstd::vector<int> prev(N, -1);\n// \tstd::queue<int> q;\n// \tq.push(source);\n// \tdist[source] = 0;\n// \twhile (!q.empty()) {\n// \t\tint u = q.front();\n// \t\tq.pop();\n// \t\tfor (int v = 0; v < N; ++v) {\n// \t\t\tif (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n// \t\t\t\tdist[v] = dist[u] + 1;\n// \t\t\t\tprev[v] = u;\n// \t\t\t\tq.push(v);\n// \t\t\t}\n// \t\t}\n// \t}\n// \tif (dist[dest] == INT_MAX) {\n// \t\treturn -1;\n// \t}\n// \tint path_len = 0;\n// \twhile (prev[dest]!= -1) {\n// \t\tpath_len++;\n// \t\tdest = prev[dest];\n// \t}\n// \treturn path_len;\n// }\n\n// MPI implementation of shortestPathLength\n#include <mpi.h>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. The shortest path length is returned on rank 0.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\nstd::vector<int> dist(N, INT_MAX);\n\tstd::vector<int> prev(N, -1);\n\tstd::queue<int> q;\n\tq.push(source);\n\tdist[source] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int v = 0; v < N; ++v) {\n\t\t\tif (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\tprev[v] = u;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[dest] == INT_MAX) {\n\t\treturn -1;\n\t}\n\tint path_len = 0;\n\twhile (prev[dest]!= -1) {\n\t\tpath_len++;\n\t\tdest = prev[dest];\n\t}\n\treturn path_len;\n}",
        "translation_function_name": "shortestPathLength",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_dist;\n    MPI_Reduce(&dist[dest], &global_dist, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n    if (global_dist == INT_MAX) {\n      return -1;\n    }\n    int path_len = 0;\n    int global_path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    MPI_Reduce(&path_len, &global_path_len, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    return global_path_len;\n  }\n  return -1;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0103475434,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0386011966,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      global_path_len = 0;\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<int> global_dist(N);\n    MPI_Reduce(&dist[0], &global_dist[0], N, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (global_dist[dest] == INT_MAX) {\n      return -1;\n    }\n\n    int path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    return path_len;\n  } else {\n    return -1;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0102681492,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0369319618,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<int> recv_dist(N);\n    MPI_Gather(&dist[0], N, MPI_INT, &recv_dist[0], N, MPI_INT, 0, MPI_COMM_WORLD);\n    std::vector<int> recv_prev(N);\n    MPI_Gather(&prev[0], N, MPI_INT, &recv_prev[0], N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    int min_dist = INT_MAX;\n    int min_rank = 0;\n    for (int i = 0; i < N; ++i) {\n      if (recv_dist[i] < min_dist && recv_dist[i] != INT_MAX) {\n        min_dist = recv_dist[i];\n        min_rank = i;\n      }\n    }\n\n    int path_len = 0;\n    if (min_dist != INT_MAX) {\n      while (recv_prev[min_rank] != -1) {\n        path_len++;\n        min_rank = recv_prev[min_rank];\n      }\n    }\n    return path_len;\n  } else {\n    return -1;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0101842244,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0370431076,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<int> global_dist(N);\n    MPI_Reduce(&dist[0], &global_dist[0], N, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (global_dist[dest] == INT_MAX) {\n      return -1;\n    }\n\n    int path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    return path_len;\n  }\n\n  return -1;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0102169652,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0368954562,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      int path_len = 0;\n      while (prev[dest] != -1) {\n        path_len++;\n        dest = prev[dest];\n      }\n      global_path_len = path_len;\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n    return path_len;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    for (int v = 0; v < N; ++v) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        q.push(v);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    if (dist[dest] == INT_MAX) {\n      return -1;\n    }\n    int path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    return path_len;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.010760278,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0370289516,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<int> dist(N, INT_MAX);\n    std::vector<int> prev(N, -1);\n    std::queue<int> q;\n\n    if (rank == 0) {\n        q.push(source);\n        dist[source] = 0;\n    }\n\n    while (!q.empty()) {\n        int u;\n        if (rank == 0) {\n            u = q.front();\n            q.pop();\n        }\n        MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n        for (int v = rank; v < N; v += size) {\n            if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                prev[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    if (rank == 0) {\n        int global_path_len = 0;\n        if (dist[dest] == INT_MAX) {\n            global_path_len = -1;\n        } else {\n            while (prev[dest] != -1) {\n                global_path_len++;\n                dest = prev[dest];\n            }\n        }\n        MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n    }\n\n    return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<int> recv_dist(N);\n    MPI_Gather(&dist[0], N, MPI_INT, &recv_dist[0], N, MPI_INT, 0, MPI_COMM_WORLD);\n    std::vector<int> recv_prev(N);\n    MPI_Gather(&prev[0], N, MPI_INT, &recv_prev[0], N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    int min_dist = INT_MAX;\n    for (int i = 0; i < N; ++i) {\n      if (recv_dist[i] < min_dist) {\n        min_dist = recv_dist[i];\n      }\n    }\n\n    if (min_dist == INT_MAX) {\n      return -1;\n    }\n\n    int path_len = 0;\n    while (recv_prev[dest] != -1) {\n      path_len++;\n      dest = recv_prev[dest];\n    }\n    return path_len;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0101784014,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0361115792,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      global_path_len = 0;\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        q.push(v);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<int> global_dist(N);\n    MPI_Reduce(dist.data(), global_dist.data(), N, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (global_dist[dest] == INT_MAX) {\n      return -1;\n    }\n\n    int path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    return path_len;\n  } else {\n    return -1;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0101892352,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0370157466,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    MPI_Reduce(&global_path_len, &path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Reduce(&path_len, nullptr, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  }\n\n  return path_len;\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int global_path_len = 0;\n    if (dist[dest] == INT_MAX) {\n      global_path_len = -1;\n    } else {\n      while (prev[dest] != -1) {\n        global_path_len++;\n        dest = prev[dest];\n      }\n    }\n    int recv_path_len;\n    MPI_Reduce(&global_path_len, &recv_path_len, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n    return recv_path_len;\n  }\n\n  return 0;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0102543492,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.037369227,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> dist(N, INT_MAX);\n  std::vector<int> prev(N, -1);\n  std::queue<int> q;\n\n  if (rank == 0) {\n    q.push(source);\n    dist[source] = 0;\n  }\n\n  while (!q.empty()) {\n    int u;\n    if (rank == 0) {\n      u = q.front();\n      q.pop();\n    }\n    MPI_Bcast(&u, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int v = rank; v < N; v += size) {\n      if (A[u * N + v] == 1 && dist[v] == INT_MAX) {\n        dist[v] = dist[u] + 1;\n        prev[v] = u;\n        if (rank == 0) {\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  if (rank == 0) {\n    int min_dist = INT_MAX;\n    MPI_Reduce(&dist[dest], &min_dist, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n    if (min_dist == INT_MAX) {\n      return -1;\n    }\n    int path_len = 0;\n    while (prev[dest] != -1) {\n      path_len++;\n      dest = prev[dest];\n    }\n    return path_len;\n  } else {\n    return 0;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0101790166,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0361014422,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "28_reduce_smallest_odd_number",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on all ranks.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {",
        "translation_prompt": "// Serial implementation of smallestOdd\n// /* Return the value of the smallest odd number in the vector x.\n//    Examples:\n// \n//    input: [7, 9, 5, 2, 8, 16, 4, 1]\n//    output: 1\n// \n//    input: [8, 36, 7, 2, 11]\n//    output: 7\n// */\n// int smallestOdd(std::vector<int> const& x) {\n// int smallest = x[0];\n//   for (int i = 1; i < x.size(); i++) {\n//     if (x[i] % 2 == 1 && x[i] < smallest) {\n//       smallest = x[i];\n//     }\n//   }\n//   return smallest;\n// }\n\n// MPI implementation of smallestOdd\n#include <mpi.h>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on all ranks.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the value of the smallest odd number in the vector x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {\nint smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  return smallest;\n}",
        "translation_function_name": "smallestOdd",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0727821516,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0738163762,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0751426549,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07697282595,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07728593475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0756150500375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08270115038125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08741975954375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.12070372436563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09100626547031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10134398357852,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729151534,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0744443336,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0748217117,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0770642367,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077524535025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0759268589625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0814678388875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08490243553438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11042764831563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09362582749766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09789100532109,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729704578,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0742489704,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741516128,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0773312852,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076690571625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0760604750125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0910097841875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080961023525,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08443349770469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0917184876875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09839774504336,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729505686,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07448794,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0745202052,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07688814765,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077465123625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076234261425,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08252495358125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08071458505312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10068760517187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10737317634609,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11468268268047,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729252214,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0757250896,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074272119,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07605623785,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076708292475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07546136835,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0831035953,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808435886875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11520318162031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10361186055859,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1103415345832,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729755422,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074153087,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0740300881,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0771020417,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07712060915,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0761757763625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0967862791125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08095703630312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08987064390156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09861772177344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10574019680703,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0730378158,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074035072,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0751227574,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077435178,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076794343675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0759348180875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08270654753125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08357110469062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10446422243125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.087384380875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10434694511758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0730168806,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074482545,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0745912986,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07656198175,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077494920975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076059907625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080847194775,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08220603015937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08911372827344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11324908963672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09826398140195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.072936437,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0753064554,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0753062446,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0762212606,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0767260605,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0756266373,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08169085616875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08324323939375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.12560381219062,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09831634921406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09746816534063,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0728458514,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074045181,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0753281568,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0768209732,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07766366165,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.075903931525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.098215505075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09266399807188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10373842542812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09833088196641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11627197983984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729464566,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074126574,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0747010715,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07688942155,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0764262584,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0757668975625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08806454876875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0848124233125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08737777446719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08766978776484,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10046208050977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0730185978,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741008196,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0744824894,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0770095702,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0767844101,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0765520443125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0825646903125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08351153568125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.12392938879219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08766037900547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10709039927031,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729687838,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0749376018,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0742567703,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0769460619,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779984087,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07620986255,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0825172752,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08210180274375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11044798074219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09297775336797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10535062918359,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729703302,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0740367966,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0742826999,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07708254765,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077018473925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0773219396125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08373529963125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08970310066563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09845387073594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10604307668828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11219620776094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.072964786,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0751051864,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0786271545,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0782425193,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07999084875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07656207835,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08331183093125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08385504515,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11974638712656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09698721957187,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10173964149453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729588526,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0745871868,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.074202595,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07652955705,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077543914675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0760613734125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0821372639375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11810184741875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08837122640781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10275992344375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0961876488832,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0728967182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0747676966,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0742584115,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076634766,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077293950775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07676520465,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08283080193125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07986220532188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10305420550938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09138630009141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09984047142617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n\n  int local_smallest = smallest;\n  int global_smallest;\n  MPI_Allreduce(&local_smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729673044,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0770322346,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0764697964,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07743299385,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780667313,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07734839365,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0836462205875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08718014006875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08909387501406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10281866568672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09442707766563,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.072974982,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741238932,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741479683,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0762506743,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0765190066,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0759188746,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08310012880625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09621778390625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09687272387344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10899683409766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10629985051484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int smallest = x[0];\n  for (int i = 1; i < x.size(); i++) {\n    if (x[i] % 2 == 1 && x[i] < smallest) {\n      smallest = x[i];\n    }\n  }\n  int global_smallest;\n  MPI_Allreduce(&smallest, &global_smallest, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);\n  return global_smallest;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0729466072,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741356194,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0741839544,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0762815276,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.076744358325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0761277488875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08288463255625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08726985224375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11987684846406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09516115832578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09407422586758,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "26_reduce_product_of_inverses",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use MPI to compute product in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the product on all ranks.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of productWithInverses\n// /* Return the product of the vector x with every odd indexed element inverted.\n//    i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n//    Example:\n// \n//    input: [4, 2, 10, 4, 5]\n//    output: 25\n// */\n// double productWithInverses(std::vector<double> const& x) {\n// double result = 1;\n//   for (int i = 0; i < x.size(); i++) {\n//     if (i % 2 == 0) {\n//       result *= x[i];\n//     } else {\n//       result *= 1 / x[i];\n//     }\n//   }\n//   return result;\n// }\n\n// MPI implementation of productWithInverses\n#include <mpi.h>\n\n/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Use MPI to compute product in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the product on all ranks.\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {\ndouble result = 1;\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  return result;\n}",
        "translation_function_name": "productWithInverses",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0244493684,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080883796,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062566818,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056206083,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008124536625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00483997495,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0107903054125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0109307996875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02119019523281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01683824587891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02084403907578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0236617086,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085483922,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062482988,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00563148625,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005054176675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00630204025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01045641565,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00927502050937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01340709074531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02108357449844,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02552298375391,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0251834806,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009539148,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062165581,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00577513805,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607316875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051765142,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01074186255,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00927062595312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01654543742031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01337948752344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02272858526602,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0257977326,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082593508,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062163354,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056068637,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00787605975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062888709125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01060058464375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00677632572813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01299338227656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02143613569766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01675414628984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0246056604,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0090583362,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062149879,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00542835215,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005693124325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005925605375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009463791075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00716461308438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01266557542187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01640213058281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01726415142734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0244289202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081262384,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062607126,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00551088965,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00632776085,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050759904625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01025537888125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01096051168437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01559371209687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02070609045625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03262340360938,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.024308949,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010015397,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0069104229,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0057086807,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007016018975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043771901125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00971772308125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00823773228438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0167675171,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01339395095703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02108788502148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.023667692,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0090489072,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063121506,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00506958535,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009233376475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006162918875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00994498614375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01023234457813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01490395174063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02053117571719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02729490324336,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0255346262,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081946556,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066876914,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00657699405,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063075978,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004938898675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0116633547875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007094750225,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01382691944062,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02509005510156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02184083367187,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0241480244,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0091886096,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062503551,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054399291,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006898780225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047111754125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00999531434375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00875846865625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01500521260469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01497600425,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02422867928828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0248135872,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081730968,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062167608,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00644280115,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00798186525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061015501375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0109822019625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0095531068375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01350020843125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01306072617656,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0171688266375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0255103734,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008339868,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0079083704,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00708939735,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081891275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00783698525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00959403430625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0083905563875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01301894594531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01824033233125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01656500945703,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = 0; i < x.size(); i++) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0260932422,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019628032,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0197110957,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0242927808,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0095532728,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062598481,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00538395305,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00670630655,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052293396375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01038033521875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00961315344375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01596598565625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01805136047109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0187231199293,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0246032642,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081829176,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062155497,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055102642,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004949659175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004655656175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0087459879,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0093976564875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01472196631406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01397813455078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02014125600898,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0258860674,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098336882,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062803536,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053975979,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00859876765,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055244114375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01005687451875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007554963375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01805887731406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02559428581328,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01910400806094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0241405486,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009204888,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0075906931,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00535606915,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0075357663,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009638504625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009346522875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01349273945937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01713500118906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01423443011172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02143427871289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0237567538,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081201112,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0070011167,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00622249995,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005745051675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006068279025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132799372875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00853882697812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01124855228594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01878279145312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01990147626797,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0251465234,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0091842974,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062212572,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00618729395,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005864083875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006020404175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0113217415375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0107996343625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01791150501406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01821517766563,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01851453705117,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double result = 1;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (int i = rank; i < x.size(); i += size) {\n    if (i % 2 == 0) {\n      result *= x[i];\n    } else {\n      result *= 1 / x[i];\n    }\n  }\n\n  double localResult = result;\n  MPI_Allreduce(&localResult, &result, 1, MPI_DOUBLE, MPI_PROD, MPI_COMM_WORLD);\n\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0249214826,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008099551,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062176014,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0094032731,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007416227825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0058693601875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00885381541875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01065032509688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01785821864531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02045589191719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02011590599258,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "29_reduce_sum_of_min_of_pairs",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use MPI to sum in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the sum on all ranks.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {",
        "translation_prompt": "// Serial implementation of sumOfMinimumElements\n// /* Return the sum of the minimum value at each index of vectors x and y for all indices.\n//    i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n//    Example:\n// \n//    input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n//    output: 10\n// */\n// double sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n// double sum = 0;\n//   for (int i = 0; i < x.size(); i++) {\n//     sum += std::min(x[i], y[i]);\n//   }\n//   return sum;\n// }\n\n// MPI implementation of sumOfMinimumElements\n#include <mpi.h>\n\n/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Use MPI to sum in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the sum on all ranks.\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(std::vector<double> const& x, std::vector<double> const& y) {\ndouble sum = 0;\n  for (int i = 0; i < x.size(); i++) {\n    sum += std::min(x[i], y[i]);\n  }\n  return sum;\n}",
        "translation_function_name": "sumOfMinimumElements",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0335151098,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1197372274,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599436058,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.033651048,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0182280547,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085084216125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01607768920625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01952224904688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0209573960125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03065696984219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04588380749883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0329395928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1197430872,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599211613,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03270490235,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017705912125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0087141431625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01914938201875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.024988189375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03117780489844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030615313525,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04185273383008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0344450966,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1147208802,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.057734601,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0315839085,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017300214325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0086260624125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01528909714375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01983644868437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03023747224375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01458784672266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04745682676914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n  double local_sum = 0;\n\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.035677027,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1198871288,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599779696,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03268441035,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017956474225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098216500625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018926610275,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02357734953125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03797227919688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03644843383672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03081194901289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0335546082,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1145833168,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0574205327,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0313756462,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017793466575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085315455125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01714615618125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02411183290313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02299789095469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02687972895312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04186633201094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.033990746,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1164276692,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0585048029,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03193613845,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017601802175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00854298785,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015449884025,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01743142335625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03236209003906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03017491832813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04450193254609,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0344741448,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1201237938,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599898837,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03296775305,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01790732775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081187578875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016126607025,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0189299848,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03049665501094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02098160147109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04388405293984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.033665062,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1165601822,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0583689611,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03172727065,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017482403925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082778228625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01456599964375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159411718875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02523757679687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02202576655625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04851753223789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0331231416,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1195867678,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0600492432,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0327854234,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01773092805,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008229678075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01734969964375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01482981732187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02234579682656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03114107835937,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02966722870703,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  double localSum = 0;\n  for (int i = rank; i < x.size(); i += size) {\n    localSum += std::min(x[i], y[i]);\n  }\n\n  double globalSum;\n  MPI_Allreduce(&localSum, &globalSum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return globalSum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.033403723,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1130160364,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0605379657,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0331551606,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193736265,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.024004167375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0274417484375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03319760601563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07450239953125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04165196065156,
                        "num_procs": 256
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0336815688,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1196159844,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599818234,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03290725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01770192645,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0088076615375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01473575889375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0221428752125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02864205246406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02546594885469,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03789644236094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.033010642,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1163626748,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0580591391,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318007358,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017438507375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00805148415,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01889156708125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01973530045313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02489815509687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02358197405938,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02392413403281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0346621456,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.119659529,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599971379,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03290172215,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0178137149,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008400789825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0192441129125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01908790746875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0213614251875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03046449695703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03409350720781,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0339986164,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1198109578,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599986103,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03274430305,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01797752275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00807092825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0261853716,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01844464148125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02119586893437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08598589721562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04398872925703,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.033406784,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1161148626,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0583431594,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03186958755,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017554818625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00791650275,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01590326656875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01390650388438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02173176647812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0302263363625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02829631179102,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int localSize = x.size() / size;\n  int start = rank * localSize;\n  int end = (rank == size - 1) ? x.size() : start + localSize;\n\n  double localSum = 0;\n  for (int i = start; i < end; i++) {\n    localSum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&localSum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.035575604,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1197102496,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0599838149,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.032896355,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018665116625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008343142075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0227289559375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190048524875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03269779778125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03515895395234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03743048181211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0350975132,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1163279002,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0582707962,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323510749,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0170255476,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085010187375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019825978875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02056571355312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01524016589531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02633269824531,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04512832291484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0356790704,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11497933,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0574232206,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0313822613,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017295732125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007984249375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0165398743625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01709193883125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02176721504687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02356611113047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03948190556758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double sum = 0;\n  double local_sum = 0;\n  for (int i = 0; i < x.size(); i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  MPI_Allreduce(&local_sum, &sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0363708728,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1115322494,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.1113521348,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  int start = rank * local_size;\n  int end = (rank == size - 1) ? x.size() : start + local_size;\n\n  double local_sum = 0;\n  for (int i = start; i < end; i++) {\n    local_sum += std::min(x[i], y[i]);\n  }\n\n  double global_sum;\n  MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n  return global_sum;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0338385072,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1205916138,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0606519487,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0328964591,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0180676321,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00970849335,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015782376875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160498397,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01562434159219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06199888617578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0329820045082,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the average of the vector x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the average on all ranks.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of average\n// /* Return the average of the vector x.\n//    Examples:\n// \t\t\n// \t input: [1, 8, 4, 5, 1]\n//    output: 3.8\n// \n//    input: [2, 2, 2, 3]\n//    output: 2.25\n// */\n// double average(std::vector<double> const& x) {\n// double sum = 0;\n// \tfor (double i : x) {\n// \t\tsum += i;\n// \t}\n// \treturn sum / x.size();\n// }\n\n// MPI implementation of average\n#include <mpi.h>\n\n/* Return the average of the vector x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the average on all ranks.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {\ndouble sum = 0;\n\tfor (double i : x) {\n\t\tsum += i;\n\t}\n\treturn sum / x.size();\n}",
        "translation_function_name": "average",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0056758192,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160841872,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160104017,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01919817875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018855659375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017267423825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0308155184125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03248494549375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0607272800125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06981004251719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08280283687109,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061777268,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159547656,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016048951,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01936383895,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.021092245675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0212514900125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02972927879375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04184940938125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05476512032187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07024816652188,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08803481003125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005656433,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016039443,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0175610145,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01924637885,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019884996425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174853752625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0360638779625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0411088776875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05033732968125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07414499714531,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0746764456207,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005164472,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160622326,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174108454,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193818629,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02108531685,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02016386455,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03756006796875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03798025569688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04522977466875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07021767977656,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09434792065117,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0057794338,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159722392,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190059471,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02001606855,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0472302462,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0184372569375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04724053896875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0352626166875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05107071462656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07367983544375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08873691745625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0059356752,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160248482,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174167109,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0192883708,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020676825175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019166092,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03131366693125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03478671953125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.050540376,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05444583044063,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07876381902422,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double localSum = 0;\n    for (double i : x) {\n        localSum += i;\n    }\n\n    double globalSum;\n    MPI_Allreduce(&localSum, &globalSum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return globalSum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0054977402,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159912192,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160079201,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01921010515,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02042054275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0212485054875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0344861188125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05044725466875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04752905364062,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06942315635781,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08430314474805,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0055961568,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160643806,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159622124,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193880198,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019601213725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01921979335,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03096159498125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03824959340937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04670715150469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06457629219453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08734051621172,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0056560776,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159944112,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0194336009,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01983817865,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02035517525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01893402665,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.029580844075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03551021941875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05095026744688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06347449752969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10228459307227,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0055472472,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159382132,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160073573,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0198118093,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018908008375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0176818447,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0333985613125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04019055607188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05408877639375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08112470457031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08788443815391,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0052477624,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0164404374,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160254007,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02037098195,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018952737525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0201012309625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.039551103675,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03842825000937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04737385217656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07041671754297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08394957001328,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0053012048,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159528826,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160448542,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01915258405,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020331869725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0198408934875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02979099151875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03561309785625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0638109871625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06546352450859,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08086161448828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058398088,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0162238944,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160331512,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01944683835,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020074861675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01937294015,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030078395625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03447301239375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05365336212656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07501138252578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09100970473477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0054405426,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015937117,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160057965,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01904622075,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.021361040325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018782248075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03190289235,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04038034310313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04920688931563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05997742104531,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07498805125937,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005588992,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015991019,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159866897,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01935614795,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0194512281,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0185697348,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.032693965325,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04247054057188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04816275540469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06237596497422,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07288641416758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0057763012,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0166767936,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0161638257,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02051183455,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0190417136,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0183872761625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03454436656875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03293956057187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.049270619275,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06939378838594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09741114277148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0055941052,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159952892,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159675134,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02022813105,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020907186425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0187320547625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318055770875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04153783380312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04836413985625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06604807194766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07840067936523,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005852527,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0174415646,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160134791,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02050473825,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020094680175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193620634625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0310509821,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.037739594225,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05526676209687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06688844098047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.08448131766055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0056571056,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0183252148,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0194681348,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193823568,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0204253952,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0205140618125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.031551122675,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03355025207812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04176935576719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05698629904297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.09009009582539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    double local_sum = 0;\n    for (double i : x) {\n        local_sum += i;\n    }\n\n    double global_sum;\n    MPI_Allreduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    return global_sum / (x.size() * size);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0055353326,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159935056,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160875954,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01939531065,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020438686675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0192058893875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0308993150375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04131156688125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05053928858281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.06535552600547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.07650912042109,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "25_reduce_xor",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the logical XOR reduction of the vector of bools x.\n   Use MPI to reduce in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on all ranks.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {",
        "translation_prompt": "// Serial implementation of reduceLogicalXOR\n// /* Return the logical XOR reduction of the vector of bools x.\n//    Example:\n// \n//    input: [false, false, false, true]\n//    output: true\n// */\n// bool reduceLogicalXOR(std::vector<bool> const& x) {\n// bool result = false;\n//   for (auto const& i : x) {\n//     result ^= i;\n//   }\n//   return result;\n// }\n\n// MPI implementation of reduceLogicalXOR\n#include <mpi.h>\n\n/* Return the logical XOR reduction of the vector of bools x.\n   Use MPI to reduce in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on all ranks.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {\nbool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n  return result;\n}",
        "translation_function_name": "reduceLogicalXOR",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121395078,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0128645668,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0132279187,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121675912,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012687556,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129302751,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121485332,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0138146356,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129434106,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120514868,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0127258878,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129063828,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120834164,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126159252,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127182294,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121474532,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0128190888,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127922644,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.012084,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012742932,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127516512,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120994624,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0129055136,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129109666,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120457798,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0128194318,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0134193156,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.012061373,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0134597908,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0128717999,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121524286,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0127975266,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0133749479,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.012162852,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012591816,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127955282,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120863104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131787248,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0131419173,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0122467514,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132460778,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129326107,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121133608,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0125959874,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129218788,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  bool result = false;\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n  MPI_Allreduce(&localResult, &result, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n  return result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121184902,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126789056,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127747768,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0122526684,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132616686,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129202054,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = false;\n  for (auto const& i : x) {\n    result ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&result, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120371338,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0127537606,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129800905,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Allreduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0121667754,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0128475686,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0129112511,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool localResult = false;\n  for (auto const& i : x) {\n    localResult ^= i;\n  }\n\n  bool globalResult;\n  MPI_Reduce(&localResult, &globalResult, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n  return globalResult;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0120827214,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126638994,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0127382417,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "32_scan_sum_of_prefix_sum_array",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of sumOfPrefixSum\n// /* Compute the prefix sum array of the vector x and return its sum.\n//    Example:\n// \n//    input: [-7, 2, 1, 9, 4, 8]\n//    output: 15\n// */\n// double sumOfPrefixSum(std::vector<double> const& x) {\n// double sum = 0;\n//     std::vector<double> prefix_sum(x.size());\n// \n//     for (size_t i = 0; i < x.size(); ++i) {\n//         if (i == 0) {\n//             prefix_sum[i] = x[i];\n//         } else {\n//             prefix_sum[i] = prefix_sum[i - 1] + x[i];\n//         }\n//         sum += prefix_sum[i];\n//     }\n// \n//     return sum;\n// }\n\n// MPI implementation of sumOfPrefixSum\n#include <mpi.h>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {\ndouble sum = 0;\n    std::vector<double> prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            prefix_sum[i] = x[i];\n        } else {\n            prefix_sum[i] = prefix_sum[i - 1] + x[i];\n        }\n        sum += prefix_sum[i];\n    }\n\n    return sum;\n}",
        "translation_function_name": "sumOfPrefixSum",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0107881972,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.039703244,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0391531864,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;  // Return 0 on non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0106954686,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0293192926,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0512811299,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0111403568,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0328678466,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0519725028,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;  // Return 0 for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0108970812,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0293330966,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0487233521,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;  // Return 0 for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.010744443,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0286973882,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0492246527,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0108609588,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0407766492,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0415258583,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0; // Return 0 for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0106958264,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0287291974,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0382815174,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;  // Return 0 for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0107128864,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0289888874,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0483724537,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0102305748,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.038770615,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0491110131,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;  // Dummy return for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0115750202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0393184742,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0531725277,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0107216732,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0295480534,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0472061101,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0; // Return 0 for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0106072,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030558656,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0545743153,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0.0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0115258076,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0304267162,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0504657301,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.011045113,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0294765036,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0513508181,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0107411198,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0301929592,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0544653443,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0107330906,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0388675168,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.040029478,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0108100192,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0290471128,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0502323742,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0108822324,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0290135056,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0484983084,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.010796197,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394057618,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0395274715,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    double sum = 0;\n    std::vector<double> prefix_sum(x.size());\n    std::vector<double> local_prefix_sum(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i == 0) {\n            local_prefix_sum[i] = x[i];\n        } else {\n            local_prefix_sum[i] = local_prefix_sum[i - 1] + x[i];\n        }\n    }\n\n    MPI_Allreduce(local_prefix_sum.data(), prefix_sum.data(), x.size(), MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += prefix_sum[i];\n    }\n\n    double total_sum = 0;\n    MPI_Reduce(&sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return total_sum;\n    } else {\n        return 0;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0111949118,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0312792318,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0417072728,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {",
        "translation_prompt": "// Serial implementation of partialMinimums\n// /* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n//    Examples:\n// \n//    input: [8, 6, -1, 7, 3, 4, 4]\n//    output: [8, 6, -1, -1, -1, -1, -1]\n// \n//    input: [5, 4, 6, 4, 3, 6, 1, 1]\n//    output: [5, 4, 4, 4, 3, 3, 1, 1]\n// */\n// void partialMinimums(std::vector<float> &x) {\n// float min = x[0];\n//     for (int i = 0; i < x.size(); i++) {\n//         if (x[i] < min) {\n//             min = x[i];\n//         }\n//         x[i] = min;\n//     }\n// }\n\n// MPI implementation of partialMinimums\n#include <mpi.h>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {\nfloat min = x[0];\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n}",
        "translation_function_name": "partialMinimums",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007666742,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001405031,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0], x.size(), MPI_FLOAT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                if (recvbuf[j] < x[j]) {\n                    x[j] = recvbuf[j];\n                }\n            }\n        }\n    } else {\n        MPI_Send(&x[0], x.size(), MPI_FLOAT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0004915954,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001046726,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0014554773,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0006485902,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013637318,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007730258,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014342638,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvBuf(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvBuf[0], x.size(), MPI_FLOAT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                if (recvBuf[j] < x[j]) {\n                    x[j] = recvBuf[j];\n                }\n            }\n        }\n    } else {\n        MPI_Send(&x[0], x.size(), MPI_FLOAT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0005192118,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011562158,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0018465808,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.000739483,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013529574,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0006503438,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013057908,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.000649598,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012848674,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        for (int r = 1; r < size; r++) {\n            std::vector<float> recv_data(x.size());\n            MPI_Recv(&recv_data[0], x.size(), MPI_FLOAT, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int i = 0; i < x.size(); i++) {\n                if (recv_data[i] < x[i]) {\n                    x[i] = recv_data[i];\n                }\n            }\n        }\n    } else {\n        MPI_Send(&x[0], x.size(), MPI_FLOAT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0004871346,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000734492,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0023096954,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0008160406,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013927922,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007072304,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014203518,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0006496842,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014246298,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007102842,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014982182,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0006497114,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001343154,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0], x.size(), MPI_FLOAT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                if (recvbuf[j] < x[j]) {\n                    x[j] = recvbuf[j];\n                }\n            }\n        }\n    } else {\n        MPI_Send(&x[0], x.size(), MPI_FLOAT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0004333766,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010705676,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0016283929,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0], x.size(), MPI_FLOAT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                if (recvbuf[j] < x[j]) {\n                    x[j] = recvbuf[j];\n                }\n            }\n        }\n    } else {\n        MPI_Send(&x[0], x.size(), MPI_FLOAT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.00043104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009639112,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015344891,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.00065029,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013233948,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007159994,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013986362,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0007539628,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014202328,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    float min = x[0];\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] < min) {\n            min = x[i];\n        }\n        x[i] = min;\n    }\n\n    if (rank == 0) {\n        std::vector<float> recvbuf(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, recvbuf.data(), x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_FLOAT, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0006484894,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012882686,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "30_scan_prefix_sum",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the prefix sum of the vector x into output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Store the result in output on rank 0.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {",
        "translation_prompt": "// Serial implementation of prefixSum\n// /* Compute the prefix sum of the vector x into output.\n//    Example:\n//    \n//    input: [1, 7, 4, 6, 6, 2]\n//    output: [1, 8, 12, 18, 24, 26]\n// */\n// void prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n// output.resize(x.size());\n//   output[0] = x[0];\n//   for (int i = 1; i < x.size(); ++i) {\n//     output[i] = output[i-1] + x[i];\n//   }\n// }\n\n// MPI implementation of prefixSum\n#include <mpi.h>\n\n/* Compute the prefix sum of the vector x into output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Store the result in output on rank 0.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the prefix sum of the vector x into output.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(std::vector<double> const& x, std::vector<double> &output) {\noutput.resize(x.size());\n  output[0] = x[0];\n  for (int i = 1; i < x.size(); ++i) {\n    output[i] = output[i-1] + x[i];\n  }\n}",
        "translation_function_name": "prefixSum",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n    std::vector<int> recv_counts(size, local_size);\n    std::vector<int> displs(size, 0);\n    for (int i = 1; i < size; ++i) {\n      displs[i] = displs[i-1] + recv_counts[i-1];\n    }\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, output.data(), recv_counts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0082920026,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0214475268,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0133725622,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(&local_output[0], local_size, MPI_DOUBLE, &output[0], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081482804,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0258920374,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0130628384,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n    std::vector<int> recv_counts(size, local_size);\n    std::vector<int> displs(size, 0);\n    for (int i = 1; i < size; ++i) {\n      displs[i] = displs[i-1] + local_size;\n    }\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, output.data(), recv_counts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081331638,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0210364166,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0134890085,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0082295172,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0210292768,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0143320378,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  if (rank == 0) {\n    for (int i = 1; i < size; ++i) {\n      output[i * local_size] += output[(i - 1) * local_size + local_size - 1];\n      for (int j = 1; j < local_size; ++j) {\n        output[i * local_size + j] += output[i * local_size + j - 1];\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.008170911,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019225984,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0220200899,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n    std::vector<int> recv_counts(size, local_size);\n    std::vector<int> displs(size, 0);\n    for (int i = 1; i < size; ++i) {\n      displs[i] = displs[i-1] + recv_counts[i-1];\n    }\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, output.data(), recv_counts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Gatherv(local_output.data(), local_size, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.008153769,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193363636,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0121304446,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  if (rank == 0) {\n    for (int i = 1; i < size; ++i) {\n      output[i * local_size] += output[(i - 1) * local_size + local_size - 1];\n      for (int j = 1; j < local_size; ++j) {\n        output[i * local_size + j] += output[i * local_size + j - 1];\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081201816,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0198381166,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0245466599,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0087466232,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0252180104,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0138821378,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081190734,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0214583654,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0131025049,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081030534,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0197355656,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0139057434,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_output(local_n);\n\n  double local_sum = x[0];\n  local_output[0] = x[0];\n  for (int i = 1; i < local_n; ++i) {\n    local_sum += x[i + rank * local_n];\n    local_output[i] = local_sum;\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_n, MPI_DOUBLE, output.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank != 0) {\n    for (int i = 0; i < local_n; ++i) {\n      output[i + rank * local_n] += output[i + (rank - 1) * local_n];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081685008,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0237604132,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.014028472,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0082669494,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0210988856,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0130492588,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081337216,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.019677835,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0138969232,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  if (rank == 0) {\n    for (int i = 1; i < size; ++i) {\n      output[i * local_size] += output[(i - 1) * local_size + local_size - 1];\n      for (int j = 1; j < local_size; ++j) {\n        output[i * local_size + j] += output[i * local_size + j - 1];\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081175304,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0193772264,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0215877138,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int size, rank;\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n\n  MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    output.resize(x.size());\n    output[0] = local_output[0];\n  }\n\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] += local_output[i-1];\n  }\n\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.008112988,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0243127852,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0177722963,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  std::vector<double> local_output(x.size());\n  local_output[0] = x[0];\n  for (int i = 1; i < x.size(); ++i) {\n    local_output[i] = local_output[i-1] + x[i];\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(&output[0], x.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < x.size(); ++j) {\n        output[j] += local_output[j];\n      }\n    }\n  } else {\n    MPI_Send(&local_output[0], x.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0082728446,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0150815096,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(&local_output[0], local_size, MPI_DOUBLE, &output[0], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081458682,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0206352506,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0136591487,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_x(local_size);\n  std::vector<double> local_output(local_size);\n\n  MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  local_output[0] = local_x[0];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + local_x[i];\n  }\n\n  std::vector<double> prefix_sums(x.size());\n  MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, prefix_sums.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    output = prefix_sums;\n  }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.008149014,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.046809486,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0366653404,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_size = x.size() / size;\n  std::vector<double> local_output(local_size);\n  local_output[0] = x[rank * local_size];\n  for (int i = 1; i < local_size; ++i) {\n    local_output[i] = local_output[i-1] + x[rank * local_size + i];\n  }\n\n  if (rank == 0) {\n    output.resize(x.size());\n  }\n\n  MPI_Gather(&local_output[0], local_size, MPI_DOUBLE, &output[0], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0081852034,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0197544992,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0131910787,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  std::vector<double> local_output(local_n);\n\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  local_output[0] = local_x[0];\n  for (int i = 1; i < local_n; ++i) {\n    local_output[i] = local_output[i-1] + local_x[i];\n  }\n\n  std::vector<double> prefix_sums(size);\n  MPI_Gather(&local_output.back(), 1, MPI_DOUBLE, prefix_sums.data(), 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    output.resize(x.size());\n    output[0] = local_output[0];\n    for (int i = 1; i < size; ++i) {\n      output[i * local_n] = prefix_sums[i - 1];\n    }\n    for (int i = 1; i < local_n; ++i) {\n      output[i] = local_output[i];\n    }\n    for (int i = 1; i < size; ++i) {\n      for (int j = 1; j < local_n; ++j) {\n        output[i * local_n + j] = prefix_sums[i - 1] + local_output[j];\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0082061212,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.032903722,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0232205459,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "56_transform_negate_odds",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of negateOddsAndHalveEvens\n// /* In the vector x negate the odd values and divide the even values by 2.\n//    Example:\n// \n//    input: [16, 11, 12, 14, 1, 0, 5]\n//    output: [8, -11, 6, 7, -1, 0, -5]\n// */\n// void negateOddsAndHalveEvens(std::vector<int> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         if (x[i] % 2 == 0) {\n//             x[i] /= 2;\n//         } else {\n//             x[i] = -x[i];\n//         }\n//     }\n// }\n\n// MPI implementation of negateOddsAndHalveEvens\n#include <mpi.h>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n}",
        "translation_function_name": "negateOddsAndHalveEvens",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009813422,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047081398,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032472528,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00627451485,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007462504225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039670081875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00450707379375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00218313150625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00148721613125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00129488282578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00206720300312,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009791362,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0208546748,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01334502,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009797492,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032437078,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033266242,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00512477105,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007071379575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031320598875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00434366201875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002763279775,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00173592789219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00169441077969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00187968216172,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009761884,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004049534,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050104425,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00723576725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006800014475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032505399875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00457252206875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00239593135625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00185077197344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00237771294922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00157168032344,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009780078,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020862497,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0146825616,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009925412,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0042314602,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037049379,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00582997205,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00631865155,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003768639025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00527008326875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00242019633437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00143435484687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00185924670391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00157781358281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_x.size(); i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009904554,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037268292,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0044069588,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054518653,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006281771225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031615340375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00456571518125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00224607025938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00142485305937,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00167749291406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00184821443437,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(x.data(), x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(temp.data(), x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009934752,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0211071446,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0144708313,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000981849,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032841958,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047133584,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00664552015,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004979205875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035289251625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00455284975,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002105906075,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152613260781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00217063746797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00174050652266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009770202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033530754,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043215626,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00662900675,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007158036125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036307609,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00505026220625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00232256837812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00163641401563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00176362922344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00167864053203,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00097721,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003466785,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045199153,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00832821125,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0059285379,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039455368,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004427089275,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00291741842812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00147044117344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033389421875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015961203125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009864256,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0208440024,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0131865322,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000980282,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003276315,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032981327,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051886176,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00591291555,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004161964775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00462091088125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00221980868125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00177816149219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00246176618828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00169274453633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009811074,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0212175424,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0131124632,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0011242928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0213092164,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.014238031,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = rank; i < x.size(); i += size) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[0], x.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&temp[0], x.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0009763404,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.020823077,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0130422497,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000983011,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0044718276,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054434255,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0068804319,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007512035425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00471954545,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00437288935,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002110389225,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00143553927344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00195349225703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00172380190859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? x.size() : start + local_size;\n\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<int> recv_buffer(x.size());\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recv_buffer[start], local_size, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            start += local_size;\n        }\n        x = recv_buffer;\n    } else {\n        MPI_Send(&x[start], local_size, MPI_INT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0011757934,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0025834808,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] % 2 == 0) {\n            local_x[i] /= 2;\n        } else {\n            local_x[i] = -local_x[i];\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009804006,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032879546,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037800131,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061268266,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005135653575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037539025625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00479242780625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002073968075,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00143607699375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158568693125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00184813524883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    int start = rank * local_size;\n    int end = start + local_size;\n\n    if (rank == size - 1) {\n        end = x.size();\n    }\n\n    for (int i = start; i < end; i++) {\n        if (x[i] % 2 == 0) {\n            x[i] /= 2;\n        } else {\n            x[i] = -x[i];\n        }\n    }\n\n    if (rank != 0) {\n        MPI_Send(&x[start], local_size, MPI_INT, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<int> temp(x.size());\n        for (int i = 0; i < local_size; i++) {\n            temp[i] = x[i];\n        }\n        for (int j = 1; j < size; j++) {\n            MPI_Recv(&temp[j * local_size], local_size, MPI_INT, j, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        x = temp;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0009828428,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0040616866,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0044448192,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00409559955,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003358698425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004497874675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.233479939675,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00462160470938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000988504525,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158011409141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00213421689336,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "59_transform_map_function",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored in mask on rank 0.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {",
        "translation_prompt": "// Serial implementation of mapPowersOfTwo\n// bool isPowerOfTwo(int x) {\n// \treturn (x > 0) && !(x & (x - 1));\n// }\n// \n// /* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n//    Example:\n// \n//    input: [8, 0, 9, 7, 15, 64, 3]\n//    output: [true, false, false, false, false, true, false]\n// */\n// void mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n// for (int i = 0; i < x.size(); i++) {\n// \t\tmask[i] = isPowerOfTwo(x[i]);\n// \t}\n// }\n\n// MPI implementation of mapPowersOfTwo\n#include <mpi.h>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored in mask on rank 0.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\nfor (int i = 0; i < x.size(); i++) {\n\t\tmask[i] = isPowerOfTwo(x[i]);\n\t}\n}",
        "translation_function_name": "mapPowersOfTwo",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint localSize = x.size() / size;\nstd::vector<bool> localMask(localSize);\n\nfor (int i = 0; i < localSize; i++) {\n    localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n}\n\nif (rank == 0) {\n    mask.resize(x.size());\n}\n\nMPI_Gather(localMask.data(), localSize, MPI_C_BOOL, mask.data(), localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint localSize = x.size() / size;\nstd::vector<bool> localMask(localSize);\n\nfor (int i = 0; i < localSize; i++) {\n    localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n}\n\nif (rank == 0) {\n    mask.resize(x.size());\n}\n\nMPI_Gather(localMask.data(), localSize, MPI_C_BOOL, mask.data(), localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(&localMask[0], localSize, MPI_C_BOOL, &mask[0], localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(localMask.data(), localSize, MPI_C_BOOL, mask.data(), localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint localSize = x.size() / size;\nstd::vector<bool> localMask(localSize);\n\nfor (int i = 0; i < localSize; i++) {\n    localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n}\n\nif (rank == 0) {\n    mask.resize(x.size());\n}\n\nMPI_Gather(localMask.data(), localSize, MPI_C_BOOL, mask.data(), localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<bool> localMask(localSize);\n\n    for (int i = 0; i < localSize; i++) {\n        localMask[i] = isPowerOfTwo(x[rank * localSize + i]);\n    }\n\n    if (rank == 0) {\n        mask.resize(x.size());\n    }\n\n    MPI_Gather(localMask.data(), localSize, MPI_C_BOOL, mask.data(), localSize, MPI_C_BOOL, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            }
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "57_transform_inverse_offset",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {",
        "translation_prompt": "// Serial implementation of oneMinusInverse\n// /* Replace every element of the vector x with 1-1/x.\n//    Example:\n// \n//    input: [2, 4, 1, 12, -2]\n//    output: [0.5, 0.75, 0, 0.91666666, 1.5]\n// */\n// void oneMinusInverse(std::vector<double> &x) {\n// for (auto &e : x) {\n//     e = 1.0 - 1.0 / e;\n//   }\n// }\n\n// MPI implementation of oneMinusInverse\n#include <mpi.h>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Replace every element of the vector x with 1-1/x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {\nfor (auto &e : x) {\n    e = 1.0 - 1.0 / e;\n  }\n}",
        "translation_function_name": "oneMinusInverse",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001475252,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008865622,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056040686,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00787443,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007813950925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062188586875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00726190054375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00598912790625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00692846398281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00800884084375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01399952311992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014628308,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077774234,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052932964,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0071266403,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00828780725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066443675875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00870122019375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00688376311562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00662288424375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00814165341562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01368612952266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001467017,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082698146,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005886556,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077169157,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01025593235,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006724913825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00748961005,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00694465922813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00657938643906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00781618323203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01377151312266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014633136,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082071992,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080393396,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00700379805,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007396817675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00744012995,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007078085375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00726069962188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00678349541719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00897867833906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01353402775,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014643014,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0078008414,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056401113,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006828789,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0075488559,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006232778975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00778492075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00593601115625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00640772542969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00870379357422,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01365131716758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001465093,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077145694,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055717677,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006815159,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00922423915,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066911735,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006860851225,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00652568844687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00581982778594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00870000876875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01398408189453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014627246,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0073260512,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0070494502,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00744672675,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00840509585,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0271973889125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0075809577375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00749829265312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00746455198906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00761160707812,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01357087919492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001464941,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008451402,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0069522607,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0069852625,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008373067825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063547044875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081299497125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00646589247188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00578898275,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00797132143047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01366844645273,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014642016,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0078262856,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053676233,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00743454075,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008528831775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008151590475,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00730291468125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00637346342188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00707762439687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00867659016875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01380467720977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014660272,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076644912,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054309311,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00737680645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00796517535,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0067545574875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00771615693125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00624267819375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00714160032969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00893958211953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01381630083711,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014693114,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077651784,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054031211,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080719557,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008796983525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061654656625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085041930875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00629011853125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00687731648125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00875348238594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01368567190938,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014771378,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0081766214,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0058616579,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00725252595,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00741560765,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055118447,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00831868318125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00704644005625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00781640179375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00848207475312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01432535378477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001463893,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077360854,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053455494,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00717820205,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00791078485,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0068900695125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0072569147375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00626045923438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00750617140469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00868329230547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01402796451563,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> gathered_x(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, gathered_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = gathered_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014650672,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076129564,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0067049214,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0078490074,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00948722465,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0070441845,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00752206934375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00722521588437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00847956643281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00796532899297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01431830225898,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014626228,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007730994,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053268075,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00765439235,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00934756945,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0116465405375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00757177071875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00601307663437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00671862100625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00849768180312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01371383146211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014656642,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077481406,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0060886391,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0068718109,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00890350675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063464422875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0071218146,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00605432884062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00601815515625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00872010257031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01359852710547,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014627388,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077689778,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053385067,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0068178125,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007642436375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006090324925,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00768129176875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006036848475,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00694767580469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009639873,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01425333489961,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014664218,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0079067362,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055518334,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00751953575,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007521515675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00684199735,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00812354038125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00735714851875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00750511645,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00805789628594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0142156287918,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014623422,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038642456,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035412549,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0058714343,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005290598875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003550067825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004417206075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037419427875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00132015447187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00188908451719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189608794648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_DOUBLE, local_x.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (auto &e : local_x) {\n    e = 1.0 - 1.0 / e;\n  }\n\n  std::vector<double> result(x.size());\n  MPI_Gather(local_x.data(), local_n, MPI_DOUBLE, result.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = result;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0014645122,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076240248,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054916622,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00698578335,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009473565575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065532756875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00735950443125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00742616333125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00713882014063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00844389837813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01441243182266,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {",
        "translation_prompt": "// Serial implementation of relu\n// /* Compute the ReLU function on every element of x. Elements less than zero become zero,\n//    while elements greater than zero stay the same.\n//    Example:\n// \n//    input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n//    output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n// */\n// void relu(std::vector<double> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         if (x[i] < 0) {\n//             x[i] = 0;\n//         }\n//     }\n// }\n\n// MPI implementation of relu\n#include <mpi.h>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        if (x[i] < 0) {\n            x[i] = 0;\n        }\n    }\n}",
        "translation_function_name": "relu",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0012771918,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270932626,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0162818739,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133594046,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01265888055,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0075114703375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076520528375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00462622250938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00366127256094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00282980165312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043488147375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0010740322,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0269693238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0154254589,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0122196525,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011485343725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076273048625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065276109875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046132471375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00341732881406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00331470186172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00472697196484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<double> local_x(local_n);\n    MPI_Scatter(&x[0], local_n, MPI_DOUBLE, &local_x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_n; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(&local_x[0], local_n, MPI_DOUBLE, &x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011203672,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272882732,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0164723863,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133382395,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01182157465,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00768893575,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00715795426875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00473408815313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00365051161719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00319189266094,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00517098368828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013243966,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270356584,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0157104236,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0139448691,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0113928442,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008208837475,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066026942875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00475900365,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00332212914688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00365474522813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055527318082,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0010528968,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0275656342,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159954192,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01334301415,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.013364127075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00878790165,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076239828375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00486970734062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00361787924687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00354991055547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00382237019531,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011029264,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272388984,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0156843634,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01301606425,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01182165395,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080841817125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00722323060625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054214237,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00349666826562,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00371805907109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00498725637109,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0010267378,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0269556282,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0159928035,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01267512025,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0125705851,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008773136025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0085544328125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00502335638438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00359261698281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00371268320234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043731405043,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<double> local_x(local_n);\n    MPI_Scatter(&x[0], local_n, MPI_DOUBLE, &local_x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_n; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(&local_x[0], local_n, MPI_DOUBLE, &x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013380944,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0277217918,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0157424677,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0139167311,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0142488235,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076490655125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01267727711875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046241100875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00359009588125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00358641097109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00470905273047,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001079777,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0273095392,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0162300915,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01271447135,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01296814385,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009055948375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0074560899125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00471553276563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00361440156094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00287364619219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00419845347305,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001179711,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0271314766,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0162382877,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01333691135,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01195365125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0074450348875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080844989,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00502737331563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00358145293437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00317493078672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00423391049922,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<double> local_x(local_n);\n    MPI_Scatter(&x[0], local_n, MPI_DOUBLE, &local_x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_n; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(&local_x[0], local_n, MPI_DOUBLE, &x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011999948,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027072552,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0156770345,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0124489834,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014526965075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007636131825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00681875155625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00578411015,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00403320994687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00300243165,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00556983686797,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0010947372,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0273188326,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0161259134,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0148223968,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011142011675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00728523255,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00769253629375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00480578875625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00452913484219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00352226069922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00482840900195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<double> local_x(local_n);\n    MPI_Scatter(&x[0], local_n, MPI_DOUBLE, &local_x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_n; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(&local_x[0], local_n, MPI_DOUBLE, &x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011846342,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0274667466,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0153726503,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0126090043,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011198823875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007418941275,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00742689715,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00457521258125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00338697158438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00390870426328,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00425469165312,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00110059,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02738003,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160144037,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01246821815,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.013103728275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077995223,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065776962875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004829753325,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00357978533281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00420759688047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00413736365195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nint local_size = x.size() / size;\nstd::vector<double> local_x(local_size);\nMPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\nfor (int i = 0; i < local_size; i++) {\n    if (local_x[i] < 0) {\n        local_x[i] = 0;\n    }\n}\n\nMPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011231306,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270684102,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0158017188,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01282883485,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011665142775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082214823625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00772520195,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00535405885938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00383522025312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00317606870781,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00329051721914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013012772,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270088542,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0165265987,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01351603595,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.013459637925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076260548125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00727136980625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047391800125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032089304375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00338932839531,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00481701294414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<double> local_x(local_n);\n    MPI_Scatter(&x[0], local_n, MPI_DOUBLE, &local_x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_n; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(&local_x[0], local_n, MPI_DOUBLE, &x[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011378904,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027572872,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0158213497,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0123596085,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0122218047,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008340996175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0180354872125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00512185056875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00391022699219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00296041371641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00475159421289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0012519346,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270402732,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160870784,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01353862,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01341879585,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008316992375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00688724296875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049827841375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00322772957656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00284127131641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00466571476719,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011586712,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0271128898,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0163004413,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0137363067,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014409222175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0083170342625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0079199105,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00481244779375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00343071863437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00399539912891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00479676302344,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<double> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_DOUBLE, local_x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        if (local_x[i] < 0) {\n            local_x[i] = 0;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_DOUBLE, x.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0011749784,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270119188,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0164142504,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0156008635,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014344703025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008587801225,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0072481804,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00460565881562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00383179906875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00372122999062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00495657491875,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "58_transform_squaring",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Replace every element of x with the square of its value.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of squareEach\n// /* Replace every element of x with the square of its value.\n//    Example:\n// \n//    input: [5, 1, 2, -4, 8]\n//    output: [25, 1, 4, 16, 64]\n// */\n// void squareEach(std::vector<int> &x) {\n// for (int i = 0; i < x.size(); i++) {\n//         x[i] = x[i] * x[i];\n//     }\n// }\n\n// MPI implementation of squareEach\n#include <mpi.h>\n\n/* Replace every element of x with the square of its value.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Replace every element of x with the square of its value.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {\nfor (int i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}",
        "translation_function_name": "squareEach",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006626072,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00285004,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032279862,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00559516395,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053358411,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006521120375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00444138295,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00207634063125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150874926875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00227888547344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00170810299023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localX.size(); i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006578766,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033153182,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031198283,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00521223815,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00579944885,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036518489,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00448332628125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00219099842188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00135176192813,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166886283047,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00184048367266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006583454,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003303069,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003173093,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055764699,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00503515355,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035128307875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00417487863125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00229448629375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00179688530937,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00156298037344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00275268132734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006587118,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028893478,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030417764,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00554497155,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004927851075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035866398,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00433610564375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00279344941563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015713714875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00198900238281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026478743543,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006910688,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003005456,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031014677,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055571588,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00489084535,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00300924135,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004014026575,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00194331162187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150709212813,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00368275504063,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00213608077578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = x.size() / size;\n    std::vector<int> local_x(local_size);\n    MPI_Scatter(x.data(), local_size, MPI_INT, local_x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < local_size; i++) {\n        local_x[i] = local_x[i] * local_x[i];\n    }\n\n    MPI_Gather(local_x.data(), local_size, MPI_INT, x.data(), local_size, MPI_INT, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006681758,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029339614,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035370806,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00591627785,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052740943,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037854797125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00436049390625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022898717375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00221170120156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00173987865859,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196892582813,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000660349,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002920911,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0040236574,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0055795951,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053476296,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003807124625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00416894955,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00266523832188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00159508689219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001446647575,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189100641758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000664491,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029656692,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031291198,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00542024875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053506876,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036458175875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00380786726875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00245627310625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131816968906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189527425781,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00603747921563,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006608154,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029052296,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031327875,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00511421875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005374473175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00308196055,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047358456125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192048576562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00139085715,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00125387766562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00172962850625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006690574,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029716922,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0041423136,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0057022902,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00537585625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003379689725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00482967948125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00204383945625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00141611838125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00180191823203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152747921367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localX.size(); i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000661938,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030383798,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033526237,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00511787775,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0048365184,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033607030125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0040119798875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00231544000938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131626811719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00241472631484,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00170585226406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006609182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030589642,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032203402,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00522144235,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005056811925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003420385475,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00534884028125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00229346660625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00137592560938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00172822395313,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00165643317578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006598162,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029688854,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0040668888,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051627593,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00483635135,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004844425575,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004388624175,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002068753175,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131989457812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00240016423594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00215544868398,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000663062,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004178178,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034308196,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00628483755,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006471261,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036215386125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00411143415,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019526194625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00159099719844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00240129974687,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017194509125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localX.size(); i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00081723,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029776936,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033405471,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00551310565,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052026994,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003209406425,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00458984803125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00181351403125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168873406563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00182345559766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00191187986563,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006617376,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030473522,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030891725,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052724786,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00551349115,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035033803375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0042192811375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196661712187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00133494866875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00160628275703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00197013812656,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0006834764,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029277118,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030892547,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00508328295,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053481675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038538778875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0042511768375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00195042407813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00144062624688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001433742325,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00180865191992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000681839,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030084216,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003332948,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00607589535,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00554053795,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00377808875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00467057341875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00224135744063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001541680925,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00186768827344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00179493390508,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localSize; i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0007023114,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030205262,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003172396,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053929169,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006175346525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037307623375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038035989,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00218958963125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00155367731875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00185010308594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00156982198633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localSize = x.size() / size;\n    std::vector<int> localX(localSize);\n    MPI_Scatter(x.data(), localSize, MPI_INT, localX.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (int i = 0; i < localX.size(); i++) {\n        localX[i] = localX[i] * localX[i];\n    }\n\n    MPI_Gather(localX.data(), localSize, MPI_INT, x.data(), localSize, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00066108,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039694356,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031128812,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00633757075,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005994665325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0041309263,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004502963975,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192535369688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168065751719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00159537870156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150864407617,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use MPI to parallelize. Assume MPI has already been initialized.\n   Every rank has a complete copy of A, x, and y. Store the result in y on rank 0.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {",
        "translation_prompt": "// Serial implementation of spmv\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n//    and A is a sparse matrix stored in COO format.\n//    A has dimensions MxN, x has N values, and y has M values.\n//    Example:\n// \n//    input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n//    output: y=[2, 3]\n// */\n// void spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//       y[i] *= beta;\n//    }\n// \n//    for (size_t i = 0; i < A.size(); ++i) {\n//       y[A[i].row] += alpha * A[i].value * x[A[i].column];\n//    }\n// }\n\n// MPI implementation of spmv\n#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use MPI to parallelize. Assume MPI has already been initialized.\n   Every rank has a complete copy of A, x, and y. Store the result in y on rank 0.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      y[A[i].row] += alpha * A[i].value * x[A[i].column];\n   }\n}",
        "translation_function_name": "spmv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   for (size_t i = start; i < end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recvbuf[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recvbuf;\n   } else {\n      MPI_Send(&y[start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015144458,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015346858,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_buffer(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_buffer[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_buffer;\n   } else {\n      MPI_Send(&y[local_start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015163738,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015331328,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      local_y[i - local_start] = y[i] * beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         local_y[A[i].row - local_start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      std::vector<int> recvcounts(size, local_M);\n      std::vector<int> displs(size, 0);\n      for (int i = 1; i < size; ++i) {\n         displs[i] = displs[i - 1] + local_M;\n      }\n\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, recvbuf.data(), recvcounts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      y = recvbuf;\n   } else {\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015190004,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015381886,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013648501,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00071817415,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000547290675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011649433125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029351251125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00098750105938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00127252485937,
                        "num_procs": 128
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 256
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      local_y[i - local_start] = y[i] * beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         local_y[A[i].row - local_start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      std::vector<int> recvcounts(size, local_M);\n      std::vector<int> displs(size, 0);\n      for (int i = 1; i < size; ++i) {\n         displs[i] = displs[i - 1] + local_M;\n      }\n\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, recvbuf.data(), recvcounts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      y = recvbuf;\n   } else {\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015179746,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015422944,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011004698,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00068340605,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00054873205,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001305081675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00228967804375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116936555938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00149069580156,
                        "num_procs": 128
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 256
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_y(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_y[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_y;\n   } else {\n      MPI_Send(&y[local_start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015157104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015326982,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start_row = rank * local_M;\n   size_t end_row = (rank + 1) * local_M;\n\n   for (size_t i = start_row; i < end_row; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start_row && A[i].row < end_row) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recvbuf[i * local_M], local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recvbuf;\n   } else {\n      MPI_Send(&y[start_row], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015398138,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015316182,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start_row = rank * local_M;\n   size_t end_row = (rank + 1) * local_M;\n\n   for (size_t i = start_row; i < end_row; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start_row && A[i].row < end_row) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recvbuf[i * local_M], local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recvbuf;\n   } else {\n      MPI_Send(&y[start_row], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001546035,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015398896,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   for (size_t i = start; i < end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_y(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_y[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_y;\n   } else {\n      MPI_Send(&y[start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015160132,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0016111736,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start_row = rank * local_M;\n   size_t end_row = start_row + local_M;\n\n   for (size_t i = start_row; i < end_row; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start_row && A[i].row < end_row) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_buffer(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_buffer[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_buffer;\n   } else {\n      MPI_Send(&y[start_row], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001515053,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.001538437,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   for (size_t i = start; i < end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recvbuf[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recvbuf;\n   } else {\n      MPI_Send(&y[start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015189924,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015325978,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start_row = rank * local_M;\n   size_t end_row = (rank + 1) * local_M;\n   if (rank == size - 1) {\n      end_row = M;\n      local_M = end_row - start_row;\n   }\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = start_row; i < end_row; ++i) {\n      local_y[i - start_row] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start_row && A[i].row < end_row) {\n         local_y[A[i].row - start_row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      y = local_y;\n      std::vector<double> recv_buffer(local_M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(recv_buffer.data(), local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         y.insert(y.end(), recv_buffer.begin(), recv_buffer.end());\n      }\n   } else {\n      MPI_Send(local_y.data(), local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015214092,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015417856,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_buffer(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_buffer[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_buffer;\n   } else {\n      MPI_Send(&y[local_start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015231202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.001535213,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = start + local_M;\n\n   for (size_t i = start; i < end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recv(local_M);\n         MPI_Recv(&recv[0], local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < local_M; ++j) {\n            y[i * local_M + j] = recv[j];\n         }\n      }\n   } else {\n      MPI_Send(&y[start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001517189,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015630858,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010790679,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007117742,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00061546525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001382755725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0023607112,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008836606,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00130281105625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00182350691094,
                        "num_procs": 256
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_buffer(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_buffer[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_buffer;\n   } else {\n      MPI_Send(&y[local_start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0016041286,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015879182,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      local_y[i - local_start] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         local_y[A[i].row - local_start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      std::vector<int> recvcounts(size, local_M);\n      std::vector<int> displs(size, 0);\n\n      MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, recvbuf.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n      y = recvbuf;\n   } else {\n      MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, nullptr, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015565248,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0016193128,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t local_start = rank * local_M;\n   size_t local_end = (rank == size - 1) ? M : (rank + 1) * local_M;\n\n   for (size_t i = local_start; i < local_end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= local_start && A[i].row < local_end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recv_buffer(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_buffer[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_buffer;\n   } else {\n      MPI_Send(&y[local_start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015186656,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015643402,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   for (size_t i = start; i < end; ++i) {\n      y[i] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         y[A[i].row] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recvbuf[0] + i * local_M, local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recvbuf;\n   } else {\n      MPI_Send(&y[start], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015148908,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.001530987,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = start; i < end; ++i) {\n      local_y[i - start] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         local_y[A[i].row - start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      std::vector<int> recvcounts(size, local_M);\n      std::vector<int> displs(size, 0);\n      for (int i = 1; i < size; ++i) {\n         displs[i] = displs[i - 1] + local_M;\n      }\n\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, recvbuf.data(), recvcounts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      y = recvbuf;\n   } else {\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015153554,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015392848,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank == size - 1) ? M : start + local_M;\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = start; i < end; ++i) {\n      local_y[i - start] *= beta;\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         local_y[A[i].row - start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M, 0.0);\n      std::vector<int> recvcounts(size, local_M);\n      std::vector<int> displs(size, 0);\n      for (int i = 1; i < size; ++i) {\n         displs[i] = displs[i - 1] + local_M;\n      }\n\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, recvbuf.data(), recvcounts.data(), displs.data(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      y = recvbuf;\n   } else {\n      MPI_Gatherv(local_y.data(), local_M, MPI_DOUBLE, nullptr, nullptr, nullptr, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015203626,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015439672,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_M = M / size;\n   size_t start = rank * local_M;\n   size_t end = (rank + 1) * local_M;\n   if (rank == size - 1) {\n      end = M;\n   }\n\n   std::vector<double> local_y(local_M, 0.0);\n\n   for (size_t i = start; i < end; ++i) {\n      local_y[i - start] = beta * y[i];\n   }\n\n   for (size_t i = 0; i < A.size(); ++i) {\n      if (A[i].row >= start && A[i].row < end) {\n         local_y[A[i].row - start] += alpha * A[i].value * x[A[i].column];\n      }\n   }\n\n   if (rank == 0) {\n      y = local_y;\n      std::vector<double> recv_y(M, 0.0);\n      for (int i = 1; i < size; ++i) {\n         MPI_Recv(&recv_y[i * local_M], local_M, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      }\n      y = recv_y;\n   } else {\n      MPI_Send(&local_y[0], local_M, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0015229174,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0015410238,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "46_sparse_la_spmm",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and X. Store the result in Y on rank 0.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// Serial implementation of spmm\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n//    X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n//    Example:\n// \n//    input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n//    output: Y=[{-1,-4}, {1,0}]\n// */\n// void spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n// std::vector<double> Ytemp(M*N, 0.0);\n//    for (auto const& a : A) {\n//       for (auto const& x : X) {\n//          if (a.column == x.row) {\n//             Ytemp[a.row*N + x.column] += a.value * x.value;\n//          }\n//       }\n//    }\n//    Y = std::move(Ytemp);\n// }\n\n// MPI implementation of spmm\n#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and X. Store the result in Y on rank 0.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\nstd::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n   Y = std::move(Ytemp);\n}",
        "translation_function_name": "spmm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0793669212,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.022343422,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0226047315,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753302274,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147877492,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0073800004,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038200427,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001846667525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008675149,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046085615625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00026696805,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00015605639688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010861211953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001246319793,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0753565416,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0197604682,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0226651734,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0753723292,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0196619974,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.020070818,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0753345364,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0196541306,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0201850167,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0753839212,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0226727668,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0201680078,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvY(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvY.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvY);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0798244562,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0224050002,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0230259198,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753850594,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131829818,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147875539,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131928018,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015141925675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0141874836,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.018077707475,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0155787501625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017209735275,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02281877594141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04253559954375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.075407105,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0225071238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0201345,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0793320166,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0227666398,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0241587242,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> temp(M*N);\n         MPI_Recv(temp.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += temp[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753479578,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0148200042,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133315198,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131037938,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0143668261,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016635637625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01794040048125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01509865015,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01745773656562,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0239617657625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382491662457,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0753979116,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0196737778,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0228584237,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.07534491,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147377534,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0151110798,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132445761,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147753939,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016180936075,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05355743270625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01510787576875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0176160032125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02342816699062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03828974819297,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N, 0.0);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753760522,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147328824,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132720307,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01314978985,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01516467835,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0151955671625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0179329047375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01492857326875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01705719121094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02238484573984,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04165802054648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvbuf(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvbuf.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvbuf);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0793414384,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0228454656,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0228345513,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.075381124,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131977876,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132525538,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0131853044,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014158867975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0181624989625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01734328261875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01549475582188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01720336117188,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02513818465312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0373166297375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N, 0.0);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753644624,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.013222781,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133736143,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0147027006,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01359223555,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0248808271125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01739805518125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01540437413125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01765870333594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02181229337109,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04074864121875,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      std::vector<double> recvY(M*N, 0.0);\n      MPI_Reduce(Ytemp.data(), recvY.data(), M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n      Y = std::move(recvY);\n   } else {\n      MPI_Reduce(Ytemp.data(), nullptr, M*N, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.075350354,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0197089336,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0200914018,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            if (rank == 0) {\n               Ytemp[a.row*N + x.column] += a.value * x.value;\n            }\n         }\n      }\n   }\n\n   if (rank == 0) {\n       Y = std::move(Ytemp);\n       for (int i = 1; i < size; ++i) {\n           std::vector<double> recvY(M*N);\n           MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n           for (size_t j = 0; j < M*N; ++j) {\n               Y[j] += recvY[j];\n           }\n       }\n   } else {\n       MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0753836088,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132971942,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0132645029,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01333265895,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015994675575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0160435231,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0175315511875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01536475142813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01732754590312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02371733884375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.03350160227734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::vector<double> Ytemp(M*N, 0.0);\n   for (auto const& a : A) {\n      for (auto const& x : X) {\n         if (a.column == x.row) {\n            Ytemp[a.row*N + x.column] += a.value * x.value;\n         }\n      }\n   }\n\n   if (rank == 0) {\n      Y = std::move(Ytemp);\n      for (int i = 1; i < size; ++i) {\n         std::vector<double> recvY(M*N);\n         MPI_Recv(recvY.data(), M*N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         for (size_t j = 0; j < M*N; ++j) {\n            Y[j] += recvY[j];\n         }\n      }\n   } else {\n      MPI_Send(Ytemp.data(), M*N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0785712346,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0227947464,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0225334851,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "49_sparse_la_sparse_lu_decomp",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. Store the result in L and U on rank 0.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {",
        "translation_prompt": "// Serial implementation of luFactorize\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n//    A is a sparse NxN matrix stored in COO format.\n//    Example:\n// \n//    input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n//    output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n// */\n// void luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n// \n// // Assuming A is sorted by row and then by column\n// L.clear();\n// U.clear();\n// \n// // Initialize L and U with zeros\n// L.resize(N * N, 0);\n// U.resize(N * N, 0);\n// \n// // Create a map for quick access to A's elements\n// std::map<std::pair<size_t, size_t>, double> A_map;\n// for (const auto& elem : A) {\n//     A_map[{elem.row, elem.column}] = elem.value;\n// }\n// \n// // LU decomposition algorithm\n// for (size_t i = 0; i < N; ++i) {\n//     // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n//     for (size_t k = i; k < N; ++k) {\n//         double sum = 0.0;\n//         for (size_t j = 0; j < i; ++j) {\n//             sum += L[i * N + j] * U[j * N + k];\n//         }\n//         U[i * N + k] = A_map[{i, k}] - sum;\n//     }\n// \n//     // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n//     for (size_t k = i + 1; k < N; ++k) {\n//         double sum = 0.0;\n//         for (size_t j = 0; j < i; ++j) {\n//             sum += L[k * N + j] * U[j * N + i];\n//         }\n//         L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n//     }\n// \n//     // L(i, i) = 1\n//     L[i * N + i] = 1.0;\n// }\n// }\n\n// MPI implementation of luFactorize\n#include <mpi.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. Store the result in L and U on rank 0.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n\n// Assuming A is sorted by row and then by column\nL.clear();\nU.clear();\n\n// Initialize L and U with zeros\nL.resize(N * N, 0);\nU.resize(N * N, 0);\n\n// Create a map for quick access to A's elements\nstd::map<std::pair<size_t, size_t>, double> A_map;\nfor (const auto& elem : A) {\n    A_map[{elem.row, elem.column}] = elem.value;\n}\n\n// LU decomposition algorithm\nfor (size_t i = 0; i < N; ++i) {\n    // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n    for (size_t k = i; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[i * N + j] * U[j * N + k];\n        }\n        U[i * N + k] = A_map[{i, k}] - sum;\n    }\n\n    // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n    for (size_t k = i + 1; k < N; ++k) {\n        double sum = 0.0;\n        for (size_t j = 0; j < i; ++j) {\n            sum += L[k * N + j] * U[j * N + i];\n        }\n        L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n    }\n\n    // L(i, i) = 1\n    L[i * N + i] = 1.0;\n}\n}",
        "translation_function_name": "luFactorize",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(const_cast<std::vector<COOElement>*>(&A), A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    if (rank == 0) {\n        for (const auto& elem : A) {\n            A_map[{elem.row, elem.column}] = elem.value;\n        }\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather the results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : L.data(), L.size(), MPI_DOUBLE, L.data(), L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : U.data(), U.size(), MPI_DOUBLE, U.data(), U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1936116034,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.235427986,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; ++i) {\n            std::vector<double> recv_L(N * N);\n            std::vector<double> recv_U(N * N);\n            MPI_Recv(recv_L.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(recv_U.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t j = 0; j < N * N; ++j) {\n                L[j] += recv_L[j];\n                U[j] += recv_U[j];\n            }\n        }\n    } else {\n        MPI_Send(L.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(U.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1921302496,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3324348212,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.2297210483,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        // Gather results from all ranks to rank 0\n        std::vector<double> recv_L(N * N, 0);\n        std::vector<double> recv_U(N * N, 0);\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, recv_L.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, recv_U.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        L = recv_L;\n        U = recv_U;\n    } else {\n        // Send results from other ranks to rank 0\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.194844813,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2375427462,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        // Gather results from all ranks to rank 0\n        std::vector<double> local_L = L;\n        std::vector<double> local_U = U;\n        for (int i = 1; i < size; ++i) {\n            MPI_Recv(&local_L[0], N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(&local_U[0], N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t j = 0; j < N * N; ++j) {\n                L[j] += local_L[j];\n                U[j] += local_U[j];\n            }\n        }\n    } else {\n        // Send local results to rank 0\n        MPI_Send(&L[0], N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(&U[0], N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        if (i % size == rank) {\n            for (size_t k = i; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[i * N + j] * U[j * N + k];\n                }\n                U[i * N + k] = A_map[{i, k}] - sum;\n            }\n\n            for (size_t k = i + 1; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[k * N + j] * U[j * N + i];\n                }\n                L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n            }\n            L[i * N + i] = 1.0;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<double> recvL(N * N, 0);\n        std::vector<double> recvU(N * N, 0);\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, recvL.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, recvU.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        L = recvL;\n        U = recvU;\n    } else {\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1917672412,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2360460814,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    L.clear();\n    U.clear();\n\n    if (rank == 0) {\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        if (i % size == rank) {\n            for (size_t k = i; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[i * N + j] * U[j * N + k];\n                }\n                U[i * N + k] = A_map[{i, k}] - sum;\n            }\n\n            for (size_t k = i + 1; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[k * N + j] * U[j * N + i];\n                }\n                L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n            }\n\n            L[i * N + i] = 1.0;\n        }\n\n        if (size > 1) {\n            MPI_Bcast(&U[i * N], N, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n            MPI_Bcast(&L[i * N], N, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; ++i) {\n            std::vector<double> recv_L(N * N);\n            std::vector<double> recv_U(N * N);\n            MPI_Recv(recv_L.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(recv_U.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t j = 0; j < N * N; ++j) {\n                L[j] += recv_L[j];\n                U[j] += recv_U[j];\n            }\n        }\n    } else {\n        MPI_Send(L.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(U.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1911651822,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2295818314,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.2996036407,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; ++i) {\n            std::vector<double> recv_L(N * N);\n            std::vector<double> recv_U(N * N);\n            MPI_Recv(recv_L.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(recv_U.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t j = 0; j < N * N; ++j) {\n                L[j] += recv_L[j];\n                U[j] += recv_U[j];\n            }\n        }\n    } else {\n        MPI_Send(L.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(U.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1912804948,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2410901684,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.2413069031,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        // Gather results from all ranks to rank 0\n        std::vector<double> L_recv(N * N, 0);\n        std::vector<double> U_recv(N * N, 0);\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, L_recv.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, U_recv.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        L = L_recv;\n        U = U_recv;\n    } else {\n        MPI_Gather(L.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_COMM_WORLD);\n        MPI_Gather(U.data(), N * N, MPI_DOUBLE, nullptr, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        L[i * N + i] = 1.0;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; ++i) {\n            std::vector<double> recv_L(N * N);\n            std::vector<double> recv_U(N * N);\n            MPI_Recv(recv_L.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(recv_U.data(), N * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t j = 0; j < N * N; ++j) {\n                L[j] += recv_L[j];\n                U[j] += recv_U[j];\n            }\n        }\n    } else {\n        MPI_Send(L.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(U.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.192191525,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2425684604,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.23139621,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather L and U to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather the results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    if (rank == 0) {\n        for (const auto& elem : A) {\n            A_map[{elem.row, elem.column}] = elem.value;\n        }\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather L and U to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(const_cast<std::vector<COOElement>*>(&A)[0].data(), A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather the results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : L.data(), L.size(), MPI_DOUBLE, L.data(), L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : U.data(), U.size(), MPI_DOUBLE, U.data(), U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1940836628,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2380953144,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather the results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(const_cast<COOElement*>(A.data()), A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    if (rank == 0) {\n        for (const auto& elem : A) {\n            A_map[{elem.row, elem.column}] = elem.value;\n        }\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : L.data(), N * N, MPI_DOUBLE, L.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : U.data(), N * N, MPI_DOUBLE, U.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1928037132,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2273781064,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    L.clear();\n    U.clear();\n\n    if (rank == 0) {\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        if (i % size == rank) {\n            for (size_t k = i; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[i * N + j] * U[j * N + k];\n                }\n                U[i * N + k] = A_map[{i, k}] - sum;\n            }\n\n            for (size_t k = i + 1; k < N; ++k) {\n                double sum = 0.0;\n                for (size_t j = 0; j < i; ++j) {\n                    sum += L[k * N + j] * U[j * N + i];\n                }\n                L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n            }\n\n            L[i * N + i] = 1.0;\n        }\n\n        if (size > 1) {\n            MPI_Bcast(&U[i * N], N, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n            MPI_Bcast(&L[i * N], N, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n        }\n    }\n\n    if (rank == 0) {\n        for (int r = 1; r < size; ++r) {\n            std::vector<double> recv_L(N * N);\n            std::vector<double> recv_U(N * N);\n            MPI_Recv(recv_L.data(), N * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            MPI_Recv(recv_U.data(), N * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (size_t i = 0; i < N * N; ++i) {\n                L[i] += recv_L[i];\n                U[i] += recv_U[i];\n            }\n        }\n    } else {\n        MPI_Send(L.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Send(U.data(), N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1916120378,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2321282258,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.2556043616,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(const_cast<COOElement*>(A.data()), A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    if (rank == 0) {\n        for (const auto& elem : A) {\n            A_map[{elem.row, elem.column}] = elem.value;\n        }\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : L.data(), N * N, MPI_DOUBLE, L.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : U.data(), N * N, MPI_DOUBLE, U.data(), N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1933745962,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2284121878,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        L.clear();\n        U.clear();\n        L.resize(N * N, 0);\n        U.resize(N * N, 0);\n    }\n\n    // Broadcast A to all ranks\n    MPI_Bcast(&A[0], A.size() * sizeof(COOElement), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n    // Create a map for quick access to A's elements\n    std::map<std::pair<size_t, size_t>, double> A_map;\n    for (const auto& elem : A) {\n        A_map[{elem.row, elem.column}] = elem.value;\n    }\n\n    // LU decomposition algorithm\n    for (size_t i = 0; i < N; ++i) {\n        // U(i, k) = A(i, k) - sum(L(i, j) * U(j, k))\n        for (size_t k = i; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[i * N + j] * U[j * N + k];\n            }\n            U[i * N + k] = A_map[{i, k}] - sum;\n        }\n\n        // L(k, i) = (A(k, i) - sum(L(k, j) * U(j, i))) / U(i, i)\n        for (size_t k = i + 1; k < N; ++k) {\n            double sum = 0.0;\n            for (size_t j = 0; j < i; ++j) {\n                sum += L[k * N + j] * U[j * N + i];\n            }\n            L[k * N + i] = (A_map[{k, i}] - sum) / U[i * N + i];\n        }\n\n        // L(i, i) = 1\n        L[i * N + i] = 1.0;\n    }\n\n    // Gather results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &L[0], L.size(), MPI_DOUBLE, &L[0], L.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : &U[0], U.size(), MPI_DOUBLE, &U[0], U.size(), MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            }
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "23_histogram_first_letter_counts",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of s. The result is stored in bins on rank 0.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {",
        "translation_prompt": "// Serial implementation of firstLetterCounts\n// /* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n//    Assume all strings are in lower case. Store the output in `bins` array.\n//    Example:\n// \n//    input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n//    output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n// */\n// void firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n// for (auto const& str : s) {\n//         bins[str[0] - 'a']++;\n//     }\n// }\n\n// MPI implementation of firstLetterCounts\n#include <mpi.h>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of s. The result is stored in bins on rank 0.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\nfor (auto const& str : s) {\n        bins[str[0] - 'a']++;\n    }\n}",
        "translation_function_name": "firstLetterCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> received_bins;\n            MPI_Recv(received_bins.data(), 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += received_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(local_bins.data(), 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        for (int i = 0; i < 26; i++) {\n            bins[i] += local_bins[i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0064893948,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065387702,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0078105722,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058895998,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063163578,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0074485968,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00854686815,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008920926775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0096324368625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.25401749200625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01169720636563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01811038597656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02551614165547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05132993198516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00583426,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061430662,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0087811767,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00952681725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010512452025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0100147727375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26776884821875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01314770524063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01776707251875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02545662374453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0511452044832,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058713854,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061849026,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0072238961,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00769109995,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009904429925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009145977925,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.27120075835,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01164294790625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01567378517031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02519816546172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0511516763668,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005916406,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065964782,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0073550349,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00732338845,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009141357475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010033920175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2602342765,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01273538602187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01598985726875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02519817528984,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05098965488711,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0059670916,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062587276,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076410549,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00774186315,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008624233575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0090920545125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2692122189375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01322934789375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01931257694219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02549020602031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05098526156094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005989209,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061262824,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0123832766,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01025813455,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009075588125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00876295585,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.24266150276875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01367702440625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01846149891719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02499040976797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05058435923438,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> received_bins;\n            MPI_Recv(received_bins.data(), 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += received_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(local_bins.data(), 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        for (int i = 0; i < 26; i++) {\n            bins[i] += local_bins[i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0059272368,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0068089894,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0107001295,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058980698,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0067892208,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076340116,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0074006302,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008233532375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0230733651125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26483574551875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01249433867187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01830376902656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02520863756172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05134965289336,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005746645,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0064787192,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007807786,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0079691716,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008562111775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010430549475,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2699703651875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0176186798625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016568569975,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02584048950781,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0507467158582,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058638412,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061912468,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007648659,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00737562615,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00918001445,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0089682066375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.22974628238125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01496540418438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01738608844062,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02550077359297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05103511521406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0059017886,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061923806,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007689209,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00852293655,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009100740175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0095857190375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2677253625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01099059987813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01586136111563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02450650139141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05102154526953,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        std::array<size_t, 26> recv_bins = {0};\n        MPI_Reduce(local_bins.data(), recv_bins.data(), 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n        bins = recv_bins;\n    } else {\n        MPI_Reduce(local_bins.data(), nullptr, 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0058861656,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062230106,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.007498478,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005878469,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065917788,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0114653609,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01062559375,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00740446785,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098867997625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26187082204375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01477363110313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01691248907656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02491668743359,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05125844312227,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058969216,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061390566,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0076181887,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00743237035,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008062478525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0088483898625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.271536599225,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0153498177125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.017106385225,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02590622156797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05111577558516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        std::array<size_t, 26> recv_bins = {0};\n        MPI_Reduce(local_bins.data(), recv_bins.data(), 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n        bins = recv_bins;\n    } else {\n        MPI_Reduce(local_bins.data(), nullptr, 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0058946692,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0062363716,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0078980539,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> localBins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            localBins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recvBins;\n            MPI_Recv(&recvBins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recvBins[j];\n            }\n        }\n    } else {\n        MPI_Send(&localBins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recvBins;\n            MPI_Recv(&recvBins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recvBins[j];\n            }\n        }\n    } else {\n        MPI_Send(&localBins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0059743412,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0065576748,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if ((str[0] - 'a') % size == rank) {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058504764,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009520563,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0302731338,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0208923743,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.015518154025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0139210206625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02210987945625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01723061315937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02141335374844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02928594045156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04879082689883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> local_bins = {0};\n\n    for (auto const& str : s) {\n        if (str[0] >= 'a' && str[0] <= 'z') {\n            local_bins[str[0] - 'a']++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 26> recv_bins;\n            MPI_Recv(&recv_bins, 26, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 26; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 26, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = local_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.005873756,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0061576834,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0073174619,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00735880285,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008986795225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00898162115,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.26734451816875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014739297175,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016293774125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02589054536641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.05070072964844,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 26> localBins = {0};\n\n    for (auto const& str : s) {\n        if ((str[0] - 'a') % size == rank) {\n            localBins[str[0] - 'a']++;\n        }\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 26, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0058271486,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0084050546,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0300158236,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0220040271,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.016166814425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014065279525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01697424208125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01826824540313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01998591475625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02833631306172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04878885406289,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "21_histogram_bin_0-100",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The result is stored in bins on rank 0.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {",
        "translation_prompt": "// Serial implementation of binsBy10Count\n// /* Vector x contains values between 0 and 100, inclusive. Count the number of\n//    values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n//    Example:\n// \n//    input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n//    output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n// */\n// void binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n// for (auto const& value : x) {\n//     if (value < 10) {\n//       bins[0]++;\n//     } else if (value < 20) {\n//       bins[1]++;\n//     } else if (value < 30) {\n//       bins[2]++;\n//     } else if (value < 40) {\n//       bins[3]++;\n//     } else if (value < 50) {\n//       bins[4]++;\n//     } else if (value < 60) {\n//       bins[5]++;\n//     } else if (value < 70) {\n//       bins[6]++;\n//     } else if (value < 80) {\n//       bins[7]++;\n//     } else if (value < 90) {\n//       bins[8]++;\n//     } else {\n//       bins[9]++;\n//     }\n//   }\n// }\n\n// MPI implementation of binsBy10Count\n#include <mpi.h>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The result is stored in bins on rank 0.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\nfor (auto const& value : x) {\n    if (value < 10) {\n      bins[0]++;\n    } else if (value < 20) {\n      bins[1]++;\n    } else if (value < 30) {\n      bins[2]++;\n    } else if (value < 40) {\n      bins[3]++;\n    } else if (value < 50) {\n      bins[4]++;\n    } else if (value < 60) {\n      bins[5]++;\n    } else if (value < 70) {\n      bins[6]++;\n    } else if (value < 80) {\n      bins[7]++;\n    } else if (value < 90) {\n      bins[8]++;\n    } else {\n      bins[9]++;\n    }\n  }\n}",
        "translation_function_name": "binsBy10Count",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> localBins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      localBins[0]++;\n    } else if (value < 20) {\n      localBins[1]++;\n    } else if (value < 30) {\n      localBins[2]++;\n    } else if (value < 40) {\n      localBins[3]++;\n    } else if (value < 50) {\n      localBins[4]++;\n    } else if (value < 60) {\n      localBins[5]++;\n    } else if (value < 70) {\n      localBins[6]++;\n    } else if (value < 80) {\n      localBins[7]++;\n    } else if (value < 90) {\n      localBins[8]++;\n    } else {\n      localBins[9]++;\n    }\n  }\n\n  MPI_Reduce(localBins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061047818,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0474403354,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0475457048,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_start = rank * (x.size() / size);\n  int local_end = (rank + 1) * (x.size() / size);\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0060998226,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0468847596,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235496449,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01422774005,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007749598025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00624354405,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026601515,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107190935937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00075353235156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00069491437266,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006546881543,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_start = rank * (x.size() / size);\n  int local_end = (rank == size - 1) ? x.size() : (rank + 1) * (x.size() / size);\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061106228,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.047541902,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0238199429,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01439335205,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007618963725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037190424125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002594585375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001053870475,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00067817767656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00074906974219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00068593328516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_start = rank * (x.size() / size);\n  int local_end = (rank == size - 1) ? x.size() : (rank + 1) * (x.size() / size);\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061087598,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0474292106,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0238531642,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01438860195,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007551402775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034993594125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0025649906375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00114233139063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00074596323125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00077512237891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00071027847773,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> recv_bins;\n      MPI_Recv(&recv_bins, 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += recv_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(&local_bins, 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += local_bins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061108436,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0448642966,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0447084962,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_start = rank * (x.size() / size);\n  int local_end = (rank + 1) * (x.size() / size);\n  if (rank == size - 1) {\n    local_end = x.size();\n  }\n\n  for (int i = local_start; i < local_end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0060998866,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0475121582,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0237598248,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01409321065,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007465659675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035621046875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00263227745625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109638027188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00065826444063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00061964335391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00066015045977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> localBins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      localBins[0]++;\n    } else if (value < 20) {\n      localBins[1]++;\n    } else if (value < 30) {\n      localBins[2]++;\n    } else if (value < 40) {\n      localBins[3]++;\n    } else if (value < 50) {\n      localBins[4]++;\n    } else if (value < 60) {\n      localBins[5]++;\n    } else if (value < 70) {\n      localBins[6]++;\n    } else if (value < 80) {\n      localBins[7]++;\n    } else if (value < 90) {\n      localBins[8]++;\n    } else {\n      localBins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> recvBins;\n      MPI_Recv(&recvBins, 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += recvBins[j];\n      }\n    }\n  } else {\n    MPI_Send(&localBins, 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += localBins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061092182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0445892978,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0446635242,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  for (int i = 0; i < 10; i++) {\n    MPI_Reduce(&local_bins[i], &bins[i], 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061131176,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.050230775,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0261091766,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0157778999,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008327172,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051240086875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00342470220625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00156250950625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010012981,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00081635420078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092554125352,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> received_bins;\n      MPI_Recv(received_bins.data(), 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += received_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(local_bins.data(), 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += local_bins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061589896,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0446775238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0448277236,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> recv_bins;\n      MPI_Recv(&recv_bins, 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += recv_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(&local_bins, 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += local_bins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061043996,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0453431222,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.044695366,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> recv_bins;\n      MPI_Recv(recv_bins.data(), 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += recv_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(local_bins.data(), 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += local_bins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061105968,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.044904915,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0450230178,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> received_bins;\n      MPI_Recv(received_bins.data(), 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += received_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(local_bins.data(), 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    bins = local_bins;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.006108473,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0457868462,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0455591742,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04696198965,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045395875075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0461044702875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.15438132709375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04586564076563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04619599365313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04675858826094,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04859912836406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  for (int i = 0; i < 10; i++) {\n    MPI_Reduce(&local_bins[i], &bins[i], 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061209082,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0503938936,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.025996786,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01563212315,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00889213825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004781803225,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00344514830625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00155952966563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00101276366875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00081611786953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107283575859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      local_bins[0]++;\n    } else if (value < 20) {\n      local_bins[1]++;\n    } else if (value < 30) {\n      local_bins[2]++;\n    } else if (value < 40) {\n      local_bins[3]++;\n    } else if (value < 50) {\n      local_bins[4]++;\n    } else if (value < 60) {\n      local_bins[5]++;\n    } else if (value < 70) {\n      local_bins[6]++;\n    } else if (value < 80) {\n      local_bins[7]++;\n    } else if (value < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; i++) {\n      std::array<size_t, 10> recv_bins;\n      MPI_Recv(&recv_bins, 10, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (int j = 0; j < 10; j++) {\n        bins[j] += recv_bins[j];\n      }\n    }\n  } else {\n    MPI_Send(&local_bins, 10, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n  }\n\n  if (rank == 0) {\n    for (int i = 0; i < 10; i++) {\n      bins[i] += local_bins[i];\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0061379222,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0455029804,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0448830906,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> localBins = {0};\n  size_t localCount = x.size() / size;\n  size_t remainder = x.size() % size;\n\n  size_t start = rank * localCount + std::min(rank, remainder);\n  size_t end = start + localCount + (rank < remainder ? 1 : 0);\n\n  for (size_t i = start; i < end; ++i) {\n    double value = x[i];\n    if (value < 10) {\n      localBins[0]++;\n    } else if (value < 20) {\n      localBins[1]++;\n    } else if (value < 30) {\n      localBins[2]++;\n    } else if (value < 40) {\n      localBins[3]++;\n    } else if (value < 50) {\n      localBins[4]++;\n    } else if (value < 60) {\n      localBins[5]++;\n    } else if (value < 70) {\n      localBins[6]++;\n    } else if (value < 80) {\n      localBins[7]++;\n    } else if (value < 90) {\n      localBins[8]++;\n    } else {\n      localBins[9]++;\n    }\n  }\n\n  MPI_Reduce(localBins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> localBins = {0};\n\n  for (auto const& value : x) {\n    if (value < 10) {\n      localBins[0]++;\n    } else if (value < 20) {\n      localBins[1]++;\n    } else if (value < 30) {\n      localBins[2]++;\n    } else if (value < 40) {\n      localBins[3]++;\n    } else if (value < 50) {\n      localBins[4]++;\n    } else if (value < 60) {\n      localBins[5]++;\n    } else if (value < 70) {\n      localBins[6]++;\n    } else if (value < 80) {\n      localBins[7]++;\n    } else if (value < 90) {\n      localBins[8]++;\n    } else {\n      localBins[9]++;\n    }\n  }\n\n  for (int i = 0; i < 10; i++) {\n    MPI_Reduce(&localBins[i], &bins[i], 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.006107902,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0454750382,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0456253002,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_count = x.size() / size;\n  int remainder = x.size() % size;\n\n  int start = rank * local_count + std::min(rank, remainder);\n  int end = start + local_count + (rank < remainder ? 1 : 0);\n\n  for (int i = start; i < end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061109016,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0475748602,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0239635118,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01430616485,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007592409325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003581569725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039860828625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109389168437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00133831332969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00052585225078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006546897793,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_count = x.size() / size;\n  int remainder = x.size() % size;\n\n  int start = rank * local_count + std::min(rank, remainder);\n  int end = start + local_count + (rank < remainder ? 1 : 0);\n\n  for (int i = start; i < end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061178642,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0475100678,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0238118214,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0141580726,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007673629425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00355881105,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002663452525,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00105812599687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00070597615937,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055422660391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00062154893633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  int local_count = x.size() / size;\n  int remainder = x.size() % size;\n\n  int start = rank * local_count + std::min(rank, remainder);\n  int end = start + local_count + (rank < remainder ? 1 : 0);\n\n  for (int i = start; i < end; i++) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061070362,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0475673836,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0238817391,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.014519176,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0077617669,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003532264625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00264629153125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011039726625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00072517136563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00059439774687,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00075816331406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::array<size_t, 10> local_bins = {0};\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] < 10) {\n      local_bins[0]++;\n    } else if (x[i] < 20) {\n      local_bins[1]++;\n    } else if (x[i] < 30) {\n      local_bins[2]++;\n    } else if (x[i] < 40) {\n      local_bins[3]++;\n    } else if (x[i] < 50) {\n      local_bins[4]++;\n    } else if (x[i] < 60) {\n      local_bins[5]++;\n    } else if (x[i] < 70) {\n      local_bins[6]++;\n    } else if (x[i] < 80) {\n      local_bins[7]++;\n    } else if (x[i] < 90) {\n      local_bins[8]++;\n    } else {\n      local_bins[9]++;\n    }\n  }\n\n  MPI_Reduce(local_bins.data(), bins.data(), 10, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0061111796,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0504847856,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0247133422,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0148475144,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.007872785675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004461768225,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003593823775,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162642998125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00101966532813,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00094589539219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092397097773,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use MPI to count in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of points. The result is stored in bins on rank 0.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {",
        "translation_prompt": "// Serial implementation of countQuadrants\n// struct Point {\n//    double x, y;\n// };\n// \n// /* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n//    Store the counts in `bins`.\n//    Example:\n// \n//    input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n//    output: [3, 1, 0, 2]\n// */\n// void countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n// for (auto const& point : points) {\n//       if (point.x > 0 && point.y > 0) {\n//          bins[0]++;\n//       } else if (point.x < 0 && point.y > 0) {\n//          bins[1]++;\n//       } else if (point.x < 0 && point.y < 0) {\n//          bins[2]++;\n//       } else {\n//          bins[3]++;\n//       }\n//    }\n// }\n\n// MPI implementation of countQuadrants\n#include <mpi.h>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use MPI to count in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of points. The result is stored in bins on rank 0.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\nfor (auto const& point : points) {\n      if (point.x > 0 && point.y > 0) {\n         bins[0]++;\n      } else if (point.x < 0 && point.y > 0) {\n         bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n         bins[2]++;\n      } else {\n         bins[3]++;\n      }\n   }\n}",
        "translation_function_name": "countQuadrants",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t local_bins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         local_bins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         local_bins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         local_bins[2]++;\n      } else {\n         local_bins[3]++;\n      }\n   }\n\n   MPI_Reduce(local_bins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0417283748,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04539969,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.023570105,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01353188015,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008432119625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043716374625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003091780725,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00180820453437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00231522864844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00211784463828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116790247891,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416945734,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0450836982,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235436171,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01335440825,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0084848132,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049641657875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003395325725,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00238462449688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00255150069219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00236371978906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00115500631992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416864,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045410845,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235955584,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136103118,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008348579975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004322396625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035092781375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00193198154687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189169610938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00197046843281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00119185846133,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416497128,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0453303914,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235761111,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136729406,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008722017975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005345663375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00313850814375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00269726341875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196260940469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00215355731562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109569336602,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416257858,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0451498984,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0243134863,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136562445,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008916425825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049135192625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00346186424375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00302925088438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00337408595781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00173904143828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118456267695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416733314,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045310418,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0236222858,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01381184105,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009395439275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004869970125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00340719621875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00194978045,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00189375935469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00222072503828,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00119448691445,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.041751663,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045108643,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0236157152,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01362444585,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098356507,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046596478375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002920950575,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00277381350938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00289594718281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00245286482813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109552881914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416260544,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045376376,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235427499,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136025002,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0083987876,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046934834625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00381081954375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00201637717813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00234370349063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00224273509766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00127732987461,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416439442,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0451364832,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0239768807,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136737787,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01034144705,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043775395875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00328278561875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00199420506562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192189473438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00235988946719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118017609961,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416087704,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0450583724,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0239892983,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0137354461,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0094837031,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004302107625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029909038625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00206877260313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050137068625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00205327717812,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00108199751289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0417253752,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045686513,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0241928883,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01364855545,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008402690975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050888572125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00333202745,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00212546291875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00277294849688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00219526417344,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00113616021523,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.041644341,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045071369,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0246230901,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0135680553,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0100064267,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00495234285,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00393320555625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00220613208125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196449673438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00201901933203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00117139911836,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.041594345,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0450909216,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0236607633,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0134951195,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009057069925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004706712875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029340958,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00201048046875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00244250733125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00295389255,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109425205937,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416812862,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0453552104,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235569559,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01349505425,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009001426175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043965923125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038471049375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00296558145,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00246195472656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00218587058906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116569172383,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416888566,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0456886586,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235461498,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01372961265,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008559948225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050210260125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00293224271875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00201624256562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00223142340625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153700908594,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00114392520273,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416357136,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0450947816,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235758012,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01372830875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.008382682725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043657216875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00353704881875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00247425610625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00379687800469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00182554841797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116044939492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416525688,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.045036536,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0236103943,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0137916666,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010491139325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046728938375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00327219166875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00174189400312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00187962838437,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00207289376953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00120060365781,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416130432,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0449345204,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235203623,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01354196285,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00825918775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046712477,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00310790231875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00223224063125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00191820134219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00197870098438,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00120220317695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   std::array<size_t, 4> localBins = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0416378772,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.044951496,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235683484,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0136315354,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009362521725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046268017625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00334486243125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00195450665312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022233580125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00245933708672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00377443878906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t localBins[4] = {0, 0, 0, 0};\n   for (size_t i = rank; i < points.size(); i += size) {\n      if (points[i].x > 0 && points[i].y > 0) {\n         localBins[0]++;\n      } else if (points[i].x < 0 && points[i].y > 0) {\n         localBins[1]++;\n      } else if (points[i].x < 0 && points[i].y < 0) {\n         localBins[2]++;\n      } else {\n         localBins[3]++;\n      }\n   }\n\n   MPI_Reduce(localBins, bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0415868818,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04565485,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0235081745,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01351444725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009039317575,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045280769125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00308287099375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00209266955938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00226552840156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00196280046328,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00115657967422,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "24_histogram_count_quartile",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use MPI to compute in parallel. Assume that MPI has already been initialized.\n   Every rank has a complete copy of x. The result is stored in bins on rank 0.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {",
        "translation_prompt": "// Serial implementation of countQuartiles\n// /* Count the number of doubles in the vector x that have a fractional part \n//    in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n//    Examples:\n// \n//    input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n//    output: [2, 1, 2, 2]\n// \n//    input: [1.9, 0.2, 0.6, 10.1, 7.4]\n//    output: [2, 1, 1, 1]\n// */\n// void countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n// for (double num : x) {\n//         double fractional_part = num - std::floor(num);\n//         if (fractional_part < 0.25) {\n//             bins[0]++;\n//         } else if (fractional_part < 0.5) {\n//             bins[1]++;\n//         } else if (fractional_part < 0.75) {\n//             bins[2]++;\n//         } else {\n//             bins[3]++;\n//         }\n//     }\n// }\n\n// MPI implementation of countQuartiles\n#include <mpi.h>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use MPI to compute in parallel. Assume that MPI has already been initialized.\n   Every rank has a complete copy of x. The result is stored in bins on rank 0.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\nfor (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            bins[0]++;\n        } else if (fractional_part < 0.5) {\n            bins[1]++;\n        } else if (fractional_part < 0.75) {\n            bins[2]++;\n        } else {\n            bins[3]++;\n        }\n    }\n}",
        "translation_function_name": "countQuartiles",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0625079914,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779527864,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780263441,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0634779442,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780788132,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0781585376,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0625788348,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.078141038,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0779471483,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    for (int i = 0; i < 4; i++) {\n        size_t local_count = local_bins[i];\n        size_t global_count;\n        MPI_Reduce(&local_count, &global_count, 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n        if (rank == 0) {\n            bins[i] = global_count;\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0635838372,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778943264,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780305662,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    for (int i = 0; i < 4; i++) {\n        size_t local_count = local_bins[i];\n        size_t global_count;\n        MPI_Reduce(&local_count, &global_count, 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n        if (rank == 0) {\n            bins[i] = global_count;\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0622968246,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779301458,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0782525471,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0632684786,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779006984,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0783218125,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(&local_bins, &global_bins, 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0634292826,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.077926902,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.078107556,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0622201202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0778888822,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780035185,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.063505061,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779979952,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0781275956,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(&local_bins, &global_bins, 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0635578702,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780403612,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0778683541,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(&local_bins, &global_bins, 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0634583832,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779000088,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0779808096,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0622745006,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779310792,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0782019795,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0635166506,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780277974,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0781646241,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.062766241,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779180792,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780799409,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(local_bins.data(), global_bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0623251594,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0779222046,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780687538,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n\n    int local_count = x.size() / size;\n    int remainder = x.size() % size;\n    int start = rank * local_count + std::min(rank, remainder);\n    int end = start + local_count + (rank < remainder ? 1 : 0);\n\n    for (int i = start; i < end; i++) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0621310188,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.075865909,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0379137583,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0215813127,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.011065385625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005393544825,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00342227875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152104620313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00106123190156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00071338829766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088826668359,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(&local_bins, &global_bins, 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0627405608,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780146986,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0781304332,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    if (rank == 0) {\n        for (int i = 0; i < size; i++) {\n            std::array<size_t, 4> recv_bins;\n            MPI_Recv(&recv_bins, 4, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 4; j++) {\n                bins[j] += recv_bins[j];\n            }\n        }\n    } else {\n        MPI_Send(&local_bins, 4, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n\n    for (size_t i = rank; i < x.size(); i += size) {\n        double num = x[i];\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractionintal_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 4> local_bins = {0, 0, 0, 0};\n    for (double num : x) {\n        double fractional_part = num - std::floor(num);\n        if (fractional_part < 0.25) {\n            local_bins[0]++;\n        } else if (fractional_part < 0.5) {\n            local_bins[1]++;\n        } else if (fractional_part < 0.75) {\n            local_bins[2]++;\n        } else {\n            local_bins[3]++;\n        }\n    }\n\n    std::array<size_t, 4> global_bins = {0, 0, 0, 0};\n    MPI_Reduce(&local_bins, &global_bins, 4, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        bins = global_bins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0633096832,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0780475952,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0780501298,
                        "num_procs": 2
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "20_histogram_pixel_histogram",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use MPI to count in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of image. The result is stored in bins on rank 0.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {",
        "translation_prompt": "// Serial implementation of pixelCounts\n// /* Count the number of pixels in image with each grayscale intensity.\n//    The vector `image` is a grayscale image with values 0-255.\n//    Store the results in `bins`.\n//    Example:\n//    \n//    input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n//    output: [0, 0, 2, 0, 1, ...]\n// */\n//  void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n// for (auto const& pixel : image) {\n//         bins[pixel]++;\n//     }\n// }\n\n// MPI implementation of pixelCounts\n#include <mpi.h>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use MPI to count in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of image. The result is stored in bins on rank 0.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\nfor (auto const& pixel : image) {\n        bins[pixel]++;\n    }\n}",
        "translation_function_name": "pixelCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    for (size_t i = rank; i < image.size(); i += size) {\n        localBins[image[i]]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018516612,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019442174,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001278687,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032818637,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002553267475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001346476025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00202214185625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00077381008438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00061752602344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000535067475,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008576976918,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n    for (auto const& pixel : image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018654796,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027634524,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0032141768,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n    for (auto const& pixel : image) {\n        localBins[pixel]++;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 256> recvBins;\n            MPI_Recv(recvBins.data(), 256, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 256; j++) {\n                bins[j] += recvBins[j];\n            }\n        }\n    } else {\n        MPI_Send(localBins.data(), 256, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = localBins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018572702,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029648112,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030155024,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00435424825,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029709325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036434505,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18452778623125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00329448829375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00383992975,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051206522375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00751272161055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    for (size_t i = rank; i < image.size(); i += size) {\n        localBins[image[i]]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001857851,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020743782,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013282742,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00312708165,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00216666395,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001510227375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021275758125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000676933625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00058419899531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00056575144687,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00072070368594,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    std::vector<int> localImage(localImageSize);\n    MPI_Scatter(image.data(), localImageSize, MPI_INT, localImage.data(), localImageSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : localImage) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00185402,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035170052,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036816042,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004734899,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004965220475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0024408049,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028644695875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00122013569688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095891757969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118633960938,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00127930854805,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    for (auto const& pixel : image) {\n        localBins[pixel]++;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 256> recvBins;\n            MPI_Recv(recvBins.data(), 256, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 256; j++) {\n                bins[j] += recvBins[j];\n            }\n        }\n    } else {\n        MPI_Send(localBins.data(), 256, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = localBins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018528276,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027311284,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029638191,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047200282,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00300572965,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034405042,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.18059771221875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00343515754688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00386409588438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00517618004219,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00758660877148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_image_size = image.size() / size;\n    std::vector<int> local_image(local_image_size);\n    MPI_Scatter(image.data(), local_image_size, MPI_INT, local_image.data(), local_image_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : local_image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018584304,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003372826,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033537608,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00482773155,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005197860675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020096312625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002675393825,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131652960625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095860450625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00122181180234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153199652734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_image_size = image.size() / size;\n    std::vector<int> local_image(local_image_size);\n    MPI_Scatter(image.data(), local_image_size, MPI_INT, local_image.data(), local_image_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : local_image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018500744,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033856362,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034363618,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0048845904,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0058561146,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021336520125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00300709480625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116224463125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009890505625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00126317001641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116804518906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_image_size = image.size() / size;\n    std::vector<int> local_image(local_image_size);\n    MPI_Scatter(image.data(), local_image_size, MPI_INT, local_image.data(), local_image_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : local_image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018600292,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034839326,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031023136,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051158727,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004752419,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028272650875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00350069639375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00105069780312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111246408906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00208992473281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00163034930039,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    int remainder = image.size() % size;\n\n    int localStart = rank * localImageSize;\n    int localEnd = localStart + localImageSize;\n    if (rank == size - 1) {\n        localEnd += remainder;\n    }\n\n    for (int i = localStart; i < localEnd; i++) {\n        localBins[image[i]]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018826756,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027641018,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015986107,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00302860355,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001913431425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007315267,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00119328278125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029154221875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032479316094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000266276475,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00054203813086,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_start = rank * (image.size() / size);\n    int local_end = (rank == size - 1) ? image.size() : (rank + 1) * (image.size() / size);\n\n    for (int i = local_start; i < local_end; i++) {\n        local_bins[image[i]]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018944256,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029789538,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017188811,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00318047825,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001879069025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007727177125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131885468125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027797088125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029733375625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00035899331016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150328056016,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    std::vector<int> localImage(localImageSize);\n    MPI_Scatter(image.data(), localImageSize, MPI_INT, localImage.data(), localImageSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : localImage) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018862486,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036162376,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035330865,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0057965364,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050575638,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026808186375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00375926199375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00134899215312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00094193978438,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109962592422,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00112513774766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_image_size = image.size() / size;\n    std::vector<int> local_image(local_image_size);\n    MPI_Scatter(image.data(), local_image_size, MPI_INT, local_image.data(), local_image_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : local_image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018579474,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003446711,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032719516,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045789689,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00500150335,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021092526,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028356206875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107246348125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00096325184531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00254425843672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00147890536289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    for (auto const& pixel : image) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018697434,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027347128,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.003297418,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    for (auto const& pixel : image) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018547416,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027380614,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0035778084,
                        "num_procs": 2
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> local_bins = {0};\n\n    int local_image_size = image.size() / size;\n    std::vector<int> local_image(local_image_size);\n    MPI_Scatter(image.data(), local_image_size, MPI_INT, local_image.data(), local_image_size, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : local_image) {\n        local_bins[pixel]++;\n    }\n\n    MPI_Reduce(local_bins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018755222,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036359186,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038915244,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00493415885,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004757703525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0024509449,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029779857,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166045514375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00105604058594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00104971481875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131502923516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    std::vector<int> localImage(localImageSize);\n    MPI_Scatter(image.data(), localImageSize, MPI_INT, localImage.data(), localImageSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : localImage) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00185726,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036656162,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028802037,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050618747,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00465372845,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022710653,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00345629935,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00137374927812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00104565485156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161201048281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015225388418,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n    for (auto const& pixel : image) {\n        localBins[pixel]++;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size; i++) {\n            std::array<size_t, 256> recvBins;\n            MPI_Recv(recvBins.data(), 256, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < 256; j++) {\n                bins[j] += recvBins[j];\n            }\n        }\n    } else {\n        MPI_Send(localBins.data(), 256, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        bins = localBins;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0019032406,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030582528,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029599056,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043272472,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031249576,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049826301125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.178490223625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034938949375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004001596625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00505909561172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00764627071758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    std::vector<int> localImage(localImageSize);\n    MPI_Scatter(image.data(), localImageSize, MPI_INT, localImage.data(), localImageSize, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (auto const& pixel : localImage) {\n        localBins[pixel]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0018579636,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0040608952,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032909775,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00469806275,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00461634935,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002195141425,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002736310025,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131226541875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092307155156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00151717164141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00123002426953,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::array<size_t, 256> localBins = {0};\n\n    int localImageSize = image.size() / size;\n    int remainder = image.size() % size;\n\n    int localStart = rank * localImageSize;\n    int localEnd = localStart + localImageSize;\n    if (rank == size - 1) {\n        localEnd += remainder;\n    }\n\n    for (int i = localStart; i < localEnd; i++) {\n        localBins[image[i]]++;\n    }\n\n    MPI_Reduce(localBins.data(), bins.data(), 256, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00186271,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027216186,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158044,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028715092,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001941093725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008827532875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116679399375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00041020665,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028161691563,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028350355859,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055470533008,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "38_search_find_the_first_even_number",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {",
        "translation_prompt": "// Serial implementation of findFirstEven\n// /* Return the index of the first even number in the vector x.\n//    Examples:\n// \n//    input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n//    output: 6\n// \n//    input: [3, 8, 9, 9, 3, 4, 8, 6]\n//    output: 1\n// */\n// size_t findFirstEven(std::vector<int> const& x) {\n// for (size_t i = 0; i < x.size(); ++i) {\n//     if (x[i] % 2 == 0) {\n//       return i;\n//     }\n//   }\n//   return x.size();\n// }\n\n// MPI implementation of findFirstEven\n#include <mpi.h>\n\n/* Return the index of the first even number in the vector x.\n   Use MPI to parallelize the search. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the index of the first even number in the vector x.\n   Examples:\n\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {\nfor (size_t i = 0; i < x.size(); ++i) {\n    if (x[i] % 2 == 0) {\n      return i;\n    }\n  }\n  return x.size();\n}",
        "translation_function_name": "findFirstEven",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Allreduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003071612,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000250054,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003467359,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152620665,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022152116,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014281344125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00548448856875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00227368101562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00402925494063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00928158424922,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01739720690781,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003067486,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000245191,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002585863,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002277563,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001537795125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010320756875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014358840875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039015179688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00036550207344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028220318281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00051698850391,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000307057,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002689612,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003790356,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00259114635,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001716829125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009211473625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015862624875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004125444375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028203038906,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024655864297,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00056495588789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003068268,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000266677,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002745221,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022327969,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001610154475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000786400975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00131033213125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004111513,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029704988594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025891258516,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00059409512109,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003064958,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000247641,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002882601,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022166494,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00159927775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009150111375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015609679375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00043740364375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032907315469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00026289300547,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055386476094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000306412,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002483246,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004993307,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00241015135,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001525945825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008652624375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00180796423125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00034577652188,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029908482188,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00042223433438,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00064223521992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003073594,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002973786,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003017035,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00254313745,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00179084365,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009958061625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00151096895625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037221735,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027990940312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032061906172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00061720367969,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Allreduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003065682,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002812164,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004335213,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019414636,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002027491275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00144365375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0057496091375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00279659547187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00357163989687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00601497546484,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01045095870938,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Allreduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return global_result;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003076102,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002519238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004931122,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018869729,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002036563425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012428373125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00575638308125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00255872480625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00735350812813,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00636453343516,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01185014878281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003068146,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025967,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000281885,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0025653968,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015845702,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009080009625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014402840375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003787488,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00033725305,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038090407734,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00047054834844,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003068826,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002857072,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004181463,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00230718625,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016976095,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011397617125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001426067,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00034700793125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028464498594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00020710085078,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00054444886484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003066886,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002815914,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002604298,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022638703,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001619829,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001087893,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015455321875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00036422424063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00035392711719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00026299993281,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00052891645625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003065802,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002561252,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003208533,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00225859505,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001339985775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008884284375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015678218375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003733921,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028545870313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025378860625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00064003068633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003067882,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002486796,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005773167,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00223859205,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001491231775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088765975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00145461555625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00041203724063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029746399844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024170561406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00056029277148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003068426,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002602594,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002711762,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020102529,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001714477325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000988603325,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00138782075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00036387239375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030776644219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055990170625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046966812656,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003068242,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002471204,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000250944,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00235740175,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001518728175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001697866975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00132731866875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000343259675,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030088405313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00026411072031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00053477820313,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000307339,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002696746,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004438796,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0023962167,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015231161,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010270889375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013702314375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039432545313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029436644219,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032607992891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00058177322578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003066546,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002548588,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002710716,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00227826615,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015700568,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00154490165,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00141657449375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037021675,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032136478594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024504831797,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049967820273,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003070934,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002470884,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004229792,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00221773095,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00167338315,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0011182904375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013968654875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038913841562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00031347894063,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027278052812,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005929434582,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_result = x.size();\n  size_t global_result;\n\n  for (size_t i = rank; i < x.size(); i += size) {\n    if (x[i] % 2 == 0) {\n      local_result = i;\n      break;\n    }\n  }\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return x.size();\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0003064498,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002514364,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002673977,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00223640605,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162794185,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008644230625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015262154625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039871197813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030811920625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027828441172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00052080302773,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",
        "translation_prompt": "// Serial implementation of contains\n// /* Return true if the vector x contains the value `target`. Return false otherwise.\n//    Examples:\n// \n//    input: x=[1, 8, 2, 6, 4, 6], target=3\n//    output: false\n//    \n//    input: x=[1, 8, 2, 6, 4, 6], target=8\n//    output: true\n// */\n// bool contains(std::vector<int> const& x, int target) {\n// return std::find(x.begin(), x.end(), target)!= x.end();\n// }\n\n// MPI implementation of contains\n#include <mpi.h>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {\nreturn std::find(x.begin(), x.end(), target)!= x.end();\n}",
        "translation_function_name": "contains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000246966,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.65206e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001710598,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00066103665,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001634351525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006869894,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00178788539375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030585000937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00045844496719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00047047783203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00097351387461,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002456032,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.42744e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001217307,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00066144635,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001669878775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006824388,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00123357245625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032334166562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00053860926719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00057986431328,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111636943828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_result = std::find(x.begin(), x.end(), target) != x.end();\n    int global_result;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002974852,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010549,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001012103,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088212645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001570938625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006701372125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012863899125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002884303,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00052422484844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049437170234,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00091071640039,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000244798,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.87706e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.58253e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00087791565,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019255344,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006702225375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012535028,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032377979375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049918559844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00041251339609,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111728158516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000244614,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.50762e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.7849e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00103035485,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161897055,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000715312625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001358662625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002947614,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00058064440156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037781061641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102276968477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_result = std::find(x.begin(), x.end(), target) != x.end();\n    int global_result;\n    MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002942188,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.85364e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001002094,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008057562,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001592533725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004981409125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014987424875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003430002375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00043646955312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00082383060391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00115628766211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002447558,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.91596e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001241553,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00091760155,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00164309455,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00074490785,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014656998125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00031037047187,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00050225547031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00044500145703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102326081914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002446598,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.83e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001614306,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00087706585,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162640105,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0023341294125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00114421524375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029306274688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046197005938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00116707246172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109698593477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = std::find(x.begin(), x.end(), target) != x.end();\n  bool global_result;\n\n  MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000247962,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.67392e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001723521,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006725427,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00165228455,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006790976375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161065556875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000334837,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00044490282187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037192191953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00099514537031,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000244572,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.36322e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.99849e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00101080375,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001572177125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003191144275,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001058294075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00031717715313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00040295444688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00093977906016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00093064870078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002458764,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.63162e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001023345,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008796887,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017361779,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00293769245,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001321606075,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00017717436563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039928275469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049744747188,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00114502770234,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000246928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.91474e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001040216,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010962877,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001620474325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006749599125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088080441875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037384601875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00066189950469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000531146575,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00104871458516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002503628,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.7258e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000110585,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000986718,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001588860175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00075006185,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111795170625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029230079375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049421222656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00047942995156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095734699023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002465776,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.95642e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001153979,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00089548545,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00174581055,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00080228795,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00123450368125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00032041776875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055704550781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00064075096953,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00122155556289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002466514,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.70352e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.59694e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009157356,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00160597385,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0006599208875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00130927895625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00042219533437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005722666375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00052681244688,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110504446289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = std::find(x.begin(), x.end(), target) != x.end();\n  bool global_result;\n\n  MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002431468,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.6436e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.65365e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001072106,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162854825,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026296804375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001236612825,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027836533125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00061849178281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00077790748125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00098275944414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n  bool global_result;\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002446074,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.61962e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.76478e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008802776,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161197835,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000805596525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014474244125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00022682928437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00037410115937,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00060299236406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00101518995742,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0002465554,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.77668e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000137655,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015201479,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015971595,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032258360875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013410878875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00028967699688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00051173980156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046752182813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00100805361719,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), target) != x.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000245449,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.49668e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001095671,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00099993775,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016614481,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000698358975,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00129895719375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00033322665625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003317147625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003737688125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00104168453477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool local_result = std::find(x.begin(), x.end(), target) != x.end();\n  bool global_result;\n\n  MPI_Reduce(&local_result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.000243287,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.7276e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0001712409,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00100210645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001634959725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00073504235,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001195957325,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00034961043125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00044408660156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038472146875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00100388467383,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "39_search_xor_contains",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {",
        "translation_prompt": "// Serial implementation of xorContains\n// /* Return true if `val` is only in one of vectors x or y.\n//    Return false if it is in both or neither.\n//    Examples:\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n//    output: true\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n//    output: false\n// */\n// bool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n// return std::find(x.begin(), x.end(), val)!= x.end() ^\n//          std::find(y.begin(), y.end(), val)!= y.end();\n// }\n\n// MPI implementation of xorContains\n#include <mpi.h>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Return the result on rank 0.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\nreturn std::find(x.begin(), x.end(), val)!= x.end() ^\n         std::find(y.begin(), y.end(), val)!= y.end();\n}",
        "translation_function_name": "xorContains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.8728e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.07722e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.78897e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00053549525,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001517647525,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005045456625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00182732324375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.663082813e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00022766169687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000121650225,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003054835043,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n\n  if (rank == 0) {\n    bool global_result;\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n    return global_result;\n  } else {\n    MPI_Reduce(&result, nullptr, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.2494e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.4678e-06,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.26071e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00045631805,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015230469,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000445312325,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001917086225,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000121897725,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00050756027812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00011951050625,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00011152529453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.9732e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.3175e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.42185e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00060273405,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001503108975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005488207875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019238346375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.720329687e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00057597817812,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010367037812,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00016031121367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n\n    if (rank == 0) {\n        bool global_result;\n        MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n        return global_result;\n    } else {\n        MPI_Reduce(&result, nullptr, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.033e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.00428e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.56655e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000367231,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001583519325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004194491375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00178124398125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.231491875e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00042011071406,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00027082696562,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00025450436406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.8508e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.09904e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.79126e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00058737125,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153586695,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000519032775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00169766341875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010445469375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00042416660938,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00012440747734,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00019272056445,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.0192e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.06056e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.18772e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00053632385,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153155355,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005631927625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018629803125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.919928125e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005829209625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00011731531406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00019781688789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result_local = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool result_global;\n\n    MPI_Reduce(&result_local, &result_global, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return result_global;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.8366e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.04276e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.77525e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00060412715,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001520337275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005217710375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001915861825,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095607937813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000256918575,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00012951739375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00015807269336,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.855e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.04518e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.84196e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002581998,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150546915,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005687289875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001899068725,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010292473438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024841105781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00121912021641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00015929203516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.8726e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.4092e-06,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.706e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00014542285,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001510405775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000511262175,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166974358125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010756545938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038986445469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00013774688906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00017389301445,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result_local = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool result_global;\n\n    MPI_Reduce(&result_local, &result_global, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return result_global;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.933e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.29726e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.68586e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005811081,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001488355325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004732482875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192869753125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010934086875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00055551584531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00011407432969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00016003863008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n  bool global_result;\n\n  MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    return global_result;\n  } else {\n    return false;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.3858e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.2359e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.80084e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0002479144,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001568338925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005002945375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018879822375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 8.143381563e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00041670613125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029928916641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010659767773,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 8.2696e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.19842e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.73416e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038045155,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001562111275,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004792394625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017775726,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010520469375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00039730445,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00035796820391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00016748181836,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.8708e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.11608e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.83255e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00069660925,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001552350725,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005479650125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00175129076875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.574156562e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00033626815469,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010503079062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00029056121133,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.953e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.4002e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.8144e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005715015,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001543991625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005004330125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017274956375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00012680878438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003979288875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00036962520312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010747417187,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.0792e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.3189e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.74757e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000605604,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00157891065,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004262637375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017421326125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00011562315,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00060162385313,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00030741201172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00016925197617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result_local = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n\n    bool result_global;\n    MPI_Reduce(&result_local, &result_global, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return result_global;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.1854e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.15176e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.03494e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00068672955,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152408185,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0004306814875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00168647593125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.336173438e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00031518207656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00115250269766,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00044867804922,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.9208e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.08766e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.83484e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00038177395,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015308119,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005711969875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152193178125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.895690625e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00023224890312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010502896719,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00014240666328,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool global_result;\n\n    MPI_Reduce(&result, &global_result, 1, MPI_CXX_BOOL, MPI_LXOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_result;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.031e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.14256e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.93184e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003425362,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001596562025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00046094065,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00188701354375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 9.916436875e-05,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00024805407344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00034955828359,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00019593589258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result_local = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool result_global;\n\n    MPI_Reduce(&result_local, &result_global, 1, MPI_CXX_BOOL, MPI_LAND, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return result_global;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 7.0914e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.2788e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.47274e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007083327,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00149443605,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.000559866025,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018401584875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010555085312,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00049362121094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00023060943906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00019032601094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    bool result_local = std::find(x.begin(), x.end(), val) != x.end() ^ std::find(y.begin(), y.end(), val) != y.end();\n    bool result_global;\n\n    MPI_Reduce(&result_local, &result_global, 1, MPI_CXX_BOOL, MPI_LOR, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return result_global;\n    } else {\n        return false;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 6.859e-06,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.18022e-05,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 1.75027e-05,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003771388,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00147481745,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0005000297375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00176260891875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00010337644375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0003566511125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00013636419062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00015415514766,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "35_search_search_for_last_struct_by_key",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {",
        "translation_prompt": "// Serial implementation of findLastShortBook\n// struct Book {\n//    std::string title;\n//    int pages;\n// };\n// \n// /* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n// \t Example:\n// \n//    input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n//    output: 2\n// */\n// size_t findLastShortBook(std::vector<Book> const& books) {\n// size_t last_short_book_index = 0;\n//    for (size_t i = 0; i < books.size(); ++i) {\n//       if (books[i].pages < 100) {\n//          last_short_book_index = i;\n//       }\n//    }\n//    return last_short_book_index;\n// }\n\n// MPI implementation of findLastShortBook\n#include <mpi.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use MPI to search in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of books. Return the result on rank 0.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(std::vector<Book> const& books) {\nsize_t last_short_book_index = 0;\n   for (size_t i = 0; i < books.size(); ++i) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n   return last_short_book_index;\n}",
        "translation_function_name": "findLastShortBook",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0028525344,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031933126,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027865915,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00499506515,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002655400025,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001705359525,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001772222675,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00185177204687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00151804250781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00172177857031,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107632344258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or any other value, as only rank 0 returns the result\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0026083438,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037512294,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030672488,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050903354,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002505074675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00146433435,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016030516625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00122489898438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118188144531,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00190608924375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088340291055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.00282458,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033755014,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0048663075,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046854611,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003948860675,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014632752875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00174048595,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00139170195,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001487732575,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00138411991875,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00090112529883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // Return 0 on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0025873644,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043047816,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003012542,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053000526,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00253277085,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013127023375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00166373373125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150873827812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016332278125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00208724241641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092014943828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0027013984,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003192912,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043996726,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00461840535,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003540859225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0018291732125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019208176,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00121258965938,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00165929548594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00160596319375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110421956367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // Return a default value on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0027607998,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032360352,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029025491,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00473354405,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002505848225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013904168625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00216502663125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00134265770625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00107337628594,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00251243326094,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00077468627461,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or any other value, as only rank 0 returns the result\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0026755398,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033102506,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002872342,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00423948765,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002734722925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012840316375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015870549625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00151802900625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00114762350937,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00129346021406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00083274232773,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002741658,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031785654,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0056383362,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004584586,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027067737,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00135770315,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00243411051875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0013860478125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00144718180781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00152213990156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00117568733984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // Placeholder return for non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002942498,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0032008752,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028958346,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00464881875,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002430564975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00132607545,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001856797575,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007989013,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00171365576094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00224873098203,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088392253633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   size_t global_last_short_book_index;\n   MPI_Reduce(&last_short_book_index, &global_last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return global_last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0030803928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031828372,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027929234,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00442935645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002623545475,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00136519735,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00146653711875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00140121189062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00126429761875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00222241491016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00093593262617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0027668114,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003166098,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005815062,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00443757965,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00415445295,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014147113875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016818293125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00144352446875,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00184815532031,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00142631661172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00130789719883,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // or some other value to indicate no result\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0028003166,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033792602,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028526996,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004474075,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002457206075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001362882625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00194501035,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00136951829687,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0010877365125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00138281584844,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0009480742125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // Return a dummy value on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002593502,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035182954,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028793884,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00531813325,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002287590375,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012867143,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016910609375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001363129525,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00201075021875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00204663037578,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110286990508,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0026871278,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037952864,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028905332,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00459990935,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00269273875,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00167128165,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00179880518125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118100329063,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00106722019844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00156976167891,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00088872274102,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.002508562,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00398994,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0028549575,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045899626,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002565889425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012922976125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00165615819375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0017808895125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00153882258125,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00177519968125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00111733995039,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // Return 0 for non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0029228466,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003279633,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005183364,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047572708,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002639369225,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001693732725,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00165561630625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110418878437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161708919375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00188846500469,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00098571120117,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0;  // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0024720014,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034001618,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046770318,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0050010284,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002454234925,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0012386560625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00155244193125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00137602636562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00109116332187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00141730658125,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00082735297617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   size_t global_last_short_book_index;\n   MPI_Reduce(&last_short_book_index, &global_last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return global_last_short_book_index;\n   } else {\n      return 0;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0025491204,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039535756,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0041253048,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0053052601,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00311770125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001292162775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001668923125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00126486607812,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00134587535781,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001681377975,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00141339331328,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   size_t local_last_short_book_index = 0;\n\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         local_last_short_book_index = i;\n      }\n   }\n\n   MPI_Reduce(&local_last_short_book_index, &last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return last_short_book_index;\n   } else {\n      return 0; // or some other value to indicate no result on non-root ranks\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0028356826,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031597814,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027810332,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0044358671,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002978632075,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0014392446625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015643093375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00150312904062,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00151689782344,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00200578607969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008615863625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   size_t last_short_book_index = 0;\n   for (size_t i = rank; i < books.size(); i += size) {\n      if (books[i].pages < 100) {\n         last_short_book_index = i;\n      }\n   }\n\n   size_t global_last_short_book_index;\n   MPI_Reduce(&last_short_book_index, &global_last_short_book_index, 1, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      return global_last_short_book_index;\n   } else {\n      return 0;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0028599104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031840694,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0027948074,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00451275105,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0025608898,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015221409625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019515302625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00157998209688,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00118601190156,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00192755130156,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00110069110156,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "37_search_find_the_closest_number_to_pi",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {",
        "translation_prompt": "// Serial implementation of findClosestToPi\n// /* Return the index of the value in the vector x that is closest to the math constant PI.\n//    Use M_PI for the value of PI.\n//    Example:\n// \n//    input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n//    output: 1\n// */\n// size_t findClosestToPi(std::vector<double> const& x) {\n// double min_distance = std::numeric_limits<double>::max();\n//   size_t min_index = 0;\n//   for (size_t i = 0; i < x.size(); ++i) {\n//     double distance = std::abs(x[i] - M_PI);\n//     if (distance < min_distance) {\n//       min_distance = distance;\n//       min_index = i;\n//     }\n//   }\n//   return min_index;\n// }\n\n// MPI implementation of findClosestToPi\n#include <mpi.h>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Use MPI to search in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(std::vector<double> const& x) {\ndouble min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < min_distance) {\n      min_distance = distance;\n      min_index = i;\n    }\n  }\n  return min_index;\n}",
        "translation_function_name": "findClosestToPi",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013018104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019578892,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020164912,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00417985725,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038154837,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031064237,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0087373622,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00704657754375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01130858332656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01667645667969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01830787664414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013022014,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001959747,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020306377,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035375142,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003971932975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003400670875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00940293733125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00546663840313,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.010539876275,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01455136839141,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01807326236133,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013042988,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019612616,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020863744,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00319692495,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004311032975,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033561948125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0099148562,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00590542278437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01675257519687,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0149390525375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02004559794258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013035434,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019646598,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022915203,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00359375435,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00419814965,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045216530625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00867329005,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00621951656562,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01037819792656,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01066856781641,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01876362915703,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001317596,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002067876,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0026112352,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0038165719,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004045245425,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003998341675,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01050487811875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00675124129375,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01001586294688,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01306718831172,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01702344622852,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0012995142,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019562862,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0041071166,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0043041281,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037366358,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033649964,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00816108504375,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00631380290625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01056697550625,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01042737799609,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02035667416367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013002674,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001962133,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022792842,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00316086365,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003952527125,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003809014275,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0084446086,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00705083512813,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0102109585375,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01869434840703,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01922111659219,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0012988888,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019639566,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022387289,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0037981597,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00446971885,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00285184925,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00987508165625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0074753235,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01026928102187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01612728677656,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02011508593516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013017404,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019618048,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020230635,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00366490615,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003751462325,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0031048752125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0080914698125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006002670675,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0116383742875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01343832489453,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01910066986367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013055052,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019664492,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0023197293,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00393582935,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00423990435,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0033291157,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009006186525,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00653575213438,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0125885214,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00925789546406,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0204037426707,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013161232,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020044208,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002070183,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0034910553,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00357454255,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0035850174625,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.009679168175,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.006717706625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01181817276719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01218362905312,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01737612919375,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001346843,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020045466,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022040198,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00320212625,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004034718775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0030963162875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0089912446125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00586227653125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01091150091094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0098893813,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01841612099414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013015398,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001962592,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021402508,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00367276175,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003957915625,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00367304775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00835081735,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00654232770937,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00961648971719,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01482297062969,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01595345529648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001302652,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019655216,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020246876,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00353367975,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00408631305,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0051038321875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0082417539625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00713343013437,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00918783127969,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01268289540391,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01955300751094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013018804,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019559196,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022963136,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0039221007,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003675363175,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036075939,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00877905181875,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066344561125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01059046792187,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01078567269063,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02301672309453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013166684,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019741198,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020208965,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00352372195,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00380613455,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003670845875,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00922933960625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00698131093125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01057508394844,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01034981933672,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02089301501133,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Reduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.001302201,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019610974,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020172698,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00427872435,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003487472775,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00265152115,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0029482315,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00264744695625,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00386433331094,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00405572168906,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0063910771207,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013515,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.001967375,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0022505343,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036560866,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.003680029,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036039543125,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0086530063625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00697438096563,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01050960496875,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0179285945375,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01886404710078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  size_t local_min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Allreduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);\n  MPI_Allreduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013013018,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019932578,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0021813572,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00315755715,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036479127,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00367911775,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00934678993125,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.005610993125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01229967793281,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01228395036016,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.02397507810859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  double min_distance = std::numeric_limits<double>::max();\n  size_t min_index = 0;\n  double local_min_distance = std::numeric_limits<double>::max();\n  size_t local_min_index = 0;\n\n  for (size_t i = 0; i < x.size(); ++i) {\n    double distance = std::abs(x[i] - M_PI);\n    if (distance < local_min_distance) {\n      local_min_distance = distance;\n      local_min_index = i;\n    }\n  }\n\n  MPI_Reduce(&local_min_distance, &min_distance, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);\n  MPI_Reduce(&local_min_index, &min_index, 1, MPI_UNSIGNED_LONG, MPI_MIN, 0, MPI_COMM_WORLD);\n\n  return min_index;\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0013013996,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0019596944,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0020410062,
                        "num_procs": 2
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00428250645,
                        "num_procs": 4
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0036484864,
                        "num_procs": 8
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.002746767375,
                        "num_procs": 16
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00339491255625,
                        "num_procs": 32
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00264479203125,
                        "num_procs": 64
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00298525360312,
                        "num_procs": 128
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00338970484062,
                        "num_procs": 256
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00638280758203,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "08_fft_split_fft",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {",
        "translation_prompt": "// Serial implementation of fft\n// /* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n// */\n// void fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n// int n = x.size();\n//     if (n == 0) return;\n//     if (n == 1) {\n//         r[0] = x[0].real();\n//         i[0] = x[0].imag();\n//         return;\n//     }\n//     std::vector<std::complex<double>> x_even(n / 2);\n//     std::vector<std::complex<double>> x_odd(n / 2);\n//     for (int i = 0; i < n / 2; i++) {\n//         x_even[i] = x[2 * i];\n//         x_odd[i] = x[2 * i + 1];\n//     }\n//     std::vector<double> r_even(n / 2);\n//     std::vector<double> i_even(n / 2);\n//     std::vector<double> r_odd(n / 2);\n//     std::vector<double> i_odd(n / 2);\n//     fft(x_even, r_even, i_even);\n//     fft(x_odd, r_odd, i_odd);\n//     for (int k = 0; k < n / 2; k++) {\n//         std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n//         r[k] = r_even[k] + z.real();\n//         i[k] = i_even[k] + z.imag();\n//         r[k + n / 2] = r_even[k] - z.real();\n//         i[k + n / 2] = i_even[k] - z.imag();\n//     }\n// }\n\n// MPI implementation of fft\n#include <mpi.h>\n\n/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\nint n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x[2 * i];\n        x_odd[i] = x[2 * i + 1];\n    }\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n}",
        "translation_function_name": "fft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r_local[0] = x_local[0].real();\n        i_local[0] = x_local[0].imag();\n    } else {\n        std::vector<std::complex<double>> x_even(n / 2);\n        std::vector<std::complex<double>> x_odd(n / 2);\n        for (int i = 0; i < n / 2; i++) {\n            x_even[i] = x_local[2 * i];\n            x_odd[i] = x_local[2 * i + 1];\n        }\n        std::vector<double> r_even(n / 2);\n        std::vector<double> i_even(n / 2);\n        std::vector<double> r_odd(n / 2);\n        std::vector<double> i_odd(n / 2);\n\n        fft(x_even, r_even, i_even);\n        fft(x_odd, r_odd, i_odd);\n\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r_local[k] = r_even[k] + z.real();\n            i_local[k] = i_even[k] + z.imag();\n            r_local[k + n / 2] = r_even[k] - z.real();\n            i_local[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.060578581,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3337372444,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r[0] = x_local[0].real();\n        i[0] = x_local[0].imag();\n        MPI_Gather(r.data(), 1, MPI_DOUBLE, r.data(), 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Gather(i.data(), 1, MPI_DOUBLE, i.data(), 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        return;\n    }\n\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x_local[2 * i];\n        x_odd[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r[k] = r_even[k] + z.real();\n        i[k] = i_even[k] + z.imag();\n        r[k + n / 2] = r_even[k] - z.real();\n        i[k + n / 2] = i_even[k] - z.imag();\n    }\n\n    MPI_Gather(r.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0777431708,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2605717526,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n / 2);\n    std::vector<std::complex<double>> x_odd(local_n / 2);\n    for (int i = 0; i < local_n / 2; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n / 2);\n    std::vector<double> i_even(local_n / 2);\n    std::vector<double> r_odd(local_n / 2);\n    std::vector<double> i_odd(local_n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    for (int k = 0; k < local_n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * (rank * local_n / n + k) / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        local_r[k] = r_even[k] + z.real();\n        local_i[k] = i_even[k] + z.imag();\n        local_r[k + local_n / 2] = r_even[k] - z.real();\n        local_i[k + local_n / 2] = i_even[k] - z.imag();\n    }\n\n    MPI_Gather(local_r.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(local_i.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0606530584,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2559706838,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.02197010679453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> x_local(local_n);\n    std::vector<double> r_local(local_n);\n    std::vector<double> i_local(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, x_local.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n / 2);\n    std::vector<std::complex<double>> x_odd(local_n / 2);\n    for (int i = 0; i < local_n / 2; i++) {\n        x_even[i] = x_local[2 * i];\n        x_odd[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n / 2);\n    std::vector<double> i_even(local_n / 2);\n    std::vector<double> r_odd(local_n / 2);\n    std::vector<double> i_odd(local_n / 2);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_local.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0613670474,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2539849978,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n);\n    std::vector<std::complex<double>> x_odd(local_n);\n    for (int i = 0; i < local_n; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n);\n    std::vector<double> i_even(local_n);\n    std::vector<double> r_odd(local_n);\n    std::vector<double> i_odd(local_n);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_even.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x_local[2 * i];\n        x_odd[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    for (int k = 0; k < n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        r_local[k] = r_even[k] + z.real();\n        i_local[k] = i_even[k] + z.imag();\n        r_local[k + n / 2] = r_even[k] - z.real();\n        i_local[k + n / 2] = i_even[k] - z.imag();\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0610787248,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2553453106,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n);\n    std::vector<std::complex<double>> x_odd(local_n);\n    for (int i = 0; i < local_n; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n);\n    std::vector<double> i_even(local_n);\n    std::vector<double> r_odd(local_n);\n    std::vector<double> i_odd(local_n);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_even.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n);\n    std::vector<std::complex<double>> x_odd(local_n);\n    for (int i = 0; i < local_n; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n);\n    std::vector<double> i_even(local_n);\n    std::vector<double> r_odd(local_n);\n    std::vector<double> i_odd(local_n);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_even.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r_local[0] = x_local[0].real();\n        i_local[0] = x_local[0].imag();\n    } else {\n        std::vector<std::complex<double>> x_even(n / 2);\n        std::vector<std::complex<double>> x_odd(n / 2);\n        for (int i = 0; i < n / 2; i++) {\n            x_even[i] = x_local[2 * i];\n            x_odd[i] = x_local[2 * i + 1];\n        }\n        std::vector<double> r_even(n / 2);\n        std::vector<double> i_even(n / 2);\n        std::vector<double> r_odd(n / 2);\n        std::vector<double> i_odd(n / 2);\n\n        fft(x_even, r_even, i_even);\n        fft(x_odd, r_odd, i_odd);\n\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r_local[k] = r_even[k] + z.real();\n            i_local[k] = i_even[k] + z.imag();\n            r_local[k + n / 2] = r_even[k] - z.real();\n            i_local[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.061101357,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3112673668,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r[0] = x_local[0].real();\n        i[0] = x_local[0].imag();\n        return;\n    }\n\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even[i] = x_local[2 * i];\n        x_odd[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_even(n / 2);\n    std::vector<double> i_even(n / 2);\n    std::vector<double> r_odd(n / 2);\n    std::vector<double> i_odd(n / 2);\n\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    std::vector<double> r_combined(n);\n    std::vector<double> i_combined(n);\n    MPI_Gather(r_even.data(), n / 2, MPI_DOUBLE, r_combined.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even.data(), n / 2, MPI_DOUBLE, i_combined.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(r_odd.data(), n / 2, MPI_DOUBLE, r_combined.data() + n / 2, n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_odd.data(), n / 2, MPI_DOUBLE, i_combined.data() + n / 2, n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_combined[k + n / 2], i_combined[k + n / 2]);\n            r[k] = r_combined[k] + z.real();\n            i[k] = i_combined[k] + z.imag();\n            r[k + n / 2] = r_combined[k] - z.real();\n            i[k + n / 2] = i_combined[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.096810578,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2966102566,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n / 2);\n    std::vector<std::complex<double>> x_odd(local_n / 2);\n    for (int i = 0; i < local_n / 2; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n / 2);\n    std::vector<double> i_even(local_n / 2);\n    std::vector<double> r_odd(local_n / 2);\n    std::vector<double> i_odd(local_n / 2);\n\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    for (int k = 0; k < local_n / 2; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * (rank * local_n / n + k) / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        local_r[k] = r_even[k] + z.real();\n        local_i[k] = i_even[k] + z.imag();\n        local_r[k + local_n / 2] = r_even[k] - z.real();\n        local_i[k + local_n / 2] = i_even[k] - z.imag();\n    }\n\n    MPI_Gather(local_r.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(local_i.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0608879308,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.253628016,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.03174866635586,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    fft(local_x, local_r, local_i);\n    std::vector<double> all_r(n);\n    std::vector<double> all_i(n);\n    MPI_Gather(local_r.data(), local_n, MPI_DOUBLE, all_r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(local_i.data(), local_n, MPI_DOUBLE, all_i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    if (rank == 0) {\n        for (int k = 0; k < n; k++) {\n            r[k] = all_r[k];\n            i[k] = all_i[k];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r_local[0] = x_local[0].real();\n        i_local[0] = x_local[0].imag();\n    } else {\n        std::vector<std::complex<double>> x_even(n / 2);\n        std::vector<std::complex<double>> x_odd(n / 2);\n        for (int i = 0; i < n / 2; i++) {\n            x_even[i] = x_local[2 * i];\n            x_odd[i] = x_local[2 * i + 1];\n        }\n        std::vector<double> r_even(n / 2);\n        std::vector<double> i_even(n / 2);\n        std::vector<double> r_odd(n / 2);\n        std::vector<double> i_odd(n / 2);\n\n        fft(x_even, r_even, i_even);\n        fft(x_odd, r_odd, i_odd);\n\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r_local[k] = r_even[k] + z.real();\n            i_local[k] = i_even[k] + z.imag();\n            r_local[k + n / 2] = r_even[k] - z.real();\n            i_local[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0611873428,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3162118334,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r_local[0] = x_local[0].real();\n        i_local[0] = x_local[0].imag();\n    } else {\n        std::vector<std::complex<double>> x_even(n / 2);\n        std::vector<std::complex<double>> x_odd(n / 2);\n        for (int i = 0; i < n / 2; i++) {\n            x_even[i] = x_local[2 * i];\n            x_odd[i] = x_local[2 * i + 1];\n        }\n        std::vector<double> r_even(n / 2);\n        std::vector<double> i_even(n / 2);\n        std::vector<double> r_odd(n / 2);\n        std::vector<double> i_odd(n / 2);\n\n        fft(x_even, r_even, i_even);\n        fft(x_odd, r_odd, i_odd);\n\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r_local[k] = r_even[k] + z.real();\n            i_local[k] = i_even[k] + z.imag();\n            r_local[k + n / 2] = r_even[k] - z.real();\n            i_local[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0591146594,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3232408194,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n);\n    std::vector<std::complex<double>> x_odd(local_n);\n    for (int i = 0; i < local_n; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n);\n    std::vector<double> i_even(local_n);\n    std::vector<double> r_odd(local_n);\n    std::vector<double> i_odd(local_n);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_even.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> x_local(local_n);\n    std::vector<double> r_local(local_n);\n    std::vector<double> i_local(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, x_local.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n / 2);\n    std::vector<std::complex<double>> x_odd(local_n / 2);\n    for (int i = 0; i < local_n / 2; i++) {\n        x_even[i] = x_local[2 * i];\n        x_odd[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n / 2);\n    std::vector<double> i_even(local_n / 2);\n    std::vector<double> r_odd(local_n / 2);\n    std::vector<double> i_odd(local_n / 2);\n\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    MPI_Gather(r_local.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r[k] = r_even[k] + z.real();\n            i[k] = i_even[k] + z.imag();\n            r[k + n / 2] = r_even[k] - z.real();\n            i[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0603280932,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2544322804,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    std::vector<double> r_local(n);\n    std::vector<double> i_local(n);\n\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (n == 1) {\n        r_local[0] = x_local[0].real();\n        i_local[0] = x_local[0].imag();\n    } else {\n        std::vector<std::complex<double>> x_even(n / 2);\n        std::vector<std::complex<double>> x_odd(n / 2);\n        for (int i = 0; i < n / 2; i++) {\n            x_even[i] = x_local[2 * i];\n            x_odd[i] = x_local[2 * i + 1];\n        }\n        std::vector<double> r_even(n / 2);\n        std::vector<double> i_even(n / 2);\n        std::vector<double> r_odd(n / 2);\n        std::vector<double> i_odd(n / 2);\n\n        fft(x_even, r_even, i_even);\n        fft(x_odd, r_odd, i_odd);\n\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(r_odd[k], i_odd[k]);\n            r_local[k] = r_even[k] + z.real();\n            i_local[k] = i_even[k] + z.imag();\n            r_local[k + n / 2] = r_even[k] - z.real();\n            i_local[k + n / 2] = i_even[k] - z.imag();\n        }\n    }\n\n    MPI_Gather(r_local.data(), n, MPI_DOUBLE, r.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n, MPI_DOUBLE, i.data(), n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0643190312,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3171609834,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n    if (n == 1) {\n        r[0] = x[0].real();\n        i[0] = x[0].imag();\n        return;\n    }\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<double> local_r(local_n);\n    std::vector<double> local_i(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even(local_n);\n    std::vector<std::complex<double>> x_odd(local_n);\n    for (int i = 0; i < local_n; i++) {\n        x_even[i] = local_x[2 * i];\n        x_odd[i] = local_x[2 * i + 1];\n    }\n\n    std::vector<double> r_even(local_n);\n    std::vector<double> i_even(local_n);\n    std::vector<double> r_odd(local_n);\n    std::vector<double> i_odd(local_n);\n    fft(x_even, r_even, i_even);\n    fft(x_odd, r_odd, i_odd);\n\n    for (int k = 0; k < local_n; k++) {\n        std::complex<double> z = std::polar(1.0, -2 * M_PI * (rank * local_n + k) / n) * std::complex<double>(r_odd[k], i_odd[k]);\n        local_r[k] = r_even[k] + z.real();\n        local_i[k] = i_even[k] + z.imag();\n        local_r[k + local_n] = r_even[k] - z.real();\n        local_i[k + local_n] = i_even[k] - z.imag();\n    }\n\n    MPI_Gather(local_r.data(), local_n, MPI_DOUBLE, r.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(local_i.data(), local_n, MPI_DOUBLE, i.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even_local(n / 2);\n    std::vector<std::complex<double>> x_odd_local(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even_local[i] = x_local[2 * i];\n        x_odd_local[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_local(n / 2);\n    std::vector<double> i_local(n / 2);\n    fft(x_even_local, r_local, i_local);\n\n    std::vector<double> r_even_local(n / 2);\n    std::vector<double> i_even_local(n / 2);\n    std::vector<double> r_odd_local(n / 2);\n    std::vector<double> i_odd_local(n / 2);\n\n    if (rank == 0) {\n        r_even_local.resize(n / 2 * size);\n        i_even_local.resize(n / 2 * size);\n        r_odd_local.resize(n / 2 * size);\n        i_odd_local.resize(n / 2 * size);\n    }\n\n    MPI_Gather(r_local.data(), n / 2, MPI_DOUBLE, r_even_local.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n / 2, MPI_DOUBLE, i_even_local.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            for (int j = 1; j < size; j++) {\n                std::complex<double> z = std::polar(1.0, -2 * M_PI * (k + j * n / 2) / n) * std::complex<double>(r_odd_local[k + j * n / 2], i_odd_local[k + j * n / 2]);\n                r_even_local[k + j * n / 2] = r_even_local[k] + z.real();\n                i_even_local[k + j * n / 2] = i_even_local[k] + z.imag();\n                r_even_local[k] = r_even_local[k] - z.real();\n                i_even_local[k] = i_even_local[k] - z.imag();\n            }\n        }\n    }\n\n    if (rank == 0) {\n        r.resize(n);\n        i.resize(n);\n    }\n\n    MPI_Gather(r_even_local.data(), n / 2, MPI_DOUBLE, r.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_even_local.data(), n / 2, MPI_DOUBLE, i.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0839963942,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.012313304,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (n == 0) return;\n\n    std::vector<std::complex<double>> x_local(n);\n    MPI_Scatter(x.data(), n, MPI_DOUBLE_COMPLEX, x_local.data(), n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::vector<std::complex<double>> x_even_local(n / 2);\n    std::vector<std::complex<double>> x_odd_local(n / 2);\n    for (int i = 0; i < n / 2; i++) {\n        x_even_local[i] = x_local[2 * i];\n        x_odd_local[i] = x_local[2 * i + 1];\n    }\n\n    std::vector<double> r_local(n / 2);\n    std::vector<double> i_local(n / 2);\n    fft(x_even_local, r_local, i_local);\n\n    std::vector<double> r_odd_local(n / 2);\n    std::vector<double> i_odd_local(n / 2);\n    MPI_Gather(r_local.data(), n / 2, MPI_DOUBLE, r.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    MPI_Gather(i_local.data(), n / 2, MPI_DOUBLE, i.data(), n / 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        for (int k = 0; k < n / 2; k++) {\n            std::complex<double> z = std::polar(1.0, -2 * M_PI * k / n) * std::complex<double>(i.data()[k], r.data()[k]);\n            r.data()[k] = r.data()[k + n / 2] + z.real();\n            i.data()[k] = i.data()[k + n / 2] + z.imag();\n            r.data()[k + n / 2] = r.data()[k + n / 2] - z.real();\n            i.data()[k + n / 2] = i.data()[k + n / 2] - z.imag();\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0720210442,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.020578767,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "07_fft_fft_conjugate",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of fftConjugate\n// /* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n// */\n// void fftConjugate(std::vector<std::complex<double>> &x) {\n// int n = x.size();\n//     int m = 0;\n//     for (int i = 0; i < n; i++) {\n//         int j = i;\n//         for (int k = 0; k < m; k++) {\n//             j = j ^ (1 << k);\n//         }\n//         if (i < j) {\n//             std::complex<double> temp = x[i];\n//             x[i] = x[j];\n//             x[j] = temp;\n//         }\n//         m = std::max(m, __builtin_ctz(j));\n//     }\n//     for (int i = 1; i < n; i *= 2) {\n//         std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n//         for (int j = 0; j < n; j += 2 * i) {\n//             for (int k = 0; k < i; k++) {\n//                 std::complex<double> u = x[j + k];\n//                 std::complex<double> t = w * x[j + k + i];\n//                 x[j + k] = u + t;\n//                 x[j + k + i] = u - t;\n//             }\n//             w = w * w;\n//         }\n//     }\n// }\n\n// MPI implementation of fftConjugate\n#include <mpi.h>\n\n/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the fourier transform of x in-place. Return the imaginary conjugate of each value.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fftConjugate(std::vector<std::complex<double>> &x) {\nint n = x.size();\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n}",
        "translation_function_name": "fftConjugate",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, result.data(), n * 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.082956446,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0562860382,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(n);\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0] + i * (n / size), n / size, MPI_DOUBLE_COMPLEX, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Send(&x[rank * (n / size)], n / size, MPI_DOUBLE_COMPLEX, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0834207046,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.056002517,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * 2 * i; j < n; j += 2 * i * size) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, x.data(), n, MPI_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n        for (int k = 0; k < i; k++) {\n            w = w * w;\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0836446886,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0152255538,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, result.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0861670874,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0572390436,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank; j < n; j += size) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n    }\n\n    if (rank != 0) {\n        MPI_Send(x.data(), n * sizeof(std::complex<double>), MPI_BYTE, 0, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<std::complex<double>> temp(n);\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(temp.data(), n * sizeof(std::complex<double>), MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = 0; j < n; j++) {\n                x[j] += temp[j];\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Allgather(MPI_IN_PLACE, (n / size), MPI_DOUBLE_COMPLEX, &x[0], (n / size), MPI_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n        w = w * w;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0962052314,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0184661256,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Allgather(MPI_IN_PLACE, (n / size), MPI_COMPLEX, &x[0], (n / size), MPI_COMPLEX, MPI_COMM_WORLD);\n        w = w * w;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0842840692,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01621858,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int n = x.size();\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, result.data(), n * 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1022935618,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0761881902,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(n);\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0] + i * (n / size), n / size, MPI_DOUBLE_COMPLEX, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Send(&x[rank * (n / size)], n / size, MPI_DOUBLE_COMPLEX, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1017165618,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0676557746,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, result.data(), n * 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, nullptr, 0, MPI_DATATYPE_NULL, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0850417258,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0562642214,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(n);\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&recvbuf[0] + i * (n / size), n / size, MPI_DOUBLE_COMPLEX, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Send(&x[rank * (n / size)], n / size, MPI_DOUBLE_COMPLEX, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0812321758,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0560544276,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank; j < n; j += size) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n        if (rank == 0) {\n            for (int p = 1; p < size; p++) {\n                std::vector<std::complex<double>> recv_buf(n);\n                MPI_Recv(&recv_buf[0], n * 2, MPI_DOUBLE, p, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                for (int j = p; j < n; j += size) {\n                    x[j] = recv_buf[j];\n                }\n            }\n        } else {\n            MPI_Send(&x[0], n * 2, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        }\n        MPI_Barrier(MPI_COMM_WORLD);\n    }\n\n    if (rank == 0) {\n        for (int p = 1; p < size; p++) {\n            std::vector<std::complex<double>> recv_buf(n);\n            MPI_Recv(&recv_buf[0], n * 2, MPI_DOUBLE, p, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n            for (int j = p; j < n; j += size) {\n                x[j] = recv_buf[j];\n            }\n        }\n    } else {\n        MPI_Send(&x[0], n * 2, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, result.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0836387092,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0598346096,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, result.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n / size, MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0898835964,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.063133736,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // ... (rest of the code remains the same, but applied to local_x instead of x)\n\n    MPI_Gather(local_x.data(), local_n, MPI_DOUBLE_COMPLEX, x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0836778664,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0011340046,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank * (n / size); j < (rank + 1) * (n / size); j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Allgather(MPI_IN_PLACE, (n / size), MPI_DOUBLE_COMPLEX, &x[0], (n / size), MPI_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n        w = w * w;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0788248168,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0162645824,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = rank; j < n; j += size) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n        }\n        MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, x.data(), n, MPI_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n        w = w * w;\n    }\n\n    if (rank == 0) {\n        for (int i = 0; i < n; i++) {\n            x[i] = std::conj(x[i]);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(n);\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, result.data(), n * 2, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), n * 2, MPI_DOUBLE, NULL, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0789759318,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0553761956,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int m = 0;\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = x[i];\n            x[i] = x[j];\n            x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = x[j + k];\n                std::complex<double> t = w * x[j + k + i];\n                x[j + k] = u + t;\n                x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0817716396,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0553045154,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    int m = 0;\n    for (int i = 0; i < local_n; i++) {\n        int j = i;\n        for (int k = 0; k < m; k++) {\n            j = j ^ (1 << k);\n        }\n        if (i < j) {\n            std::complex<double> temp = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = temp;\n        }\n        m = std::max(m, __builtin_ctz(j));\n    }\n\n    for (int i = 1; i < n; i *= 2) {\n        std::complex<double> w = std::polar(1.0, -2 * M_PI / i);\n        for (int j = 0; j < local_n; j += 2 * i) {\n            for (int k = 0; k < i; k++) {\n                std::complex<double> u = local_x[j + k];\n                std::complex<double> t = w * local_x[j + k + i];\n                local_x[j + k] = u + t;\n                local_x[j + k + i] = u - t;\n            }\n            w = w * w;\n        }\n    }\n\n    MPI_Gather(local_x.data(), local_n, MPI_DOUBLE_COMPLEX, x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0807778278,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0581701776,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "05_fft_inverse_fft",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of ifft\n// /* forward declare fft. computes fourier transform in-place */\n// void fft(std::vector<std::complex<double>> &x);\n// \n// /* Compute the inverse fourier transform of x in-place.\n//    Example:\n//    \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n// */\n// void ifft(std::vector<std::complex<double>> &x) {\n// \n// // Take conjugate of the complex numbers\n// for (auto &elem : x) {\n//     elem = std::conj(elem);\n// }\n// \n// // Apply fft\n// fft(x);\n// \n// // Take conjugate again\n// for (auto &elem : x) {\n//     elem = std::conj(elem);\n// }\n// \n// // Scale the numbers\n// for (auto &elem : x) {\n//     elem /= static_cast<double>(x.size());\n// }\n// }\n\n// MPI implementation of ifft\n#include <mpi.h>\n\n/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. The final result is stored on rank 0.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* forward declare fft. computes fourier transform in-place */\nvoid fft(std::vector<std::complex<double>> &x);\n\n/* Compute the inverse fourier transform of x in-place.\n   Example:\n   \n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{0.5,0}, {0.125,0.301777}, {0,-0}, {0.125,0.0517767}, {0,-0}, {0.125,-0.0517767}, {0,-0}, {0.125,-0.301777}]\n*/\nvoid ifft(std::vector<std::complex<double>> &x) {\n\n// Take conjugate of the complex numbers\nfor (auto &elem : x) {\n    elem = std::conj(elem);\n}\n\n// Apply fft\nfft(x);\n\n// Take conjugate again\nfor (auto &elem : x) {\n    elem = std::conj(elem);\n}\n\n// Scale the numbers\nfor (auto &elem : x) {\n    elem /= static_cast<double>(x.size());\n}\n}",
        "translation_function_name": "ifft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.036324691,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0374615028,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers in parallel\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Reduce(x.data(), result.data(), x.size() * 2, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Reduce(x.data(), nullptr, x.size() * 2, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0369570088,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0389965314,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.05840558172734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0368809138,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0368483968,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers in parallel\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    // Gather results on rank 0\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0372833006,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0378339876,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.037036155,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.037779808,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    // Gather the results on rank 0\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0370320052,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0379455142,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0442659638,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0451635012,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    // Gather results to rank 0\n    if (rank == 0) {\n        std::vector<std::vector<std::complex<double>>> all_results(size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, all_results.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        for (int i = 1; i < size; ++i) {\n            x.insert(x.end(), all_results[i].begin(), all_results[i].end());\n        }\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0366349654,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.037489268,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0371167318,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381026732,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0371908174,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380318082,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    // Gather the results on rank 0\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0366198362,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0374137554,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.03632742,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0399068264,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers in parallel\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    // Gather results to rank 0\n    if (rank == 0) {\n        std::vector<std::vector<std::complex<double>>> results(size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, results.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        // Combine results from all ranks\n        for (int i = 1; i < size; i++) {\n            for (int j = 0; j < x.size(); j++) {\n                x[j] += results[i][j];\n            }\n        }\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.038845259,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0395891376,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0371405248,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0379007966,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers in parallel\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0370907196,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0378415056,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0364171122,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0373396802,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0370670652,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0377813606,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // Take conjugate of the complex numbers\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Apply fft in parallel\n    fft(x);\n\n    // Take conjugate again\n    for (auto &elem : x) {\n        elem = std::conj(elem);\n    }\n\n    // Scale the numbers\n    for (auto &elem : x) {\n        elem /= static_cast<double>(x.size());\n    }\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> result(x.size());\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, result.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        x = result;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0370918414,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380302514,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "06_fft_dft",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {",
        "translation_prompt": "// Serial implementation of dft\n// /* Compute the discrete fourier transform of x. Store the result in output.\n//    Example:\n// \n//    input: [1, 4, 9, 16]\n//    output: [30+0i, -8-12i, -10-0i, -8+12i]\n// */\n// void dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n// // TODO: implement this function\n//     output.resize(x.size());\n//     for (int i = 0; i < x.size(); i++) {\n//         output[i] = 0;\n//         for (int j = 0; j < x.size(); j++) {\n//             output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n//         }\n//     }\n// }\n\n// MPI implementation of dft\n#include <mpi.h>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n// TODO: implement this function\n    output.resize(x.size());\n    for (int i = 0; i < x.size(); i++) {\n        output[i] = 0;\n        for (int j = 0; j < x.size(); j++) {\n            output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n}",
        "translation_function_name": "dft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841729588,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1182848898,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102810805742,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0842020676,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1184174586,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01383499440586,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(&local_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, &gathered_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841741352,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1184107798,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01622475300234,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841962202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1184560446,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01281439930508,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841964272,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1185229964,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01173008293281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841712758,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.118228438,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.012741288125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0842232314,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1190255508,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00086898374766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841543622,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.118765914,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008351371668,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(&local_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, &gathered_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841632284,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1183167234,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008094680457,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.084176141,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1184557584,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00081006825781,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.084117391,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1183242678,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01258896800469,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(&local_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, &gathered_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841366928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1181812294,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01214567350039,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.084097209,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1186027838,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0007707585332,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841255058,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1175967692,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00087312782891,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.084128181,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1179196048,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01195263518477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Gather(&local_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, &gathered_output[0], local_n, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0840998078,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1192514544,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00090289248281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841574938,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1193497726,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01180735964258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int size, rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = rank * local_n; i < (rank + 1) * local_n; i++) {\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i - rank * local_n] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * i * j / x.size()));\n        }\n    }\n\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.084244896,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1200692302,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01598324619961,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    std::vector<std::complex<double>> gathered_output(x.size());\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, gathered_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n\n    output = gathered_output;\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0842117296,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.117883082,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01197777122852,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_output(local_n, 0);\n\n    for (int i = 0; i < local_n; i++) {\n        int global_i = rank * local_n + i;\n        for (int j = 0; j < x.size(); j++) {\n            local_output[i] += x[j] * std::exp(std::complex<double>(0, -2 * M_PI * global_i * j / x.size()));\n        }\n    }\n\n    MPI_Allgather(local_output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, output.data(), local_n, MPI_CXX_DOUBLE_COMPLEX, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0841682106,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1192113376,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01179194134375,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "translation_prompt": "// Serial implementation of fft\n// /* Compute the fourier transform of x. Store the result in output.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n// */\n// void fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n// int n = x.size();\n//     output.resize(n);\n// \n//     // base case\n//     if (n == 1) {\n//         output[0] = x[0];\n//         return;\n//     }\n// \n//     // radix 2 Cooley-Tukey FFT\n//     // decompose x into even and odd parts\n//     std::vector<std::complex<double>> x_even(n/2);\n//     std::vector<std::complex<double>> x_odd(n/2);\n//     for (int k = 0; k < n/2; k++) {\n//         x_even[k] = x[2*k];\n//         x_odd[k] = x[2*k + 1];\n//     }\n// \n//     // recursively compute FFTs of even and odd parts\n//     std::vector<std::complex<double>> y_even(n/2);\n//     std::vector<std::complex<double>> y_odd(n/2);\n//     fft(x_even, y_even);\n//     fft(x_odd, y_odd);\n// \n//     // combine results\n//     for (int k = 0; k < n/2; k++) {\n//         double kth = -2 * M_PI * k / n;\n//         output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n//         output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n//     }\n// }\n\n// MPI implementation of fft\n#include <mpi.h>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\nint n = x.size();\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}",
        "translation_function_name": "fft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0816322624,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0085120376,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x[2 * k];\n        x_odd[k] = x[2 * k + 1];\n    }\n\n    // scatter x to all processes\n    MPI_Scatter(&x[0], n / size, MPI_DOUBLE_COMPLEX, &x_local[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // gather y_even and y_odd from all processes\n    MPI_Gather(&y_even[0], n / (2 * size), MPI_DOUBLE_COMPLEX, &y_even[0], n / (2 * size), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    MPI_Gather(&y_odd[0], n / (2 * size), MPI_DOUBLE_COMPLEX, &y_odd[0], n / (2 * size), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // combine results\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0869259682,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2050983728,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.64873433344766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    int local_n = n / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    std::vector<std::complex<double>> local_y(local_n);\n\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    fft(local_x, local_y);\n\n    MPI_Gather(local_y.data(), local_n, MPI_DOUBLE_COMPLEX, y_even.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    MPI_Gather(local_y.data(), local_n, MPI_DOUBLE_COMPLEX, y_odd.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.081735728,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1488145842,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.218523631025,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0805562324,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1488085912,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21762417077422,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int i = 0; i < n / size; i++) {\n        x_local[i] = x[rank + i * size];\n    }\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x_local[2 * k];\n        x_odd[k] = x_local[2 * k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    // Gather results from all processes\n    std::vector<std::complex<double>> gathered_output(n);\n    MPI_Gather(&output[0], n / size, MPI_DOUBLE_COMPLEX, &gathered_output[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // Copy gathered results to output\n    if (rank == 0) {\n        output = gathered_output;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0815448902,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2048595374,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0831966642,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1513128474,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21753746412734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0810457044,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1482728982,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21776909547148,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x[2 * k];\n        x_odd[k] = x[2 * k + 1];\n    }\n\n    // distribute input data to all processes\n    MPI_Scatter(&x[0], n / size, MPI_DOUBLE_COMPLEX, &x_local[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    // gather results from all processes\n    MPI_Gather(&output[0], n / size, MPI_DOUBLE_COMPLEX, &output[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0806791044,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1915185148,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.80349707016016,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    MPI_Scatter(x.data(), n / size, MPI_DOUBLE_COMPLEX, x_local.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x_local[2 * k];\n        x_odd[k] = x_local[2 * k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    std::vector<std::complex<double>> y_local(n / size);\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        y_local[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        y_local[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    MPI_Gather(y_local.data(), n / size, MPI_DOUBLE_COMPLEX, output.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0812202754,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.203356396,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    MPI_Scatter(x.data(), n / size, MPI_DOUBLE_COMPLEX, x_local.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x_local[2 * k];\n        x_odd[k] = x_local[2 * k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    std::vector<std::complex<double>> y_local(n / size);\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        y_local[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        y_local[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    MPI_Gather(y_local.data(), n / size, MPI_DOUBLE_COMPLEX, output.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0878594628,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2050544526,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    MPI_Scatter(x.data(), n / size, MPI_DOUBLE_COMPLEX, x_local.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x_local[2 * k];\n        x_odd[k] = x_local[2 * k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    MPI_Gather(output.data(), n / size, MPI_DOUBLE_COMPLEX, output.data(), n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0870807526,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1933452528,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0815238206,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1504153084,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21835465721016,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0813682532,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1485308016,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21741503653516,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_local(n / size);\n    std::vector<std::complex<double>> x_even(n / 2);\n    std::vector<std::complex<double>> x_odd(n / 2);\n    for (int k = 0; k < n / 2; k++) {\n        x_even[k] = x[2 * k];\n        x_odd[k] = x[2 * k + 1];\n    }\n\n    // distribute data to all processes\n    MPI_Scatter(&x[0], n / size, MPI_DOUBLE_COMPLEX, &x_local[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n / 2);\n    std::vector<std::complex<double>> y_odd(n / 2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n / 2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n / 2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n\n    // gather results from all processes\n    MPI_Gather(&output[0], n / size, MPI_DOUBLE_COMPLEX, &output[0], n / size, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0821315004,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.190553725,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.60113014235273,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    output.resize(n);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    fft(x_even, y_even);\n    fft(x_odd, y_odd);\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0864625892,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1469896238,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21849026503047,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size/2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0857046654,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1463560632,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21637722979648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        std::complex<double> twiddle = std::complex<double>(cos(kth), sin(kth));\n        if (rank < size / 2) {\n            output[k] = y_even[k] + twiddle * y_odd[k];\n            output[k + n/2] = y_even[k] - twiddle * y_odd[k];\n        } else {\n            output[k] = y_even[k + n/2] + twiddle * y_odd[k + n/2];\n            output[k + n/2] = y_even[k + n/2] - twiddle * y_odd[k + n/2];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        std::complex<double> twiddle = std::complex<double>(cos(kth), sin(kth));\n        if (rank < size / 2) {\n            output[k] = y_even[k] + twiddle * y_odd[k];\n            output[k + n/2] = y_even[k] - twiddle * y_odd[k];\n        }\n    }\n\n    if (rank >= size / 2) {\n        MPI_Send(output.data(), n, MPI_DOUBLE_COMPLEX, rank - size / 2, 0, MPI_COMM_WORLD);\n    } else {\n        std::vector<std::complex<double>> recv_buffer(n);\n        for (int i = 0; i < size / 2; i++) {\n            if (i != rank) {\n                MPI_Recv(recv_buffer.data(), n, MPI_DOUBLE_COMPLEX, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                for (int j = 0; j < n; j++) {\n                    output[j] += recv_buffer[j];\n                }\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    output.resize(n);\n\n    // base case\n    if (n == 1) {\n        output[0] = x[0];\n        return;\n    }\n\n    // radix 2 Cooley-Tukey FFT\n    // decompose x into even and odd parts\n    std::vector<std::complex<double>> x_even(n/2);\n    std::vector<std::complex<double>> x_odd(n/2);\n    for (int k = 0; k < n/2; k++) {\n        x_even[k] = x[2*k];\n        x_odd[k] = x[2*k + 1];\n    }\n\n    // recursively compute FFTs of even and odd parts\n    std::vector<std::complex<double>> y_even(n/2);\n    std::vector<std::complex<double>> y_odd(n/2);\n\n    if (rank < size / 2) {\n        fft(x_even, y_even);\n        fft(x_odd, y_odd);\n    } else {\n        fft(x_odd, y_odd);\n        fft(x_even, y_even);\n    }\n\n    // combine results\n    for (int k = 0; k < n/2; k++) {\n        double kth = -2 * M_PI * k / n;\n        output[k] = y_even[k] + std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n        output[k + n/2] = y_even[k] - std::complex<double>(cos(kth), sin(kth)) * y_odd[k];\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0814654994,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1471655726,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.21775091357656,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "03_dense_la_axpy",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Store the result in z on rank 0.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {",
        "translation_prompt": "// Serial implementation of axpy\n// /* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n//    Example:\n//    \n//    input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n//    output: z=[2, -6, 5, 17]\n// */\n// void axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n// for (int i = 0; i < x.size(); ++i) {\n//     z[i] = alpha*x[i] + y[i];\n//   }\n// }\n\n// MPI implementation of axpy\n#include <mpi.h>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x and y. Store the result in z on rank 0.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\nfor (int i = 0; i < x.size(); ++i) {\n    z[i] = alpha*x[i] + y[i];\n  }\n}",
        "translation_function_name": "axpy",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank*local_n + i] + y[rank*local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.015950691,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394136354,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00672664001641,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0159348936,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394415234,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00680708163281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n    MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, NULL, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0158265664,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394062334,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0065085713707,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0157315982,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0388580494,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00686005771953,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0158063504,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0391473962,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00712184843672,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0158402684,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0393944572,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00690244023086,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0168949984,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0497515236,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00679615540859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.021325401,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0799373404,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00680706708633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0211543382,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0788233874,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00656455960352,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.021882063,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.10026589,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00676250036211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0158380176,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0393422152,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01105911877578,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0156442048,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0393724118,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00695809006523,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(local_z.data(), local_n, MPI_DOUBLE, z.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0157270182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394321268,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00753409138125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.015806247,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0395530878,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00649398681367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n    MPI_Gather(local_z.data(), local_n, MPI_DOUBLE, z.data(), local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  } else {\n    MPI_Gather(local_z.data(), local_n, MPI_DOUBLE, nullptr, 0, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0157161458,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394327158,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00706442219336,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0156237386,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0395195164,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00692470323242,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.015639158,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0392865322,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00717204326289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.01570873,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0391681716,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00651235239023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0156588808,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0392413128,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00633720475742,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = x.size() / size;\n  std::vector<double> local_z(local_n);\n\n  for (int i = 0; i < local_n; ++i) {\n    local_z[i] = alpha * x[rank * local_n + i] + y[rank * local_n + i];\n  }\n\n  if (rank == 0) {\n    z.resize(x.size());\n  }\n\n  MPI_Gather(&local_z[0], local_n, MPI_DOUBLE, &z[0], local_n, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0159262718,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0391542376,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00698597956367,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "01_dense_la_solve",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and b. Store the result in x on rank 0.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "translation_prompt": "// Serial implementation of solveLinearSystem\n// /* Solve the linear system Ax=b for x.\n//    A is an NxN matrix in row-major. x and b have N elements.\n//    Example:\n//    \n//    input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n//    output: x=[3, 1, 2]\n// */\n// void solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n// // check if the input is valid\n//     if (A.size()!= N * N) {\n//         throw std::invalid_argument(\"A must be a NxN matrix\");\n//     }\n//     if (b.size()!= N) {\n//         throw std::invalid_argument(\"b must have N elements\");\n//     }\n//     // create a copy of A\n//     std::vector<double> A_copy(A);\n//     // create a copy of b\n//     std::vector<double> b_copy(b);\n//     // perform Gaussian elimination\n//     for (size_t i = 0; i < N; i++) {\n//         // find the pivot row and swap it with the current row\n//         size_t pivot_row = i;\n//         for (size_t j = i + 1; j < N; j++) {\n//             if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n//                 pivot_row = j;\n//             }\n//         }\n//         if (pivot_row!= i) {\n//             // swap the current row with the pivot row\n//             for (size_t j = 0; j < N; j++) {\n//                 std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n//             }\n//             std::swap(b_copy[i], b_copy[pivot_row]);\n//         }\n//         // eliminate the current row\n//         for (size_t j = i + 1; j < N; j++) {\n//             double factor = A_copy[j * N + i] / A_copy[i * N + i];\n//             for (size_t k = 0; k < N; k++) {\n//                 A_copy[j * N + k] -= factor * A_copy[i * N + k];\n//             }\n//             b_copy[j] -= factor * b_copy[i];\n//         }\n//     }\n//     // back substitution\n//     x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n//     for (size_t i = N - 2; i < N; i--) {\n//         double sum = 0;\n//         for (size_t j = i + 1; j < N; j++) {\n//             sum += A_copy[i * N + j] * x[j];\n//         }\n//         x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n//     }\n// }\n\n// MPI implementation of solveLinearSystem\n#include <mpi.h>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and b. Store the result in x on rank 0.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n// check if the input is valid\n    if (A.size()!= N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size()!= N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n    // create a copy of A\n    std::vector<double> A_copy(A);\n    // create a copy of b\n    std::vector<double> b_copy(b);\n    // perform Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row!= i) {\n            // swap the current row with the pivot row\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        // eliminate the current row\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    // back substitution\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}",
        "translation_function_name": "solveLinearSystem",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n        for (size_t i = N - 2; i < N; i--) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1004277694,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1755040834,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // broadcast the pivot row and the current row to all ranks\n        MPI_Bcast(&A_copy[i * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n        // eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            if (j % size == rank) {\n                double factor = A_copy[j * N + i] / A_copy[i * N + i];\n                for (size_t k = 0; k < N; k++) {\n                    A_copy[j * N + k] -= factor * A_copy[i * N + k];\n                }\n                b_copy[j] -= factor * b_copy[i];\n            }\n        }\n    }\n\n    // back substitution on rank 0\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n        for (size_t i = N - 2; i < N; i--) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.100519593,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1199436422,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.18423002448242,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1236109062,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1193226074,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30694156190586,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // Perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // Find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // Broadcast the pivot row and the current row to all ranks\n        MPI_Bcast(&A_copy[i * N], N, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[i], 1, MPI_DOUBLE, i % size, MPI_COMM_WORLD);\n\n        // Eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            if (j % size == rank) {\n                double factor = A_copy[j * N + i] / A_copy[i * N + i];\n                for (size_t k = 0; k < N; k++) {\n                    A_copy[j * N + k] -= factor * A_copy[i * N + k];\n                }\n                b_copy[j] -= factor * b_copy[i];\n            }\n        }\n    }\n\n    // Back substitution on rank 0\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n        for (size_t i = N - 2; i < N; i--) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1020241694,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1194669998,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 1.67007199164687,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.124269281,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1211483134,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30697580991523,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1236914436,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1193828046,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30612728664258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.12363012,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1193479492,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30882347218984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        if (rank == 0) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1003009518,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.119609115,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.31113858636094,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1239068478,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1199296582,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3090595192207,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.123602126,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.119635815,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30896999794648,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1238369722,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1198648868,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30667771528984,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1270837558,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.119751983,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30869844882266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // broadcast pivot row and b_copy to all ranks\n        MPI_Bcast(&A_copy[i * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n        // eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            if (j % size == rank) {\n                double factor = A_copy[j * N + i] / A_copy[i * N + i];\n                for (size_t k = 0; k < N; k++) {\n                    A_copy[j * N + k] -= factor * A_copy[i * N + k];\n                }\n                b_copy[j] -= factor * b_copy[i];\n            }\n        }\n    }\n\n    // back substitution in parallel\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n\n    // gather results to rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : x.data(), N, MPI_DOUBLE, x.data(), N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1037840786,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1194772674,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n        for (size_t i = N - 2; i < N; i--) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.101330998,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1789534042,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.37760503284492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // broadcast the pivot row and swap it with the current row on all ranks\n        MPI_Bcast(&A_copy[i * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n        // eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    // back substitution in parallel\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n\n    // gather the results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : x.data(), N, MPI_DOUBLE, x.data(), N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1458923958,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2006102218,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n        for (size_t i = N - 2; i < N; i--) {\n            double sum = 0;\n            for (size_t j = i + 1; j < N; j++) {\n                sum += A_copy[i * N + j] * x[j];\n            }\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.102517429,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1758016348,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.37577701136758,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1242228882,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1205250108,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30669965847773,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // broadcast the pivot row and swap if necessary\n        MPI_Bcast(&A_copy[i * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n        // eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            if (j % size == rank) {\n                double factor = A_copy[j * N + i] / A_copy[i * N + i];\n                for (size_t k = 0; k < N; k++) {\n                    A_copy[j * N + k] -= factor * A_copy[i * N + k];\n                }\n                b_copy[j] -= factor * b_copy[i];\n            }\n        }\n    }\n\n    // back substitution in parallel\n    x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n\n    // gather the results on rank 0\n    MPI_Gather(rank == 0 ? MPI_IN_PLACE : x.data(), N, MPI_DOUBLE, x.data(), N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1008427562,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1194954116,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    // perform Gaussian elimination in parallel\n    for (size_t i = 0; i < N; i++) {\n        // find the pivot row and swap it with the current row\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        // broadcast the pivot row to all ranks\n        MPI_Bcast(&A_copy[pivot_row * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&b_copy[pivot_row], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n        // eliminate the current row in parallel\n        for (size_t j = i + 1; j < N; j++) {\n            if (j % size == rank) {\n                double factor = A_copy[j * N + i] / A_copy[i * N + i];\n                for (size_t k = 0; k < N; k++) {\n                    A_copy[j * N + k] -= factor * A_copy[i * N + k];\n                }\n                b_copy[j] -= factor * b_copy[i];\n            }\n        }\n    }\n\n    // back substitution in parallel\n    std::vector<double> local_x(N, 0);\n    for (size_t i = N - 1; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * local_x[j];\n        }\n        local_x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n\n    // gather the local_x from all ranks to x on rank 0\n    MPI_Gather(&local_x[0], N, MPI_DOUBLE, &x[0], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1015840546,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.122515572,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (A.size() != N * N) {\n        throw std::invalid_argument(\"A must be a NxN matrix\");\n    }\n    if (b.size() != N) {\n        throw std::invalid_argument(\"b must have N elements\");\n    }\n\n    std::vector<double> A_copy(A);\n    std::vector<double> b_copy(b);\n\n    for (size_t i = 0; i < N; i++) {\n        size_t pivot_row = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivot_row * N + i])) {\n                pivot_row = j;\n            }\n        }\n        if (pivot_row != i) {\n            for (size_t j = 0; j < N; j++) {\n                std::swap(A_copy[i * N + j], A_copy[pivot_row * N + j]);\n            }\n            std::swap(b_copy[i], b_copy[pivot_row]);\n        }\n\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = 0; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    if (rank == 0) {\n        x[N - 1] = b_copy[N - 1] / A_copy[(N - 1) * N + (N - 1)];\n    }\n\n    for (size_t i = N - 2; i < N; i--) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        if (rank == 0) {\n            x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1270563602,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1193541668,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.30488305819727,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "02_dense_la_gemm",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and B. Store the result in C on rank 0.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// Serial implementation of gemm\n// /* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n//    A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n//    output: C=[[9, 5], [4, 2]]\n// */\n// void gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             double sum = 0;\n//             for (size_t k = 0; k < K; ++k) {\n//                 sum += A[i * K + k] * B[k * N + j];\n//             }\n//             C[i * N + j] = sum;\n//         }\n//     }\n// }\n\n// MPI implementation of gemm\n#include <mpi.h>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and B. Store the result in C on rank 0.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            double sum = 0;\n            for (size_t k = 0; k < K; ++k) {\n                sum += A[i * K + k] * B[k * N + j];\n            }\n            C[i * N + j] = sum;\n        }\n    }\n}",
        "translation_function_name": "gemm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0042245668,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0354367384,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.50733832e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0042918172,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.038121381,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.074435273e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035662902,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0329521482,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.302885078e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0036140478,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0307832946,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.410852852e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035743294,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0307336498,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.717329766e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.003603977,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318529528,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.115858281e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.003547329,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0336376438,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.031768828e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035855414,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0312768022,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.033971445e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035899914,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030775703,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.255762266e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.003575895,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.030795083,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.18478043e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0040923956,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0335787746,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.722887227e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0040637116,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.035470054,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.263575156e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035690682,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0306084712,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.390005977e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0048947712,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0394489222,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.454898711e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.004095937,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0356151054,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.717516211e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0042453348,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380821138,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.611646797e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0041293432,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0361030006,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.72228625e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0035557714,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0336595384,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.392698633e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0036466934,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0310164074,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.981955078e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                double sum = 0;\n                for (size_t k = 0; k < K; ++k) {\n                    sum += A[i * K + k] * B[k * N + j];\n                }\n                C[i * N + j] = sum;\n            }\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.003636112,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0312787594,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 6.046939375e-05,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "04_dense_la_gemv",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and x. Store the result in y on rank 0.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {",
        "translation_prompt": "// Serial implementation of gemv\n// /* Multiply the matrix A by the vector x. Store the results in the vector y.\n//    A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n//    output: y=[1, -3]\n// */\n// void gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n// for (size_t i = 0; i < M; ++i) {\n//         double sum = 0;\n//         for (size_t j = 0; j < N; ++j) {\n//             sum += A[i * N + j] * x[j];\n//         }\n//         y[i] = sum;\n//     }\n// }\n\n// MPI implementation of gemv\n#include <mpi.h>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A and x. Store the result in y on rank 0.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\nfor (size_t i = 0; i < M; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        y[i] = sum;\n    }\n}",
        "translation_function_name": "gemv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320257666,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318353418,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0008988681668,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320225472,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0345354204,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00094037007227,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0319800774,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319488068,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00093662180977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0319488086,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0345453752,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00096338432227,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    if (rank == 0) {\n        for (size_t i = 0; i < M; ++i) {\n            double sum = 0;\n            for (size_t j = 0; j < N; ++j) {\n                sum += A[i * N + j] * x[j];\n            }\n            y[i] = sum;\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0326813072,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.035640536,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 7.077032969e-05,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320231818,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0323196248,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102015768906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320594624,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319282824,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095634420547,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0319798392,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.031861629,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00067964313164,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.032066604,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319029888,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092278797383,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0346451446,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319845914,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00095844407734,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y = std::vector<double>(M, 0);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0321652006,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0408966468,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00117889333008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.032033866,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04217197,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00092037894609,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0321807658,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318956892,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00087708862187,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y = std::vector<double>(M, 0);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320723954,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318971618,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00085481860977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0319345822,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.031897128,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00096895799453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.031968965,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318545134,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00102497938008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.031959964,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.031872193,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00089017416719,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0319839812,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319154824,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00106057230234,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0.0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(&local_y[0], local_M, MPI_DOUBLE, &y[0], local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.031974834,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319099098,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00207338570859,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t local_M = M / size;\n    size_t local_start = rank * local_M;\n    size_t local_end = (rank == size - 1) ? M : local_start + local_M;\n\n    std::vector<double> local_y(local_M, 0);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        double sum = 0;\n        for (size_t j = 0; j < N; ++j) {\n            sum += A[i * N + j] * x[j];\n        }\n        local_y[i - local_start] = sum;\n    }\n\n    if (rank == 0) {\n        y.resize(M);\n    }\n\n    MPI_Gather(local_y.data(), local_M, MPI_DOUBLE, y.data(), local_M, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0320172156,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0319167764,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00073594595312,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "00_dense_la_lu_decomp",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. Store the result in A on rank 0.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {",
        "translation_prompt": "// Serial implementation of luFactorize\n// /* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n//    Store the results for L and U into the original matrix A. \n//    A is an NxN matrix stored in row-major.\n//    Example:\n// \n//    input: [[4, 3], [6, 3]]\n//    output: [[4, 3], [1.5, -1.5]]\n// */\n// void luFactorize(std::vector<double> &A, size_t N) {\n// for (size_t i = 0; i < N; i++) {\n//     for (size_t j = i + 1; j < N; j++) {\n//       A[j * N + i] = A[j * N + i] / A[i * N + i];\n//       for (size_t k = i + 1; k < N; k++) {\n//         A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n//       }\n//     }\n//   }\n// }\n\n// MPI implementation of luFactorize\n#include <mpi.h>\n\n/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of A. Store the result in A on rank 0.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {\nfor (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n}",
        "translation_function_name": "luFactorize",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n\n      if (rank == 0) {\n        for (size_t k = i + 1; k < N; k++) {\n          A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n        }\n      }\n    }\n\n    if (size > 1) {\n      MPI_Bcast(&A[i * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0999636774,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1241834254,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.16581932926055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1 + rank; k < N; k += size) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n      if (size > 1) {\n        MPI_Bcast(&A[j * N + k], N - k, MPI_DOUBLE, rank, MPI_COMM_WORLD);\n      }\n    }\n    if (size > 1) {\n      MPI_Bcast(&A[j * N + i], N - i, MPI_DOUBLE, rank, MPI_COMM_WORLD);\n    }\n  }\n  if (rank == 0) {\n    for (int r = 1; r < size; r++) {\n      MPI_Recv(&A[0], N * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&A[0], N * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    // Gather results from all ranks to rank 0\n    std::vector<double> recvbuf(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvbuf[j];\n      }\n    }\n  } else {\n    // Send results from other ranks to rank 0\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.123089449,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.101463709,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.6586480398832,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    // Gather results from all ranks to rank 0\n    std::vector<double> recvBuffer(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvBuffer[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvBuffer[j];\n      }\n    }\n  } else {\n    // Send results from other ranks to rank 0\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.125627648,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1011808734,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.64564118598164,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1 + rank; k < N; k += size) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n      if (rank == 0) {\n        MPI_Bcast(&A[j * N + i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n        MPI_Bcast(&A[j * N + i + 1], N - i - 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1036574442,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2388394202,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int r = 1; r < size; r++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t i = 0; i < A.size(); i++) {\n        A[i] = recvbuf[i];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0993163086,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.126669878,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.30890473337656,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    // Collect results from other ranks if necessary\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0998966108,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1256620456,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.27015124805664,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n\n      if (rank == 0) {\n        for (size_t k = i + 1; k < N; k++) {\n          A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n        }\n      }\n    }\n\n    if (size > 1) {\n      MPI_Bcast(&A[(i + 1) * N + i], N - i - 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0988167738,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0992400274,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.11956602129141,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvA(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvA[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < N * N; j++) {\n        A[j] = recvA[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0999321622,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1255205958,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31697534061641,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1 + rank; k < N; k += size) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n      if (rank == 0) {\n        MPI_Bcast(&A[j * N], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      }\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0990810026,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1993812598,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    // Gather results from all ranks to rank 0\n    std::vector<double> recvBuffer(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvBuffer[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvBuffer[j];\n      }\n    }\n  } else {\n    // Send results from other ranks to rank 0\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1357255376,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1122984016,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.62776950863125,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int r = 1; r < size; r++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t i = 0; i < A.size(); i++) {\n        A[i] = recvbuf[i];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1106452126,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1401582838,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.32470830583711,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvA(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvA[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < N * N; j++) {\n        A[j] = recvA[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1000228146,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.137818019,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31786099303672,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int r = 1; r < size; r++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t i = 0; i < A.size(); i++) {\n        A[i] = recvbuf[i];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0994385596,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1268203828,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.32488886993398,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvA(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvA[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < N * N; j++) {\n        A[j] = recvA[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0998092738,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1252111862,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.33108518005977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1; j < N; j++) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n\n      if (rank == 0) {\n        for (size_t k = i + 1; k < N; k++) {\n          A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n        }\n      }\n      MPI_Bcast(&A[j * N + i], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n      MPI_Bcast(&A[j * N + i + 1], N - i - 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n    }\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1003208858,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.106890465,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvbuf[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0985898468,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1264561668,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31736924518906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int r = 1; r < size; r++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t i = 0; i < A.size(); i++) {\n        A[i] = recvbuf[i];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0985263574,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1265853398,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31260087352461,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvbuf[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0988327208,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1268393444,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31486355825664,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i + 1 + rank; j < N; j += size) {\n      A[j * N + i] = A[j * N + i] / A[i * N + i];\n      for (size_t k = i + 1; k < N; k++) {\n        A[j * N + k] = A[j * N + k] - A[j * N + i] * A[i * N + k];\n      }\n    }\n  }\n\n  if (rank == 0) {\n    std::vector<double> recvbuf(A.size());\n    for (int i = 1; i < size; i++) {\n      MPI_Recv(&recvbuf[0], A.size(), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < A.size(); j++) {\n        A[j] = recvbuf[j];\n      }\n    }\n  } else {\n    MPI_Send(&A[0], A.size(), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0995240922,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1295827556,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.31222910770625,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "42_sort_sorted_ranks",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every process has a complete copy of x. Store the result in ranks on process 0.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {",
        "translation_prompt": "// Serial implementation of ranks\n// /* For each value in the vector x compute its index in the sorted vector.\n//    Store the results in `ranks`.\n//    Examples:\n// \n//    input: [3.1, 2.8, 9.1, 0.4, 3.14]\n//    output: [2, 1, 4, 0, 3]\n//  \n//    input: [100, 7.6, 16.1, 18, 7.6]\n//    output: [4, 0, 1, 2, 3]\n// */\n// void ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n// std::vector<float> sorted = x;\n//     std::sort(sorted.begin(), sorted.end());\n//     ranks.resize(x.size());\n//     for (size_t i = 0; i < x.size(); ++i) {\n//         ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n//     }\n// }\n\n// MPI implementation of ranks\n#include <mpi.h>\n\n/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every process has a complete copy of x. Store the result in ranks on process 0.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks) {\nstd::vector<float> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    ranks.resize(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), x[i]));\n    }\n}",
        "translation_function_name": "ranks",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0129012172,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0280300818,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<std::vector<size_t>> all_ranks(size);\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, all_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n        for (int i = 0; i < size; ++i) {\n            for (size_t j = 0; j < local_x.size(); ++j) {\n                ranks[i * local_x.size() + j] = all_ranks[i][j];\n            }\n        }\n    } else {\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), x.size(), MPI_UNSIGNED_LONG, ranks.data(), x.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0129920992,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0279597384,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<size_t> recv_counts(size);\n        std::vector<size_t> displs(size, 0);\n        for (int i = 0; i < size; ++i) {\n            recv_counts[i] = x.size() / size;\n            if (i < x.size() % size) {\n                recv_counts[i]++;\n            }\n            if (i > 0) {\n                displs[i] = displs[i - 1] + recv_counts[i - 1];\n            }\n        }\n        MPI_Gatherv(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), recv_counts.data(), displs.data(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Gatherv(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, nullptr, nullptr, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0143238366,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0280258558,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), x.size(), MPI_UNSIGNED_LONG, ranks.data(), x.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.012997946,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0278764714,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<size_t> recv_counts(size);\n        std::vector<size_t> displs(size, 0);\n\n        MPI_Gather(&local_ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, &ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Gather(&local_ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, NULL, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.012666524,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0279000782,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<std::vector<size_t>> all_ranks(size);\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, all_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n        for (int i = 0; i < size; ++i) {\n            size_t offset = i * (x.size() / size);\n            std::copy(all_ranks[i].begin(), all_ranks[i].end(), ranks.begin() + offset);\n        }\n    } else {\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0128898208,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0273974666,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0130019778,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0281870102,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0128964234,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0275503518,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<size_t> recv_counts(size);\n        std::vector<size_t> displs(size, 0);\n        MPI_Gather(&local_ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, &ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Gather(&local_ranks[0], local_ranks.size(), MPI_UNSIGNED_LONG, NULL, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0127007182,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0281870768,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<std::vector<size_t>> all_ranks(size);\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, all_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n        for (int i = 0; i < size; ++i) {\n            for (size_t j = 0; j < local_x.size(); ++j) {\n                ranks[i * local_x.size() + j] = all_ranks[i][j];\n            }\n        }\n    } else {\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(x.size());\n    for (size_t i = 0; i < x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n    }\n\n    MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0129720944,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027208565,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<std::vector<size_t>> all_ranks(size);\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, all_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n\n        for (int i = 0; i < size; ++i) {\n            for (size_t j = 0; j < local_x.size(); ++j) {\n                ranks[i * local_x.size() + j] = all_ranks[i][j];\n            }\n        }\n    } else {\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::sort(local_x.begin(), local_x.end());\n\n    std::vector<size_t> local_ranks(local_x.size());\n    for (size_t i = 0; i < local_x.size(); ++i) {\n        local_ranks[i] = std::distance(local_x.begin(), std::lower_bound(local_x.begin(), local_x.end(), x[i]));\n    }\n\n    if (rank == 0) {\n        ranks.resize(x.size());\n        std::vector<std::vector<size_t>> all_ranks(size);\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, all_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n        for (int i = 0; i < size; ++i) {\n            for (size_t j = 0; j < local_x.size(); ++j) {\n                ranks[i * local_x.size() + j] = all_ranks[i][j];\n            }\n        }\n    } else {\n        MPI_Gather(local_ranks.data(), local_ranks.size(), MPI_UNSIGNED_LONG, nullptr, 0, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::vector<float> sorted;\n    if (rank == 0) {\n        sorted = x;\n        std::sort(sorted.begin(), sorted.end());\n        ranks.resize(x.size());\n    }\n\n    MPI_Bcast(&sorted[0], sorted.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n\n    size_t local_start = rank * (x.size() / size);\n    size_t local_end = (rank == size - 1) ? x.size() : (rank + 1) * (x.size() / size);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), local_x[i]));\n    }\n\n    if (rank == 0) {\n        for (int p = 1; p < size; ++p) {\n            size_t start = p * (x.size() / size);\n            size_t end = (p == size - 1) ? x.size() : (p + 1) * (x.size() / size);\n            MPI_Recv(&ranks[start], end - start, MPI_UNSIGNED_LONG, p, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else {\n        MPI_Send(&ranks[local_start], local_end - local_start, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0129605048,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0278923642,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::vector<float> sorted;\n    if (rank == 0) {\n        sorted = x;\n        std::sort(sorted.begin(), sorted.end());\n        ranks.resize(x.size());\n    }\n\n    MPI_Bcast(&sorted[0], x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n\n    size_t local_start = rank * (x.size() / size);\n    size_t local_end = (rank + 1) * (x.size() / size);\n    if (rank == size - 1) {\n        local_end = x.size();\n    }\n\n    std::vector<size_t> local_ranks(local_end - local_start);\n    for (size_t i = local_start; i < local_end; ++i) {\n        local_ranks[i - local_start] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), local_x[i]));\n    }\n\n    if (rank == 0) {\n        ranks = local_ranks;\n        for (int i = 1; i < size; ++i) {\n            MPI_Recv(&ranks[0] + i * (x.size() / size), x.size() / size, MPI_UNSIGNED_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else {\n        MPI_Send(&local_ranks[0], local_end - local_start, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.014656255,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0318892438,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::vector<float> sorted;\n    if (rank == 0) {\n        sorted = x;\n        std::sort(sorted.begin(), sorted.end());\n        ranks.resize(x.size());\n    }\n\n    MPI_Bcast(&sorted[0], x.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n\n    size_t local_start = rank * (x.size() / size);\n    size_t local_end = (rank + 1) * (x.size() / size);\n    if (rank == size - 1) {\n        local_end = x.size();\n    }\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), local_x[i]));\n    }\n\n    if (rank == 0) {\n        for (int p = 1; p < size; ++p) {\n            MPI_Recv(&ranks[p * (x.size() / size)], x.size() / size, MPI_UNSIGNED_LONG, p, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else {\n        MPI_Send(&ranks[local_start], local_end - local_start, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0143691228,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0311570138,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::vector<float> local_x = x;\n    std::vector<float> sorted;\n    if (rank == 0) {\n        sorted = x;\n        std::sort(sorted.begin(), sorted.end());\n        ranks.resize(x.size());\n    }\n\n    MPI_Bcast(&sorted[0], sorted.size(), MPI_FLOAT, 0, MPI_COMM_WORLD);\n\n    size_t local_start = rank * (x.size() / size);\n    size_t local_end = (rank == size - 1) ? x.size() : (rank + 1) * (x.size() / size);\n\n    for (size_t i = local_start; i < local_end; ++i) {\n        ranks[i] = std::distance(sorted.begin(), std::lower_bound(sorted.begin(), sorted.end(), local_x[i]));\n    }\n\n    if (rank == 0) {\n        std::vector<size_t> recv_ranks;\n        recv_ranks.resize(x.size());\n        for (int p = 1; p < size; ++p) {\n            MPI_Recv(&recv_ranks[0] + p * (x.size() / size), x.size() / size, MPI_UNSIGNED_LONG, p, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        ranks = recv_ranks;\n    } else {\n        MPI_Send(&ranks[local_start], local_end - local_start, MPI_UNSIGNED_LONG, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.014633463,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0313069328,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "44_sort_sort_non-zero_elements",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use MPI to sort x in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {",
        "translation_prompt": "// Serial implementation of sortIgnoreZero\n// /* Sort the vector x in ascending order ignoring elements with value 0.\n//    Leave zero valued elements in-place.\n//    Example:\n// \n// \t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n//    output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n// */\n// void sortIgnoreZero(std::vector<int> &x) {\n// int n = x.size();\n//   int i = 0;\n//   int j = 0;\n//   int k = 0;\n// \n//   while (i < n) {\n//     if (x[i] == 0) {\n//       i++;\n//     } else {\n//       j = i + 1;\n//       while (j < n) {\n//         if (x[j] == 0) {\n//           j++;\n//         } else {\n//           if (x[i] > x[j]) {\n//             k = x[i];\n//             x[i] = x[j];\n//             x[j] = k;\n//           }\n//           j++;\n//         }\n//       }\n//       i++;\n//     }\n//   }\n// }\n\n// MPI implementation of sortIgnoreZero\n#include <mpi.h>\n\n/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place. \n\t Use MPI to sort x in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Example:\n\n   input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Sort the vector x in ascending order ignoring elements with value 0.\n   Leave zero valued elements in-place.\n   Example:\n\n\t input: [8, 4, 0, 9, 8, 0, 1, -1, 7]\n   output: [-1, 1, 0, 4, 7, 0, 8, 8, 9]\n*/\nvoid sortIgnoreZero(std::vector<int> &x) {\nint n = x.size();\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < n) {\n    if (x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < n) {\n        if (x[j] == 0) {\n          j++;\n        } else {\n          if (x[i] > x[j]) {\n            k = x[i];\n            x[i] = x[j];\n            x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n}",
        "translation_function_name": "sortIgnoreZero",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018250344,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0675658122,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00337774724687,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_INT, local_x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(local_x.data(), local_n, MPI_INT, x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018141482,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.7434617818,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00458255762695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018067826,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.6862896346,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00337852280039,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001816817,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.6660384746,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00351225361211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_INT, local_x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(local_x.data(), local_n, MPI_INT, x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001813064,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.6623877182,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00340121394922,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018184704,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0563061888,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00744100201992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018200316,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0088621698,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00319926950742,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018260324,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0128745466,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00273896010625,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018176306,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.1386138738,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00235613755234,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018272186,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.7037091764,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00349471555742,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001818877,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.668752251,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00333660934492,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001814148,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.6628948804,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00394451539609,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018128158,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.8583254928,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00267158647773,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.001822293,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.7387955668,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00403136851289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018130664,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.1192372184,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00355236372969,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018225718,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0474764826,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00332381585508,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018356424,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.5879791284,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0030080869668,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int n = x.size();\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(x.data(), local_n, MPI_INT, local_x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  std::sort(local_x.begin(), local_x.end(), [](int a, int b) {\n    if (a == 0) {\n      return false;\n    } else if (b == 0) {\n      return true;\n    } else {\n      return a < b;\n    }\n  });\n\n  MPI_Gather(local_x.data(), local_n, MPI_INT, x.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018378242,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.003007804,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  while (i < local_n) {\n    if (local_x[i] == 0) {\n      i++;\n    } else {\n      j = i + 1;\n      while (j < local_n) {\n        if (local_x[j] == 0) {\n          j++;\n        } else {\n          if (local_x[i] > local_x[j]) {\n            k = local_x[i];\n            local_x[i] = local_x[j];\n            local_x[j] = k;\n          }\n          j++;\n        }\n      }\n      i++;\n    }\n  }\n\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018179192,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.6657049734,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00330066207266,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  int n = x.size();\n  int local_n = n / size;\n  std::vector<int> local_x(local_n);\n  MPI_Scatter(&x[0], local_n, MPI_INT, &local_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (int i = 0; i < local_n; i++) {\n    if (local_x[i] == 0) {\n      continue;\n    }\n    for (int j = i + 1; j < local_n; j++) {\n      if (local_x[j] == 0) {\n        continue;\n      }\n      if (local_x[i] > local_x[j]) {\n        int temp = local_x[i];\n        local_x[i] = local_x[j];\n        local_x[j] = temp;\n      }\n    }\n  }\n\n  std::vector<int> sorted_x(n);\n  MPI_Gather(&local_x[0], local_n, MPI_INT, &sorted_x[0], local_n, MPI_INT, 0, MPI_COMM_WORLD);\n\n  if (rank == 0) {\n    x = sorted_x;\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0018142258,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 4.0097621122,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00570392633555,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "41_sort_k-th_smallest_element",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Find the k-th smallest element of the vector x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {",
        "translation_prompt": "// Serial implementation of findKthSmallest\n// /* Find the k-th smallest element of the vector x.\n//    Example:\n//    \n//    input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n//    output: 6\n// */\n// int findKthSmallest(std::vector<int> const& x, int k) {\n// int n = x.size();\n//     std::vector<int> y(x);\n//     std::sort(y.begin(), y.end());\n//     return y[k-1];\n// }\n\n// MPI implementation of findKthSmallest\n#include <mpi.h>\n\n/* Find the k-th smallest element of the vector x.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Return the result on rank 0.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {\nint n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n    return y[k-1];\n}",
        "translation_function_name": "findKthSmallest",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return 0;  // Placeholder return value for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1; // or some other error code to indicate non-zero ranks should not return a value\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-zero ranks should not return a value\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1; // or some other error code to indicate that only rank 0 should return the result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    if (rank == 0) {\n        int result;\n        MPI_Status status;\n        MPI_Recv(&result, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &status);\n        return result;\n    } else {\n        if (rank <= n) {\n            int result = y[k-1];\n            MPI_Send(&result, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or any other value, since only rank 0 returns the result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (MPI::COMM_WORLD.Get_rank() == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI::COMM_WORLD.Reduce(&local_kth, &global_kth, 1, MPI::INT, MPI::MIN, 0);\n\n    if (MPI::COMM_WORLD.Get_rank() == 0) {\n        return global_kth;\n    } else {\n        return 0;  // Placeholder return value for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": false,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0065085962,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0066837284,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00728280094297,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (MPI::COMM_WORLD.Get_rank() == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI::COMM_WORLD.Reduce(&local_kth, &global_kth, 1, MPI::INT, MPI::MIN, 0);\n\n    if (MPI::COMM_WORLD.Get_rank() == 0) {\n        return global_kth;\n    } else {\n        return 0;  // Placeholder return value for non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": false,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.007169612,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0078781954,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00718262986211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return 0;  // or some other value to indicate no result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1; // or some other error code to indicate that only rank 0 should return the result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1; // or some other error code to indicate that only rank 0 should return the result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1; // or some other error code to indicate non-zero ranks should not return a value\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate non-root ranks\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    int local_kth;\n    if (rank == 0) {\n        local_kth = y[k-1];\n    }\n\n    int global_kth;\n    MPI_Reduce(&local_kth, &global_kth, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        return global_kth;\n    } else {\n        return -1;  // or some other error code to indicate that only rank 0 should return the result\n    }\n}\n",
                "source_write_success": true,
                "did_build": false,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": null
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    if (rank == 0) {\n        int result;\n        MPI_Status status;\n        MPI_Recv(&result, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &status);\n        return result;\n    } else {\n        if (rank <= n) {\n            int local_k = k - 1;\n            int local_result = y[local_k];\n            MPI_Send(&local_result, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int n = x.size();\n    std::vector<int> y(x);\n    std::sort(y.begin(), y.end());\n\n    if (rank == 0) {\n        int result;\n        MPI_Status status;\n        MPI_Recv(&result, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &status);\n        return result;\n    } else {\n        if (rank <= n) {\n            int local_k = k - 1;\n            int local_result = y[local_k];\n            MPI_Send(&local_result, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "43_sort_sort_an_array_of_structs_by_key",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use MPI to sort in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of results. Store the output in results on rank 0.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {",
        "translation_prompt": "// Serial implementation of sortByStartTime\n// struct Result {\n//    int startTime, duration;\n//    float value;\n// };\n// \n// /* Sort vector of Result structs by start time in ascending order.\n//    Example:\n//    \n//    input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n//    output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n// */\n// void sortByStartTime(std::vector<Result> &results) {\n// std::sort(results.begin(), results.end(), [](const Result &a, const Result &b) {\n//       return a.startTime < b.startTime;\n//    });\n// }\n\n// MPI implementation of sortByStartTime\n#include <mpi.h>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Use MPI to sort in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of results. Store the output in results on rank 0.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "struct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   \n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {\nstd::sort(results.begin(), results.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n}",
        "translation_function_name": "sortByStartTime",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() - localSize * (size - 1);\n      std::sort(results.begin(), results.begin() + remaining, [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042430522,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0061405924,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042395796,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004674261,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01309762082617,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size();\n   std::vector<Result> localResults = results;\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   if (rank == 0) {\n      results = localResults;\n      std::vector<Result> tempResults;\n      for (int i = 1; i < size; i++) {\n         MPI_Recv(&localSize, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         localResults.resize(localSize);\n         MPI_Recv(localResults.data(), localSize * sizeof(Result), MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         tempResults.insert(tempResults.end(), localResults.begin(), localResults.end());\n      }\n      std::sort(tempResults.begin(), tempResults.end(), [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n      results.insert(results.end(), tempResults.begin(), tempResults.end());\n   } else {\n      MPI_Send(&localSize, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n      MPI_Send(localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0041899844,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0045309024,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042406636,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049026796,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01342311575391,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042347748,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046653064,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01255872701484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042275894,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0047800436,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01384469272891,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size();\n   std::vector<Result> localResults = results;\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   if (rank == 0) {\n      std::vector<Result> mergedResults;\n      mergedResults.reserve(localSize * size);\n      mergedResults.insert(mergedResults.end(), localResults.begin(), localResults.end());\n\n      for (int i = 1; i < size; i++) {\n         MPI_Recv(&localSize, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         localResults.resize(localSize);\n         MPI_Recv(localResults.data(), localSize * sizeof(Result), MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         mergedResults.insert(mergedResults.end(), localResults.begin(), localResults.end());\n      }\n\n      std::sort(mergedResults.begin(), mergedResults.end(), [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n\n      results = mergedResults;\n   } else {\n      MPI_Send(&localSize, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n      MPI_Send(localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0041652062,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0067150778,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042559864,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0048178286,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01427811842109,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042360672,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.004861827,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01181967082891,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() - localSize * (size - 1);\n      std::sort(results.begin(), results.begin() + remaining, [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.00422804,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0061043404,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042260702,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046916418,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01232555461289,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\nint rank, size;\nMPI_Comm_rank(MPI_COMM_WORLD, &rank);\nMPI_Comm_size(MPI_COMM_WORLD, &size);\n\nif (rank == 0) {\n    std::vector<Result> localResults = results;\n    std::vector<Result> mergedResults;\n\n    for (int i = 1; i < size; i++) {\n        MPI_Recv(&localResults[0], localResults.size() * sizeof(Result), MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        mergedResults.insert(mergedResults.end(), localResults.begin(), localResults.end());\n    }\n\n    std::sort(mergedResults.begin(), mergedResults.end(), [](const Result &a, const Result &b) {\n        return a.startTime < b.startTime;\n    });\n\n    results = mergedResults;\n} else {\n    MPI_Send(&results[0], results.size() * sizeof(Result), MPI_BYTE, 0, 0, MPI_COMM_WORLD);\n}\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 5.44e-08,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.000127956,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042729202,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0049571462,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00939442442695,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() - localSize * (size - 1);\n      std::sort(results.begin(), results.begin() + remaining, [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0044942956,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0062467694,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0049268568,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0054052224,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01694629231836,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size() / size;\n   std::vector<Result> localResults(localSize);\n   MPI_Scatter(results.data(), localSize * sizeof(Result), MPI_BYTE, localResults.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   MPI_Gather(localResults.data(), localSize * sizeof(Result), MPI_BYTE, results.data(), localSize * sizeof(Result), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   if (rank == 0) {\n      int remaining = results.size() % size;\n      if (remaining > 0) {\n         std::sort(results.begin() + localSize * size, results.end(), [](const Result &a, const Result &b) {\n            return a.startTime < b.startTime;\n         });\n      }\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0043537076,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0046898786,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01248276653281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size();\n   std::vector<Result> localResults = results;\n\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   if (rank == 0) {\n      std::vector<int> recvCounts(size);\n      std::vector<int> displs(size, 0);\n\n      for (int i = 0; i < size; i++) {\n         recvCounts[i] = results.size() / size;\n      }\n      recvCounts[size - 1] += results.size() % size;\n\n      for (int i = 1; i < size; i++) {\n         displs[i] = displs[i - 1] + recvCounts[i - 1];\n      }\n\n      results.resize(localSize);\n      MPI_Gatherv(localResults.data(), localSize, MPI_BYTE, results.data(), recvCounts.data(), displs.data(), MPI_BYTE, 0, MPI_COMM_WORLD);\n   } else {\n      MPI_Gatherv(localResults.data(), localSize, MPI_BYTE, nullptr, nullptr, nullptr, MPI_BYTE, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0044051424,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0045440952,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size();\n   std::vector<Result> localResults = results;\n\n   // Scatter the data to all processes\n   std::vector<int> recvCounts(size);\n   std::vector<int> displs(size);\n   for (int i = 0; i < size; i++) {\n      recvCounts[i] = localSize / size;\n      if (i < localSize % size) {\n         recvCounts[i]++;\n      }\n      displs[i] = (i > 0) ? (displs[i - 1] + recvCounts[i - 1]) : 0;\n   }\n\n   std::vector<Result> localResultsRecv(recvCounts[rank]);\n   MPI_Scatterv(localResults.data(), recvCounts.data(), displs.data(), MPI_BYTE, localResultsRecv.data(), recvCounts[rank], MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   // Sort the local data\n   std::sort(localResultsRecv.begin(), localResultsRecv.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   // Gather the sorted data to rank 0\n   std::vector<int> sendCounts(size);\n   for (int i = 0; i < size; i++) {\n      sendCounts[i] = (i < localSize % size) ? (localSize / size + 1) : (localSize / size);\n   }\n\n   std::vector<Result> sortedResults(localSize);\n   MPI_Gatherv(localResultsRecv.data(), recvCounts[rank], MPI_BYTE, sortedResults.data(), sendCounts.data(), displs.data(), MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   // Store the sorted results in results on rank 0\n   if (rank == 0) {\n      results = sortedResults;\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0041652002,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0029387692,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   if (rank == 0) {\n      std::vector<Result> localResults = results;\n      std::vector<Result> mergedResults;\n\n      for (int i = 1; i < size; i++) {\n         int count;\n         MPI_Recv(&count, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         std::vector<Result> tempResults(count);\n         MPI_Recv(tempResults.data(), count * sizeof(Result), MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n         mergedResults.insert(mergedResults.end(), tempResults.begin(), tempResults.end());\n      }\n\n      mergedResults.insert(mergedResults.end(), localResults.begin(), localResults.end());\n      std::sort(mergedResults.begin(), mergedResults.end(), [](const Result &a, const Result &b) {\n         return a.startTime < b.startTime;\n      });\n\n      results = mergedResults;\n   } else {\n      int count = results.size();\n      MPI_Send(&count, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);\n      MPI_Send(results.data(), count * sizeof(Result), MPI_BYTE, 0, 0, MPI_COMM_WORLD);\n   }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0042506448,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0052586354,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n   int rank, size;\n   MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n   MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n   int localSize = results.size();\n   std::vector<Result> localResults = results;\n\n   // Scatter the data to all processes\n   MPI_Scatter(results.data(), localSize, MPI_BYTE, localResults.data(), localSize, MPI_BYTE, 0, MPI_COMM_WORLD);\n\n   // Sort the local data\n   std::sort(localResults.begin(), localResults.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n\n   // Gather the sorted data to rank 0\n   MPI_Gather(localResults.data(), localSize, MPI_BYTE, results.data(), localSize, MPI_BYTE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0043805842,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0046683822,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "40_sort_sort_an_array_of_complex_numbers_by_magnitude",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use MPI to sort in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {",
        "translation_prompt": "// Serial implementation of sortComplexByMagnitude\n// /* Sort the vector x of complex numbers by their magnitude in ascending order.\n//    Example:\n//    \n//    input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n//    output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n// */\n// void sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n// std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n//         return std::abs(a) < std::abs(b);\n//     });\n// }\n\n// MPI implementation of sortComplexByMagnitude\n#include <mpi.h>\n\n/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Use MPI to sort in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of x. Store the result in x on rank 0.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\nstd::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n}",
        "translation_function_name": "sortComplexByMagnitude",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0799195558,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1278222924,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0798419842,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080925321,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796759928,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.080768757,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0798933668,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.128074417,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796230276,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0806725486,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796692306,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808222176,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0798224962,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807005588,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796265422,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1280843118,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.079874776,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1280186926,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0799527446,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1283462734,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0795363892,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0806338818,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.079644993,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1281926106,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0797748466,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0808309916,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.079738707,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807560092,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796852568,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807502866,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::copy(recvbuf.begin(), recvbuf.end(), x.begin());\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0796774684,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0807224606,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::sort(local_x.begin(), local_x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    std::vector<std::complex<double>> sorted_x(x.size());\n    MPI_Gather(local_x.data(), local_n, MPI_DOUBLE_COMPLEX, sorted_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        x = sorted_x;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0799616514,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0813686826,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.03906935647812,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    std::sort(x.begin(), x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    if (rank == 0) {\n        std::vector<std::complex<double>> recvbuf(x.size() * size);\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, recvbuf.data(), x.size(), MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n        std::sort(recvbuf.begin(), recvbuf.end(), [](std::complex<double> a, std::complex<double> b) {\n            return std::abs(a) < std::abs(b);\n        });\n        x = recvbuf;\n    } else {\n        MPI_Gather(x.data(), x.size(), MPI_DOUBLE_COMPLEX, nullptr, 0, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0799251116,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1281540288,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::sort(local_x.begin(), local_x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    std::vector<std::complex<double>> sorted_x(x.size());\n    MPI_Gather(local_x.data(), local_n, MPI_DOUBLE_COMPLEX, sorted_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        x = sorted_x;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0800250664,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0813642362,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01002420264219,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_n = x.size() / size;\n    std::vector<std::complex<double>> local_x(local_n);\n    MPI_Scatter(x.data(), local_n, MPI_DOUBLE_COMPLEX, local_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    std::sort(local_x.begin(), local_x.end(), [](std::complex<double> a, std::complex<double> b) {\n        return std::abs(a) < std::abs(b);\n    });\n\n    std::vector<std::complex<double>> sorted_x(x.size());\n    MPI_Gather(local_x.data(), local_n, MPI_DOUBLE_COMPLEX, sorted_x.data(), local_n, MPI_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        x = sorted_x;\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0798685552,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0811704044,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0091347827168,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of cellsXOR\n// /* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n//    Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n//    input and output are NxN grids of ints in row-major.\n//    Example:\n// \n//    input: [[0, 1, 1, 0],\n//            [1, 0, 0, 0],\n//            [0, 0, 0, 0],\n//            [0, 1, 0, 0]\n//    output: [[0, 0, 1, 1],\n//             [1, 0, 0, 1],\n//             [0, 0, 1, 0],\n//             [1, 0, 1, 0]]\n// */\n// void cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n// for (size_t i = 0; i < N; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             int count = 0;\n//             if (i > 0 && input[i - 1 + j * N] == 1) {\n//                 ++count;\n//             }\n//             if (i < N - 1 && input[i + 1 + j * N] == 1) {\n//                 ++count;\n//             }\n//             if (j > 0 && input[i + (j - 1) * N] == 1) {\n//                 ++count;\n//             }\n//             if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n//                 ++count;\n//             }\n//             if (count == 1) {\n//                 output[i + j * N] = 1;\n//             } else {\n//                 output[i + j * N] = 0;\n//             }\n//         }\n//     }\n// }\n\n// MPI implementation of cellsXOR\n#include <mpi.h>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                output[i + j * N] = 1;\n            } else {\n                output[i + j * N] = 0;\n            }\n        }\n    }\n}",
        "translation_function_name": "cellsXOR",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0859706334,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3366389578,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0859344452,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3365033594,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0940265848,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3341281354,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0861350296,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3362835326,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    int start = rank * local_N;\n    int end = start + local_N;\n\n    if (rank == size - 1) {\n        end = N;\n    }\n\n    std::vector<int> local_input(input.begin() + start * N, input.begin() + end * N);\n    std::vector<int> local_output(local_N * N, 0);\n\n    for (size_t i = start; i < end; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[(i - 1) * N + j] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && input[(i + 1) * N + j] == 1) {\n                ++count;\n            }\n            if (j > 0 && input[i * N + (j - 1)] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && input[i * N + (j + 1)] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[(i - start) * N + j] = 1;\n            } else {\n                local_output[(i - start) * N + j] = 0;\n            }\n        }\n    }\n\n    if (rank == 0) {\n        output = local_output;\n        for (int i = 1; i < size; ++i) {\n            MPI_Recv(&output[i * local_N * N], local_N * N, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else {\n        MPI_Send(&local_output[0], local_N * N, MPI_INT, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0963430304,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1281242648,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00169939589453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0862815666,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3411448942,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0939169112,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3331883892,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0937919306,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.332851074,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    int start_row = rank * local_N;\n    int end_row = start_row + local_N;\n\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = start_row; i < end_row; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[(i - 1) + j * N] == 1) {\n                ++count;\n            }\n            if (i < N - 1 && local_input[(i + 1) + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0859838782,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3367958458,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0866406344,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3376328502,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0873971574,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.396095555,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.091691525,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3391530478,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0968532432,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.34255219,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0928792452,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.393453046,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0883437584,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.333780203,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.10433483,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3920443076,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.099169263,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3607028144,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0860384368,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.341862657,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[(i - 1) * N + j] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[(i + 1) * N + j] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i * N + (j - 1)] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i * N + (j + 1)] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i * N + j] = 1;\n            } else {\n                local_output[i * N + j] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0938766852,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.2318251924,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00936213394414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_N = N / size;\n    std::vector<int> local_input(local_N * N);\n    std::vector<int> local_output(local_N * N);\n\n    MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < local_N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && local_input[i - 1 + j * N] == 1) {\n                ++count;\n            }\n            if (i < local_N - 1 && local_input[i + 1 + j * N] == 1) {\n                ++count;\n            }\n            if (j > 0 && local_input[i + (j - 1) * N] == 1) {\n                ++count;\n            }\n            if (j < N - 1 && local_input[i + (j + 1) * N] == 1) {\n                ++count;\n            }\n            if (count == 1) {\n                local_output[i + j * N] = 1;\n            } else {\n                local_output[i + j * N] = 0;\n            }\n        }\n    }\n\n    MPI_Gather(local_output.data(), local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0861227934,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.3394501262,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "54_stencil_game_of_life",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of gameOfLife\n// /* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n//    A cell is 1 if it is alive and 0 if it is dead.\n//    If a live cell has fewer than 2 live neighbors then it dies.\n//    If a live cell has 2 or 3 live neighbors then it lives on.\n//    If a live cell has more than 3 live neighbords then it dies.\n//    If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Example:\n// \n//    input:  [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 0, 0, 0],\n//             [0, 1, 1, 0, 0],\n//             [0, 0, 1, 1, 0],\n//             [0, 1, 0, 0, 0]]\n//    output: [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 1, 0, 0],\n//             [0, 1, 0, 1, 0],\n//             [0, 0, 0, 1, 0],\n//             [0, 0, 1, 0, 0]]\n// */\n// void gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n// std::vector<int> next(input.size(), 0);\n//   for (size_t i = 0; i < N; ++i) {\n//     for (size_t j = 0; j < N; ++j) {\n//       int count = 0;\n//       for (int x = -1; x <= 1; ++x) {\n//         for (int y = -1; y <= 1; ++y) {\n//           if (x == 0 && y == 0) {\n//             continue;\n//           }\n//           size_t r = (i + x + N) % N;\n//           size_t c = (j + y + N) % N;\n//           count += input[r * N + c];\n//         }\n//       }\n//       if (input[i * N + j] == 1) {\n//         next[i * N + j] = (count == 2 || count == 3);\n//       } else {\n//         next[i * N + j] = (count == 3);\n//       }\n//     }\n//   }\n//   output = next;\n// }\n\n// MPI implementation of gameOfLife\n#include <mpi.h>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use MPI to compute in parallel. Assume MPI is already initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\nstd::vector<int> next(input.size(), 0);\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n  output = next;\n}",
        "translation_function_name": "gameOfLife",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.size());\n  std::vector<int> local_output(input.size());\n\n  int local_N = N / size;\n  int start = rank * local_N;\n  int end = start + local_N;\n\n  MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  MPI_Gather(next.data() + start * N, local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1141960074,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1350391558,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.17405557824766,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), recv_buffer.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < recv_buffer.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), next.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1138760572,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1339683898,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.19419337778711,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), input.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < input.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), input.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.112489947,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1347726198,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 3.2039256707668,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.begin() + rank * (N * N / size), input.begin() + (rank + 1) * (N * N / size));\n  std::vector<int> local_output(local_input.size(), 0);\n\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        local_output[i * N + j] = (count == 2 || count == 3);\n      } else {\n        local_output[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = local_output;\n    for (int i = 1; i < size; ++i) {\n      std::vector<int> temp(N * N / size, 0);\n      MPI_Recv(temp.data(), temp.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      output.insert(output.end(), temp.begin(), temp.end());\n    }\n  } else {\n    MPI_Send(local_output.data(), local_output.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1067039106,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1318174512,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.size());\n  std::vector<int> local_output(input.size());\n\n  int local_N = N / size;\n  int start = rank * local_N;\n  int end = start + local_N;\n\n  MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  MPI_Gather(next.data() + start * N, local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1035945104,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1266292554,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.17675139265078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.size());\n  std::vector<int> local_output(input.size());\n\n  int local_N = N / size;\n  int start = rank * local_N;\n  int end = start + local_N;\n\n  MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  MPI_Gather(next.data() + start * N, local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1037210878,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1263471342,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.17638192613008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> temp(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(temp.data(), temp.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < temp.size(); ++j) {\n        output[j] |= temp[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), next.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1032180204,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1331480344,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.95558482203555,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), input.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < input.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), input.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1054976172,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1333214276,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.88789148801406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size());\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), input.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < input.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), input.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1062186756,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1333441588,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.73457310148906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size());\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), recv_buffer.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < N; ++j) {\n        output[i * N + j] = recv_buffer[i * N + j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), next.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.108197862,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1333010102,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 1.47502495640117,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), input.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < input.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), input.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1121061028,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1332546292,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.73721786876563,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.size());\n  std::vector<int> local_output(input.size());\n\n  int local_N = N / size;\n  int start = rank * local_N;\n  int end = start + local_N;\n\n  MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  MPI_Gather(next.data() + start * N, local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1037502896,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1262138248,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.17642350035078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  std::vector<int> local_input(input.size());\n  std::vector<int> local_output(input.size());\n\n  size_t local_N = N / size;\n  size_t start = rank * local_N;\n  size_t end = start + local_N;\n\n  MPI_Scatter(input.data(), local_N * N, MPI_INT, local_input.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += local_input[r * N + c];\n        }\n      }\n      if (local_input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  MPI_Gather(next.data() + start * N, local_N * N, MPI_INT, output.data(), local_N * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1037915162,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1263175302,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.17571177585234,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  std::vector<int> next(input.size(), 0);\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_N = N / size;\n  size_t start = rank * local_N;\n  size_t end = start + local_N;\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(local_N * N, 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(&recv_buffer[0] + i * local_N * N, local_N * N, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n    output.insert(output.end(), recv_buffer.begin(), recv_buffer.end());\n  } else {\n    MPI_Send(&next[start * N], local_N * N, MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.107389189,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.139608255,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size());\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), recv_buffer.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < recv_buffer.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), next.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.106143037,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1330069344,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.96812273144727,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), input.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < input.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), input.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.1031942316,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1339949214,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.91147678507539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  std::vector<int> next(input.size(), 0);\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_N = N / size;\n  size_t start = rank * local_N;\n  size_t end = start + local_N;\n\n  for (size_t i = start; i < end; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> temp(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(temp.data(), temp.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < local_N; ++j) {\n        output[(i * local_N + j) * N] = temp[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data() + start * N, local_N * N, MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1032677874,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1307269918,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.05497861830977,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  std::vector<int> next(input.size(), 0);\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_N = N / size;\n  size_t start_row = rank * local_N;\n  size_t end_row = start_row + local_N;\n\n  for (size_t i = start_row; i < end_row; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> temp(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(temp.data(), temp.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < local_N; ++j) {\n        output[(i * local_N + j) * N] = temp[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data() + start_row * N, local_N * N, MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1079998506,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1306118658,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.05512652136406,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  std::vector<int> next(input.size(), 0);\n  for (size_t i = rank; i < N; i += size) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> recv_buffer(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(recv_buffer.data(), recv_buffer.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < recv_buffer.size(); ++j) {\n        output[j] |= recv_buffer[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data(), next.size(), MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.10619284,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1332027662,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 2.98306462469219,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  std::vector<int> next(input.size(), 0);\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_N = N / size;\n  size_t start_row = rank * local_N;\n  size_t end_row = start_row + local_N;\n\n  for (size_t i = start_row; i < end_row; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      int count = 0;\n      for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          size_t r = (i + x + N) % N;\n          size_t c = (j + y + N) % N;\n          count += input[r * N + c];\n        }\n      }\n      if (input[i * N + j] == 1) {\n        next[i * N + j] = (count == 2 || count == 3);\n      } else {\n        next[i * N + j] = (count == 3);\n      }\n    }\n  }\n\n  if (rank == 0) {\n    output = next;\n    std::vector<int> temp(input.size(), 0);\n    for (int i = 1; i < size; ++i) {\n      MPI_Recv(temp.data(), temp.size(), MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n      for (size_t j = 0; j < local_N; ++j) {\n        output[(i * local_N + j) * N] = temp[j];\n      }\n    }\n  } else {\n    MPI_Send(next.data() + start_row * N, local_N * N, MPI_INT, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.1031487698,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1306569084,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.05471635732383,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "52_stencil_1d_jacobi_3-point_stencil",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {",
        "translation_prompt": "// Serial implementation of jacobi1D\n// /* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n//    i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n//    Replace with 0 when reading past the boundaries of `input`.\n//    Example:\n// \n//    input: [9, -6, -1, 2, 3]\n//    output: [1, 2/3, -5/3, 4/3, 5/3]\n// */\n// void jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n// // YOUR CODE HERE\n//     for (int i = 1; i < input.size() - 1; i++) {\n//         output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n//     }\n// }\n\n// MPI implementation of jacobi1D\n#include <mpi.h>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n// YOUR CODE HERE\n    for (int i = 1; i < input.size() - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n}",
        "translation_function_name": "jacobi1D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[end - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.023859589,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.026913467,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00231040694727,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0240037528,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270548744,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00240931766953,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[end - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0238637424,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027160258,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00246488953008,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0238722584,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272292034,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00232285899414,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[start], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.023889683,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027067358,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00227853564453,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = start + local_size;\n\n    if (rank == size - 1) {\n        end = input.size();\n    }\n\n    for (int i = start; i < end; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size - 1; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        MPI_Recv(&output[(size - 1) * local_size], input.size() - (size - 1) * local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    } else {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = start + local_size;\n\n    if (rank == size - 1) {\n        end = input.size();\n    }\n\n    for (int i = start; i < end; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank != 0) {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    } else {\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0241235222,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0133474174,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.04612677008828,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size - 1; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        MPI_Recv(&output[(size - 1) * local_size], input.size() - (size - 1) * local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    } else {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    std::vector<double> local_input(local_size + 2, 0.0);\n    std::vector<double> local_output(local_size, 0.0);\n\n    MPI_Scatter(input.data(), local_size, MPI_DOUBLE, local_input.data() + 1, local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 1; i <= local_size; i++) {\n        local_output[i - 1] = (local_input[i - 1] + local_input[i] + local_input[i + 1]) / 3;\n    }\n\n    MPI_Gather(local_output.data(), local_size, MPI_DOUBLE, output.data(), local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0237884146,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0592879714,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.02153856333633,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[end - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0238839084,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0270489148,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.0024691412082,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0240276156,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272193746,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00242288585937,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[input.size() - local_size], local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[input.size() - local_size], local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": false,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0240230732,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272095038,
                        "num_procs": 1
                    },
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[end - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0239166316,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.027014326,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00227571169258,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[local_size - 2], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0238760196,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272657356,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00229537739727,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < local_size - 1; i++) {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n        if (size > 1) {\n            MPI_Recv(&output[local_size - 1], 1, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    } else if (rank == size - 1) {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n    } else {\n        MPI_Send(&output[start + 1], 1, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\n        MPI_Recv(&output[end - 1], 1, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0240696326,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0272038532,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00247827294844,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    std::vector<double> local_input(local_size + 2, 0.0);\n    std::vector<double> local_output(local_size, 0.0);\n\n    MPI_Scatter(&input[0], local_size, MPI_DOUBLE, &local_input[1], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        local_input[0] = 0.0;\n    }\n    if (rank == size - 1) {\n        local_input[local_size + 1] = 0.0;\n    }\n\n    for (int i = 1; i < local_size + 1; i++) {\n        local_output[i - 1] = (local_input[i - 1] + local_input[i] + local_input[i + 1]) / 3;\n    }\n\n    MPI_Gather(&local_output[0], local_size, MPI_DOUBLE, &output[0], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0239852164,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0604851754,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01988329739297,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start; i < end; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size - 1; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        MPI_Recv(&output[(size - 1) * local_size], input.size() - (size - 1) * local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    } else {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank == 0) {\n        for (int i = 1; i < size - 1; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        MPI_Recv(&output[(size - 1) * local_size], input.size() - (size - 1) * local_size, MPI_DOUBLE, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    } else {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": false,
                "did_all_run": false,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": null,
                "runs": [
                    {
                        "did_run": false,
                        "is_valid": null,
                        "runtime": null,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    int start = rank * local_size;\n    int end = (rank == size - 1) ? input.size() : start + local_size;\n\n    for (int i = start + 1; i < end - 1; i++) {\n        output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n    }\n\n    if (rank != 0) {\n        MPI_Send(&output[start], local_size, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n    } else {\n        for (int i = 1; i < size; i++) {\n            MPI_Recv(&output[i * local_size], local_size, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n    }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0239247494,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.01359477,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.04964430306992,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int local_size = input.size() / size;\n    std::vector<double> local_input(local_size + 2, 0.0);\n    std::vector<double> local_output(local_size, 0.0);\n\n    MPI_Scatter(&input[0], local_size, MPI_DOUBLE, &local_input[1], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n    for (int i = 1; i <= local_size; i++) {\n        local_output[i - 1] = (local_input[i - 1] + local_input[i] + local_input[i + 1]) / 3;\n    }\n\n    MPI_Gather(&local_output[0], local_size, MPI_DOUBLE, &output[0], local_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.0240462856,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.060097901,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01981276195039,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "51_stencil_edge_kernel",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of imageIn. The result is stored in imageOut on rank 0.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {",
        "translation_prompt": "// Serial implementation of convolveKernel\n// const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n// \n// /* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n//    the dot product of itself and its neighbors with the edge kernel.\n//    Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n//    imageIn and imageOut are NxN grayscale images stored in row-major.\n//    Store the output of the computation in imageOut.\n//    Example:\n// \n//    input: [[112, 118, 141, 152],\n//            [93, 101, 119, 203],\n//            [45, 17, 16, 232],\n//            [82, 31, 49, 101]]\n//    output: [[255, 255, 255, 255],\n//             [255, 147, 0, 255],\n//             [36, 0, 0, 255],\n//             [255, 39, 0, 255]]\n// */\n// void convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n// for (size_t i = 0; i < N; ++i) {\n//         for (size_t j = 0; j < N; ++j) {\n//             int sum = 0;\n//             for (int k = -1; k <= 1; ++k) {\n//                 for (int l = -1; l <= 1; ++l) {\n//                     int x = i + k;\n//                     int y = j + l;\n//                     if (x >= 0 && x < N && y >= 0 && y < N) {\n//                         sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n//                     }\n//                 }\n//             }\n//             imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n//         }\n//     }\n// }\n\n// MPI implementation of convolveKernel\n#include <mpi.h>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of imageIn. The result is stored in imageOut on rank 0.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "const int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\nfor (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n}",
        "translation_function_name": "convolveKernel",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2350613892,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1722150352,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00929049447539,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2305132906,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1732939028,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00895322116328,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2360005126,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1741754562,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01041153498945,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + rank * localN + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2387956688,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.1805571236,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2349310952,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.172406879,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00822955196602,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.2267176906,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1709464568,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00868943651562,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + rank * localN + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.753168985,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.452849527,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7272878302,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.6062219682,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01057255493164,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int globalI = rank * localN + i;\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = globalI + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.74163863,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.4524817794,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7253170074,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.5921925542,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.09775565088789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7095048138,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.5792822988,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01388195428906,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.723353782,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.6081728834,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00981312136367,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.730435432,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.5977996518,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00940098794922,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7241011414,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.6043486476,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00924048492812,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7279165806,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.5987697288,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00951069404531,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7163275388,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.6015496764,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00897225517969,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + rank * localN + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7224767012,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.468240586,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7112870214,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.5791406842,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.00898016780195,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = i + rank * localN + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.704466342,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.4534523808,
                        "num_procs": 1
                    }
                ]
            },
            {
                "generated_output": "\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    size_t localN = N / size;\n    std::vector<int> localImageIn(localN * N);\n    std::vector<int> localImageOut(localN * N);\n\n    MPI_Scatter(imageIn.data(), localN * N, MPI_INT, localImageIn.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    for (size_t i = 0; i < localN; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int globalI = rank * localN + i;\n            int sum = 0;\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    int x = globalI + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += localImageIn[i * N + j] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            localImageOut[i * N + j] = std::max(std::min(sum, 255), 0);\n        }\n    }\n\n    MPI_Gather(localImageOut.data(), localN * N, MPI_INT, imageOut.data(), localN * N, MPI_INT, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": false,
                "are_all_valid": false,
                "best_sequential_runtime": 0.7372752628,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.453395719,
                        "num_procs": 1
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "53_stencil_2d_jacobi_5-point_stencil",
        "parallelism_model": "mpi",
        "prompt": "#include <mpi.h>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {",
        "translation_prompt": "// Serial implementation of jacobi2D\n// /* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n//    i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n//    Replace with 0 when reading past the boundaries of `input`.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Example:\n// \n//    input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n//    output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n// */\n// void jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n// for (size_t i = 1; i < N - 1; ++i) {\n//     for (size_t j = 1; j < N - 1; ++j) {\n//       output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n//     }\n//   }\n// }\n\n// MPI implementation of jacobi2D\n#include <mpi.h>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use MPI to compute in parallel. Assume MPI has already been initialized.\n   Every rank has a complete copy of input. The result is stored in output on rank 0.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n",
        "translation_src_model": "serial",
        "translation_dst_model": "mpi",
        "translation_src_example": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\nfor (size_t i = 1; i < N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n}",
        "translation_function_name": "jacobi2D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0637989698,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382407416,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00160732601211,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0639304706,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381603322,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161200533789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.064123506,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381570702,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162752993789,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2) / size * rank + 1;\n  size_t local_end = (N-2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2) / size * r + 1;\n      size_t end = (N-2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.064171456,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382211586,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016096852418,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int i = 1; i < size; ++i) {\n      size_t start = (N - 2) / size * i + 1;\n      size_t end = (N - 2) / size * (i + 1) + 1;\n      if (i == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0636547246,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.038224186,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158373678594,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2)/size * rank + 1;\n  size_t local_end = (N-2)/size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2)/size * r + 1;\n      size_t end = (N-2)/size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0641221356,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381083466,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0016112853582,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0637689838,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381942332,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00160899861172,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2)/size * rank + 1;\n  size_t local_end = (N-2)/size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2)/size * r + 1;\n      size_t end = (N-2)/size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0639144854,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0379151868,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00157544206914,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.063336814,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.038259019,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161019089141,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2) / size * rank + 1;\n  size_t local_end = (N-2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2) / size * r + 1;\n      size_t end = (N-2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0638055188,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382091592,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00173864029023,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2)/size * rank + 1;\n  size_t local_end = (N-2)/size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2)/size * r + 1;\n      size_t end = (N-2)/size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.064165042,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0383213882,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00163948980078,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0637448686,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380811848,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00162196323477,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_N = N / size;\n  size_t start_row = rank * local_N;\n  size_t end_row = start_row + local_N;\n\n  if (rank == size - 1) {\n    end_row = N;\n    local_N = end_row - start_row;\n  }\n\n  std::vector<double> local_input(local_N * N);\n  std::vector<double> local_output(local_N * N);\n\n  MPI_Scatter(input.data(), local_N * N, MPI_DOUBLE, local_input.data(), local_N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n\n  for (size_t i = 1; i < local_N - 1; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      local_output[i * N + j] = (local_input[(i - 1) * N + j] + local_input[(i + 1) * N + j] + local_input[i * N + j - 1] + local_input[i * N + j + 1] + local_input[i * N + j]) / 5;\n    }\n  }\n\n  MPI_Gather(local_output.data(), local_N * N, MPI_DOUBLE, output.data(), local_N * N, MPI_DOUBLE, 0, MPI_COMM_WORLD);\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": false,
                "best_sequential_runtime": 0.064358267,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.1233309392,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": false,
                        "runtime": 0.01774724058281,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0636091082,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380904126,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00163139256836,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0639231262,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381058216,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00164106709102,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0639592098,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0380553208,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0015545988875,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0634385802,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0381546014,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00164484541484,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2) / size * rank + 1;\n  size_t local_end = (N-2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2) / size * r + 1;\n      size_t end = (N-2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0637994562,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382284014,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00158915991055,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N - 2) / size * rank + 1;\n  size_t local_end = (N - 2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N - 2) / size * r + 1;\n      size_t end = (N - 2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0640430748,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.0382124176,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00163892381562,
                        "num_procs": 512
                    }
                ]
            },
            {
                "generated_output": "\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n  size_t local_start = (N-2) / size * rank + 1;\n  size_t local_end = (N-2) / size * (rank + 1) + 1;\n  if (rank == size - 1) {\n    local_end = N - 1;\n  }\n\n  for (size_t i = local_start; i < local_end; ++i) {\n    for (size_t j = 1; j < N - 1; ++j) {\n      output[i * N + j] = (input[(i - 1) * N + j] + input[(i + 1) * N + j] + input[i * N + j - 1] + input[i * N + j + 1] + input[i * N + j]) / 5;\n    }\n  }\n\n  if (rank == 0) {\n    for (int r = 1; r < size; ++r) {\n      size_t start = (N-2) / size * r + 1;\n      size_t end = (N-2) / size * (r + 1) + 1;\n      if (r == size - 1) {\n        end = N - 1;\n      }\n      MPI_Recv(&output[start * N], (end - start) * N, MPI_DOUBLE, r, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n    }\n  } else {\n    MPI_Send(&output[local_start * N], (local_end - local_start) * N, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);\n  }\n}\n",
                "source_write_success": true,
                "did_build": true,
                "is_source_valid": true,
                "did_any_run": true,
                "did_all_run": true,
                "are_any_valid": true,
                "are_all_valid": true,
                "best_sequential_runtime": 0.0635939168,
                "runs": [
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.038019706,
                        "num_procs": 1
                    },
                    {
                        "did_run": true,
                        "is_valid": true,
                        "runtime": 0.00161754897656,
                        "num_procs": 512
                    }
                ]
            }
        ]
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(Kokkos::View<const double*> &x) {",
        "translation_prompt": "// CUDA implementation of closestPair\n// __device__ double distanceBetweenPoints(double x1, double x2) {\n// \treturn fabs(x1 - x2);\n// }\n// \n// /* Compute the distance between the closest two elements in the vector x.\n//    Store the result in distance.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [7, 3, 9, 12, 31, 1]\n//    output: 2\n// */\n// __global__ void closestPair(const double *x, size_t N, double *distance) {\n// \n//     int tid = blockIdx.x * blockDim.x + threadIdx.x;\n//     double minDist = DBL_MAX;\n// \n//     for (int i = 0; i < N; i++) {\n//         for (int j = i + 1; j < N; j++) {\n//             double dist = distanceBetweenPoints(x[i], x[j]);\n//             if (dist < minDist) {\n//                 minDist = dist;\n//             }\n//         }\n//     }\n// \n//     distance[tid] = minDist;\n// }\n\n// Kokkos implementation of closestPair\n#include <Kokkos_Core.hpp>\n\ndouble distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(Kokkos::View<const double*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "__device__ double distanceBetweenPoints(double x1, double x2) {\n\treturn fabs(x1 - x2);\n}\n\n/* Compute the distance between the closest two elements in the vector x.\n   Store the result in distance.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\n__global__ void closestPair(const double *x, size_t N, double *distance) {\n\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    double minDist = DBL_MAX;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double dist = distanceBetweenPoints(x[i], x[j]);\n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n    }\n\n    distance[tid] = minDist;\n}",
        "translation_function_name": "closestPair",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(\"closest_pair\", x.size(), KOKKOS_LAMBDA(const int i, double& local_minDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < local_minDist) {\n                local_minDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.extent(0), KOKKOS_LAMBDA(int i, double& localMinDist) {\n        for (int j = i + 1; j < x.extent(0); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(\"closest_pair\", x.size(), KOKKOS_LAMBDA(const int i, double& local_minDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < local_minDist) {\n                local_minDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(\"closest_pair\", x.size(), KOKKOS_LAMBDA(int i, double &local_minDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < local_minDist) {\n                local_minDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(\"closest_pair\", x.size(), KOKKOS_LAMBDA(const int i, double& local_minDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < local_minDist) {\n                local_minDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.extent(0), KOKKOS_LAMBDA(int i, double& localMinDist) {\n        for (int j = i + 1; j < x.extent(0); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double &localMinDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(\"closest_pair\", x.size(), KOKKOS_LAMBDA(const int i, double& local_minDist) {\n        for (int j = i + 1; j < x.size(); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < local_minDist) {\n                local_minDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n",
            "\n    double minDist = DBL_MAX;\n\n    Kokkos::parallel_reduce(x.extent(0), KOKKOS_LAMBDA(int i, double& localMinDist) {\n        for (int j = i + 1; j < x.extent(0); j++) {\n            double dist = distance(x(i), x(j));\n            if (dist < localMinDist) {\n                localMinDist = dist;\n            }\n        }\n    }, Kokkos::Min<double>(minDist));\n\n    return minDist;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "15_graph_edge_count",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix. A represents a directed graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(Kokkos::View<const int**> &A, size_t N) {",
        "translation_prompt": "// CUDA implementation of edgeCount\n// /* Count the number of edges in the directed graph defined by the adjacency matrix A.\n//    Store the result in numEdges. A represents a directed graph.\n//    A is an NxN adjacency matrix stored in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// __global__ void edgeCount(const int *A, size_t N, int *numEdges) {\n// int tid = threadIdx.x;\n// \tint bid = blockIdx.x;\n// \tint numThreads = blockDim.x;\n// \tint numBlocks = gridDim.x;\n// \tint start = bid * numThreads + tid;\n// \tint end = (bid + 1) * numThreads;\n// \tint count = 0;\n// \tfor (int i = start; i < end; i++) {\n// \t\tfor (int j = 0; j < N; j++) {\n// \t\t\tif (A[i * N + j] == 1) {\n// \t\t\t\tcount++;\n// \t\t\t}\n// \t\t}\n// \t}\n// \t__syncthreads();\n// \tif (tid == 0) {\n// \t\tatomicAdd(numEdges, count);\n// \t}\n// }\n\n// Kokkos implementation of edgeCount\n#include <Kokkos_Core.hpp>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix. A represents a directed graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(Kokkos::View<const int**> &A, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   Store the result in numEdges. A represents a directed graph.\n   A is an NxN adjacency matrix stored in row-major.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\n__global__ void edgeCount(const int *A, size_t N, int *numEdges) {\nint tid = threadIdx.x;\n\tint bid = blockIdx.x;\n\tint numThreads = blockDim.x;\n\tint numBlocks = gridDim.x;\n\tint start = bid * numThreads + tid;\n\tint end = (bid + 1) * numThreads;\n\tint count = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (A[i * N + j] == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\t__syncthreads();\n\tif (tid == 0) {\n\t\tatomicAdd(numEdges, count);\n\t}\n}",
        "translation_function_name": "edgeCount",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(\"edgeCount\", Kokkos::RangePolicy<>(0, N), KOKKOS_LAMBDA(int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n\n  return count;\n}\n",
            "\n    int count = 0;\n    Kokkos::parallel_reduce(\"edge_count\", Kokkos::RangePolicy<>(0, N), KOKKOS_LAMBDA(int i, int& local_count) {\n        for (int j = 0; j < N; j++) {\n            if (A(i, j) == 1) {\n                local_count++;\n            }\n        }\n    }, count);\n    return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(\"edgeCount\", Kokkos::RangePolicy<>(0, N), KOKKOS_LAMBDA(int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(\"edge_count\", Kokkos::RangePolicy<>(0, N), KOKKOS_LAMBDA(int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n    int count = 0;\n    Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n        for (int j = 0; j < N; j++) {\n            if (A(i, j) == 1) {\n                local_count++;\n            }\n        }\n    }, count);\n    return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(\"edgeCount\", Kokkos::RangePolicy<>(0, N), KOKKOS_LAMBDA(int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n",
            "\n  int count = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_count) {\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        local_count++;\n      }\n    }\n  }, count);\n  return count;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "17_graph_highest_degree",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix. A is an undirected graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(Kokkos::View<const int**> &A, size_t N) {",
        "translation_prompt": "// CUDA implementation of maxDegree\n// /* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph. \n//    Store the result in maxDegree.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n// \t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n//    output: 3\n// */\n// __global__ void maxDegree(const int *A, size_t N, int *maxDegree) {\n// int tid = threadIdx.x;\n// \tint max = 0;\n// \tfor (int i = tid; i < N; i += blockDim.x) {\n// \t\tint degree = 0;\n// \t\tfor (int j = 0; j < N; j++) {\n// \t\t\tif (A[i * N + j] == 1) {\n// \t\t\t\tdegree++;\n// \t\t\t}\n// \t\t}\n// \t\tif (degree > max) {\n// \t\t\tmax = degree;\n// \t\t}\n// \t}\n// \t__syncthreads();\n// \tatomicMax(maxDegree, max);\n// }\n\n// Kokkos implementation of maxDegree\n#include <Kokkos_Core.hpp>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix. A is an undirected graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(Kokkos::View<const int**> &A, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph. \n   Store the result in maxDegree.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\n__global__ void maxDegree(const int *A, size_t N, int *maxDegree) {\nint tid = threadIdx.x;\n\tint max = 0;\n\tfor (int i = tid; i < N; i += blockDim.x) {\n\t\tint degree = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (A[i * N + j] == 1) {\n\t\t\t\tdegree++;\n\t\t\t}\n\t\t}\n\t\tif (degree > max) {\n\t\t\tmax = degree;\n\t\t}\n\t}\n\t__syncthreads();\n\tatomicMax(maxDegree, max);\n}",
        "translation_function_name": "maxDegree",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int& localMax) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > localMax) {\n      localMax = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\nint max = 0;\nKokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n        if (A(i, j) == 1) {\n            degree++;\n        }\n    }\n    if (degree > local_max) {\n        local_max = degree;\n    }\n}, Kokkos::Max<int>(max));\nreturn max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\nint max = 0;\nKokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n        if (A(i, j) == 1) {\n            degree++;\n        }\n    }\n    if (degree > local_max) {\n        local_max = degree;\n    }\n}, Kokkos::Max<int>(max));\nreturn max;\n}\n",
            "\nint max = 0;\nKokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n        if (A(i, j) == 1) {\n            degree++;\n        }\n    }\n    if (degree > local_max) {\n        local_max = degree;\n    }\n}, Kokkos::Max<int>(max));\nreturn max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(int i, int &localMax) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > localMax) {\n      localMax = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n",
            "\n  int maxDegree = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int& local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(maxDegree));\n  return maxDegree;\n}\n",
            "\n  int max = 0;\n  Kokkos::parallel_reduce(N, KOKKOS_LAMBDA(const int i, int &local_max) {\n    int degree = 0;\n    for (int j = 0; j < N; j++) {\n      if (A(i, j) == 1) {\n        degree++;\n      }\n    }\n    if (degree > local_max) {\n      local_max = degree;\n    }\n  }, Kokkos::Max<int>(max));\n  return max;\n}\n"
        ]
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix. A is an undirected graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(Kokkos::View<const int**> &A, size_t N, int source, int dest) {",
        "translation_prompt": "// CUDA implementation of shortestPathLength\n// /* Compute the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n//    A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n//    Store the result in pathLength.\n//    Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n//    Example:\n// \n// \t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n//    output: 2\n// */\n// __global__ void shortestPathLength(const int *A, size_t N, int source, int dest, int *pathLength) {\n// int row = blockIdx.y * blockDim.y + threadIdx.y;\n//     int col = blockIdx.x * blockDim.x + threadIdx.x;\n// \n//     if (row < N && col < N) {\n//         if (row == col) {\n//             pathLength[row] = 0;\n//         } else if (A[row * N + col] == 1) {\n//             pathLength[row] = 1;\n//         } else {\n//             pathLength[row] = INT_MAX;\n//         }\n// \n//         __syncthreads();\n// \n//         for (int k = 0; k < N; ++k) {\n//             if (pathLength[row] + pathLength[k] < pathLength[col]) {\n//                 pathLength[col] = pathLength[row] + pathLength[k];\n//             }\n//             __syncthreads();\n//         }\n//     }\n// \n//     if (row == dest) {\n//         *pathLength = pathLength[row];\n//     }\n// }\n\n// Kokkos implementation of shortestPathLength\n#include <Kokkos_Core.hpp>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix. A is an undirected graph.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(Kokkos::View<const int**> &A, size_t N, int source, int dest) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Store the result in pathLength.\n   Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\n__global__ void shortestPathLength(const int *A, size_t N, int source, int dest, int *pathLength) {\nint row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < N && col < N) {\n        if (row == col) {\n            pathLength[row] = 0;\n        } else if (A[row * N + col] == 1) {\n            pathLength[row] = 1;\n        } else {\n            pathLength[row] = INT_MAX;\n        }\n\n        __syncthreads();\n\n        for (int k = 0; k < N; ++k) {\n            if (pathLength[row] + pathLength[k] < pathLength[col]) {\n                pathLength[col] = pathLength[row] + pathLength[k];\n            }\n            __syncthreads();\n        }\n    }\n\n    if (row == dest) {\n        *pathLength = pathLength[row];\n    }\n}",
        "translation_function_name": "shortestPathLength",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& col) {\n            if (pathLength(col) > pathLength(source) + A(col, source) && pathLength(col) > pathLength(k) + A(col, k)) {\n                pathLength(col) = pathLength(source) + A(col, source);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == source) {\n            pathLength(row) = 0;\n        } else if (A(row, source) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(dest);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + A(row, k) < pathLength(k)) {\n                pathLength(k) = pathLength(row) + A(row, k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n",
            "\n    Kokkos::View<int*> pathLength(\"pathLength\", N);\n\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n        if (row == dest) {\n            pathLength(row) = 0;\n        } else if (A(row, dest) == 1) {\n            pathLength(row) = 1;\n        } else {\n            pathLength(row) = INT_MAX;\n        }\n    });\n\n    Kokkos::fence();\n\n    for (int k = 0; k < N; ++k) {\n        Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int& row) {\n            if (pathLength(row) + pathLength(k) < pathLength(dest)) {\n                pathLength(dest) = pathLength(row) + pathLength(k);\n            }\n        });\n        Kokkos::fence();\n    }\n\n    return pathLength(source);\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "28_reduce_smallest_odd_number",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(Kokkos::View<const int*> const& x) {",
        "translation_prompt": "// CUDA implementation of smallestOdd\n// /* Find the value of the smallest odd number in the vector x. Store it in smallest.\n//    Use CUDA to compute in parallel. The kernel is launched with the same number of threads as elements in x.\n//    Examples:\n// \n//    input: [7, 9, 5, 2, 8, 16, 4, 1]\n//    output: 1\n// \n//    input: [8, 36, 7, 2, 11]\n//    output: 7\n// */\n// __global__ void smallestOdd(const int *x, size_t N, int *smallest) {\n// int thread_id = threadIdx.x;\n//     int block_id = blockIdx.x;\n//     int stride = blockDim.x;\n// \n//     int local_smallest = x[block_id * stride + thread_id];\n//     for (int i = 1; i < stride; i++) {\n//         int value = x[block_id * stride + thread_id + i];\n//         if (value % 2 == 1 && value < local_smallest) {\n//             local_smallest = value;\n//         }\n//     }\n//     if (local_smallest % 2 == 1) {\n//         atomicMin(smallest, local_smallest);\n//     }\n// }\n\n// Kokkos implementation of smallestOdd\n#include <Kokkos_Core.hpp>\n\n/* Return the value of the smallest odd number in the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(Kokkos::View<const int*> const& x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Find the value of the smallest odd number in the vector x. Store it in smallest.\n   Use CUDA to compute in parallel. The kernel is launched with the same number of threads as elements in x.\n   Examples:\n\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\n__global__ void smallestOdd(const int *x, size_t N, int *smallest) {\nint thread_id = threadIdx.x;\n    int block_id = blockIdx.x;\n    int stride = blockDim.x;\n\n    int local_smallest = x[block_id * stride + thread_id];\n    for (int i = 1; i < stride; i++) {\n        int value = x[block_id * stride + thread_id + i];\n        if (value % 2 == 1 && value < local_smallest) {\n            local_smallest = value;\n        }\n    }\n    if (local_smallest % 2 == 1) {\n        atomicMin(smallest, local_smallest);\n    }\n}",
        "translation_function_name": "smallestOdd",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsmall) {\n        if (x(i) % 2 == 1 && x(i) < lsmall) {\n            lsmall = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lcl) {\n        if (x(i) % 2 == 1 && x(i) < lcl) {\n            lcl = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsm) {\n        if (x(i) % 2 == 1 && x(i) < lsm) {\n            lsm = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lsmall) {\n        if (x(i) % 2 == 1 && x(i) < lsmall) {\n            lsmall = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lcl) {\n        if (x(i) % 2 == 1 && x(i) < lcl) {\n            lcl = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& local_smallest) {\n        if (x(i) % 2 == 1 && x(i) < local_smallest) {\n            local_smallest = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lcl) {\n        if (x(i) % 2 == 1 && x(i) < lcl) {\n            lcl = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n",
            "\n    int smallest = INT_MAX;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, int& lcl) {\n        if (x(i) % 2 == 1 && x(i) < lcl) {\n            lcl = x(i);\n        }\n    }, Kokkos::Min<int>(smallest));\n    return smallest;\n}\n"
        ]
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Return the average of the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(Kokkos::View<const double*> const& x) {",
        "translation_prompt": "// CUDA implementation of average\n// /* Compute the average of the vector x. Store the result in average.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Examples:\n//    \n// \t input: [1, 8, 4, 5, 1]\n//    output: 3.8\n// \n//    input: [2, 2, 2, 3]\n//    output: 2.25\n// */\n// __global__ void average(const double *x, size_t N, double *average) {\n// \n//     int tid = blockIdx.x * blockDim.x + threadIdx.x;\n//     double sum = 0.0;\n//     if (tid < N) {\n//         sum = x[tid];\n//     }\n//     sum = atomicAdd(average, sum);\n//     __syncthreads();\n//     if (tid == 0) {\n//         *average /= N;\n//     }\n// }\n\n// Kokkos implementation of average\n#include <Kokkos_Core.hpp>\n\n/* Return the average of the vector x.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(Kokkos::View<const double*> const& x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the average of the vector x. Store the result in average.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Examples:\n   \n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\n__global__ void average(const double *x, size_t N, double *average) {\n\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    double sum = 0.0;\n    if (tid < N) {\n        sum = x[tid];\n    }\n    sum = atomicAdd(average, sum);\n    __syncthreads();\n    if (tid == 0) {\n        *average /= N;\n    }\n}\n",
        "translation_function_name": "average",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(const int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n",
            "\n    double sum = 0.0;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, double& local_sum) {\n        local_sum += x(i);\n    }, sum);\n\n    return sum / x.size();\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Replace the i-th element of the array x with the minimum value from indices 0 through i.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(Kokkos::View<float*> &x) {",
        "translation_prompt": "// CUDA implementation of partialMinimums\n// /* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Examples:\n// \n//    input: [8, 6, -1, 7, 3, 4, 4]\n//    output: [8, 6, -1, -1, -1, -1, -1]\n// \n//    input: [5, 4, 6, 4, 3, 6, 1, 1]\n//    output: [5, 4, 4, 4, 3, 3, 1, 1]\n// */\n// __global__ void partialMinimums(float *x, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (i < N) {\n//         float min = x[i];\n//         for (int j = 0; j < i; j++) {\n//             if (x[j] < min) {\n//                 min = x[j];\n//             }\n//         }\n//         x[i] = min;\n//     }\n// }\n\n// Kokkos implementation of partialMinimums\n#include <Kokkos_Core.hpp>\n\n/* Replace the i-th element of the array x with the minimum value from indices 0 through i.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(Kokkos::View<float*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\n__global__ void partialMinimums(float *x, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        float min = x[i];\n        for (int j = 0; j < i; j++) {\n            if (x[j] < min) {\n                min = x[j];\n            }\n        }\n        x[i] = min;\n    }\n}",
        "translation_function_name": "partialMinimums",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n        float min = x(i);\n        for (int j = 0; j < i; j++) {\n            if (x(j) < min) {\n                min = x(j);\n            }\n        }\n        x(i) = min;\n    });\n}\n"
        ]
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "30_scan_prefix_sum",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute the prefix sum of the vector x into output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(Kokkos::View<const double*> const& x, Kokkos::View<double*> &output) {",
        "translation_prompt": "// CUDA implementation of prefixSum\n// /* Compute the prefix sum of the vector x into output.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n//    Example:\n//    \n//    input: [1, 7, 4, 6, 6, 2]\n//    output: [1, 8, 12, 18, 24, 26]\n// */\n// __global__ void prefixSum(const double *x, double *output, size_t N) {\n// int tid = threadIdx.x + blockIdx.x * blockDim.x;\n//     int stride = blockDim.x * gridDim.x;\n// \n//     for (size_t i = tid; i < N; i += stride) {\n//         double sum = 0;\n//         for (size_t j = 0; j <= i; ++j) {\n//             sum += x[j];\n//         }\n//         output[i] = sum;\n//     }\n// }\n\n// Kokkos implementation of prefixSum\n#include <Kokkos_Core.hpp>\n\n/* Compute the prefix sum of the vector x into output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(Kokkos::View<const double*> const& x, Kokkos::View<double*> &output) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the prefix sum of the vector x into output.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n   Example:\n   \n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\n__global__ void prefixSum(const double *x, double *output, size_t N) {\nint tid = threadIdx.x + blockIdx.x * blockDim.x;\n    int stride = blockDim.x * gridDim.x;\n\n    for (size_t i = tid; i < N; i += stride) {\n        double sum = 0;\n        for (size_t j = 0; j <= i; ++j) {\n            sum += x[j];\n        }\n        output[i] = sum;\n    }\n}",
        "translation_function_name": "prefixSum",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(\"prefixSum\", x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n      double sum = 0;\n      for (int j = 0; j <= i; ++j) {\n          sum += x(j);\n      }\n      output(i) = sum;\n  });\n  Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n      double sum = 0;\n      for (int j = 0; j <= i; ++j) {\n          sum += x(j);\n      }\n      output(i) = sum;\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n      double sum = 0;\n      for (int j = 0; j <= i; ++j) {\n          sum += x(j);\n      }\n      output(i) = sum;\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double sum = 0;\n        for (int j = 0; j <= i; ++j) {\n            sum += x(j);\n        }\n        output(i) = sum;\n    });\n    Kokkos::fence();\n}"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "56_transform_negate_odds",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(Kokkos::View<int*> &x) {",
        "translation_prompt": "// CUDA implementation of negateOddsAndHalveEvens\n// /* In the vector x negate the odd values and divide the even values by 2.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Example:\n// \n//    input: [16, 11, 12, 14, 1, 0, 5]\n//    output: [8, -11, 6, 7, -1, 0, -5]\n// */\n// __global__ void negateOddsAndHalveEvens(int *x, size_t N) {\n// int idx = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (idx < N) {\n//         if (x[idx] % 2 == 0) {\n//             x[idx] /= 2;\n//         } else {\n//             x[idx] = -x[idx];\n//         }\n//     }\n// }\n\n// Kokkos implementation of negateOddsAndHalveEvens\n#include <Kokkos_Core.hpp>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(Kokkos::View<int*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* In the vector x negate the odd values and divide the even values by 2.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Example:\n\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\n__global__ void negateOddsAndHalveEvens(int *x, size_t N) {\nint idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        if (x[idx] % 2 == 0) {\n            x[idx] /= 2;\n        } else {\n            x[idx] = -x[idx];\n        }\n    }\n}",
        "translation_function_name": "negateOddsAndHalveEvens",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        if (x(idx) % 2 == 0) {\n            x(idx) /= 2;\n        } else {\n            x(idx) = -x(idx);\n        }\n    });\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "59_transform_map_function",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(Kokkos::View<const int*> const& x, Kokkos::View<bool*> &mask) {",
        "translation_prompt": "// CUDA implementation of mapPowersOfTwo\n// __device__ bool isPowerOfTwo(int x) {\n// \treturn (x > 0) && !(x & (x - 1));\n// }\n// \n// /* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n//    Example:\n// \n//    input: [8, 0, 9, 7, 15, 64, 3]\n//    output: [true, false, false, false, false, true, false]\n// */\n// __global__ void mapPowersOfTwo(const int *x, bool *mask, size_t N) {\n// int i = threadIdx.x + blockIdx.x * blockDim.x;\n// \tif (i < N) {\n// \t\tmask[i] = isPowerOfTwo(x[i]);\n// \t}\n// }\n\n// Kokkos implementation of mapPowersOfTwo\n#include <Kokkos_Core.hpp>\n\nbool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(Kokkos::View<const int*> const& x, Kokkos::View<bool*> &mask) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "__device__ bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\n__global__ void mapPowersOfTwo(const int *x, bool *mask, size_t N) {\nint i = threadIdx.x + blockIdx.x * blockDim.x;\n\tif (i < N) {\n\t\tmask[i] = isPowerOfTwo(x[i]);\n\t}\n}",
        "translation_function_name": "mapPowersOfTwo",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n    mask(i) = isPowerOfTwo(x(i));\n  });\n}\n"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "57_transform_inverse_offset",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(Kokkos::View<double*> &x) {",
        "translation_prompt": "// CUDA implementation of oneMinusInverse\n// /* Replace every element of the vector x with 1-1/x.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n//    Example:\n// \n//    input: [2, 4, 1, 12, -2]\n//    output: [0.5, 0.75, 0, 0.91666666, 1.5]\n// */\n// __global__ void oneMinusInverse(double *x, size_t N) {\n// int idx = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (idx < N) {\n//         x[idx] = 1.0 - 1.0 / x[idx];\n//     }\n// }\n\n// Kokkos implementation of oneMinusInverse\n#include <Kokkos_Core.hpp>\n\n/* Replace every element of the vector x with 1-1/x.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(Kokkos::View<double*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Replace every element of the vector x with 1-1/x.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as elements in x.\n   Example:\n\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\n__global__ void oneMinusInverse(double *x, size_t N) {\nint idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        x[idx] = 1.0 - 1.0 / x[idx];\n    }\n}",
        "translation_function_name": "oneMinusInverse",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n        x(idx) = 1.0 - 1.0 / x(idx);\n    });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n    x(idx) = 1.0 - 1.0 / x(idx);\n});\n}",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n    x(idx) = 1.0 - 1.0 / x(idx);\n});\n}",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n    x(idx) = 1.0 - 1.0 / x(idx);\n});\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA(const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = 1.0 - 1.0 / x(idx);\n  });\n}"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(Kokkos::View<double*> &x) {",
        "translation_prompt": "// CUDA implementation of relu\n// /* Compute the ReLU function on every element of x. Elements less than zero become zero,\n//    while elements greater than zero stay the same.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Example:\n// \n//    input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n//    output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n// */\n// __global__ void relu(double *x, size_t N) {\n// int idx = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (idx < N) {\n//         x[idx] = max(0.0, x[idx]);\n//     }\n// }\n\n// Kokkos implementation of relu\n#include <Kokkos_Core.hpp>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(Kokkos::View<double*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\n__global__ void relu(double *x, size_t N) {\nint idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        x[idx] = max(0.0, x[idx]);\n    }\n}",
        "translation_function_name": "relu",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n    x(idx) = max(0.0, x(idx));\n});\n}",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n    x(idx) = max(0.0, x(idx));\n});\n}",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n    x(idx) = max(0.0, x(idx));\n});\n}",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n    x(idx) = max(0.0, x(idx));\n});\n}",
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n        x(idx) = max(0.0, x(idx));\n    });\n}\n",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = max(0.0, x(idx));\n  });\n}\n",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = max(0.0, x(idx));\n  });\n}\n",
            "\nKokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n    x(idx) = max(0.0, x(idx));\n});\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int idx) {\n      x(idx) = max(0.0, x(idx));\n  });\n}"
        ]
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "58_transform_squaring",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Replace every element of x with the square of its value.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(Kokkos::View<int*> &x) {",
        "translation_prompt": "// CUDA implementation of squareEach\n// /* Replace every element of x with the square of its value.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Example:\n// \n//    input: [5, 1, 2, -4, 8]\n//    output: [25, 1, 4, 16, 64]\n// */\n// __global__ void squareEach(int *x, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (i < N) {\n//         x[i] = x[i] * x[i];\n//     }\n// }\n\n// Kokkos implementation of squareEach\n#include <Kokkos_Core.hpp>\n\n/* Replace every element of x with the square of its value.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(Kokkos::View<int*> &x) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Replace every element of x with the square of its value.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Example:\n\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\n__global__ void squareEach(int *x, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        x[i] = x[i] * x[i];\n    }\n}",
        "translation_function_name": "squareEach",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n        x(i) = x(i) * x(i);\n    });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n    x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n    x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}",
            "\n  Kokkos::parallel_for(x.size(), KOKKOS_LAMBDA (const int i) {\n      x(i) = x(i) * x(i);\n  });\n}"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use Kokkos to parallelize. Assume Kokkos has already been initialized.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, Kokkos::View<const COOElement*> const& A, Kokkos::View<const double*> const& x, double beta, Kokkos::View<double *> &y, size_t M, size_t N) {",
        "translation_prompt": "// CUDA implementation of spmv\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n//    and A is a sparse matrix stored in COO format with sizeA elements.\n//    A has dimensions MxN, x has N values, and y has M values.\n//    Use CUDA to parallelize. The kernel will be launched with at least sizeA threads.\n//    Example:\n// \n//    input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n//    output: y=[2, 3]\n// */\n// __global__ void spmv(double alpha, const COOElement *A, size_t sizeA, const double *x, double beta, double *y, size_t M, size_t N) {\n// size_t row = blockIdx.x * blockDim.x + threadIdx.x;\n//    if (row < M) {\n//       double sum = 0.0;\n//       for (size_t i = 0; i < sizeA; i++) {\n//          if (A[i].row == row) {\n//             sum += A[i].value * x[A[i].column];\n//          }\n//       }\n//       y[row] = alpha * sum + beta * y[row];\n//    }\n// }\n\n// Kokkos implementation of spmv\n#include <Kokkos_Core.hpp>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use Kokkos to parallelize. Assume Kokkos has already been initialized.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, Kokkos::View<const COOElement*> const& A, Kokkos::View<const double*> const& x, double beta, Kokkos::View<double *> &y, size_t M, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format with sizeA elements.\n   A has dimensions MxN, x has N values, and y has M values.\n   Use CUDA to parallelize. The kernel will be launched with at least sizeA threads.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\n__global__ void spmv(double alpha, const COOElement *A, size_t sizeA, const double *x, double beta, double *y, size_t M, size_t N) {\nsize_t row = blockIdx.x * blockDim.x + threadIdx.x;\n   if (row < M) {\n      double sum = 0.0;\n      for (size_t i = 0; i < sizeA; i++) {\n         if (A[i].row == row) {\n            sum += A[i].value * x[A[i].column];\n         }\n      }\n      y[row] = alpha * sum + beta * y[row];\n   }\n}",
        "translation_function_name": "spmv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA (const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA (const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n   Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const size_t row) {\n      double sum = 0.0;\n      for (size_t i = 0; i < A.extent(0); i++) {\n         if (A(i).row == row) {\n            sum += A(i).value * x(A(i).column);\n         }\n      }\n      y(row) = alpha * sum + beta * y(row);\n   });\n   Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "46_sparse_la_spmm",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(Kokkos::View<const COOElement*> &A, Kokkos::View<const COOElement*> &X, Kokkos::View<double**> &Y, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// CUDA implementation of spmm\n// struct COOElement {\n//    size_t row, column;\n//    double value;\n// };\n// \n// /* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format with sizeA elements.\n//    X is a sparse KxN matrix in COO format with sizeX elements. Y is a dense MxN matrix in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched with at least sizeA threads.\n//    Example:\n// \n//    input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n//    output: Y=[{-1,-4}, {1,0}]\n// */\n// __global__ void spmm(const COOElement *A, size_t sizeA, const COOElement *X, size_t sizeX, double *Y, size_t M, size_t K, size_t N) {\n// \n//     int row = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (row < M) {\n//         for (int i = 0; i < sizeA; i++) {\n//             if (A[i].row == row) {\n//                 int col = A[i].column;\n//                 double valA = A[i].value;\n//                 for (int j = 0; j < sizeX; j++) {\n//                     if (X[j].row == col) {\n//                         int colX = X[j].column;\n//                         double valX = X[j].value;\n//                         atomicAdd(&Y[row * N + colX], valA * valX);\n//                     }\n//                 }\n//             }\n//         }\n//     }\n// }\n\n// Kokkos implementation of spmm\n#include <Kokkos_Core.hpp>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(Kokkos::View<const COOElement*> &A, Kokkos::View<const COOElement*> &X, Kokkos::View<double**> &Y, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format with sizeA elements.\n   X is a sparse KxN matrix in COO format with sizeX elements. Y is a dense MxN matrix in row-major.\n   Use CUDA to compute in parallel. The kernel is launched with at least sizeA threads.\n   Example:\n\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\n__global__ void spmm(const COOElement *A, size_t sizeA, const COOElement *X, size_t sizeX, double *Y, size_t M, size_t K, size_t N) {\n\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < M) {\n        for (int i = 0; i < sizeA; i++) {\n            if (A[i].row == row) {\n                int col = A[i].column;\n                double valA = A[i].value;\n                for (int j = 0; j < sizeX; j++) {\n                    if (X[j].row == col) {\n                        int colX = X[j].column;\n                        double valX = X[j].value;\n                        atomicAdd(&Y[row * N + colX], valA * valX);\n                    }\n                }\n            }\n        }\n    }\n}\n",
        "translation_function_name": "spmm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.size(); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.size(); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n        for (int i = 0; i < A.extent(0); i++) {\n            if (A(i).row == row) {\n                int col = A(i).column;\n                double valA = A(i).value;\n                for (int j = 0; j < X.extent(0); j++) {\n                    if (X(j).row == col) {\n                        int colX = X(j).column;\n                        double valX = X(j).value;\n                        Kokkos::atomic_add(&Y(row, colX), valA * valX);\n                    }\n                }\n            }\n        }\n    });\n}\n"
        ]
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "48_sparse_la_sparse_axpy",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nstruct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, Kokkos::View<const Element*> &x, Kokkos::View<const Element*> &y, Kokkos::View<double*> &z) {",
        "translation_prompt": "// CUDA implementation of sparseAxpy\n// struct Element {\n// \tsize_t index;\n//   double value;\n// };\n// \n// /* Compute z = alpha*x+y where x and y are sparse vectors of size Nx and Ny. Store the result in z.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x or y.\n//    Example:\n//    \n//    input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n//    output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n// */\n// __global__ void sparseAxpy(double alpha, const Element *x, const Element *y, double *z, size_t Nx, size_t Ny, size_t N) {\n// size_t i = blockIdx.x * blockDim.x + threadIdx.x;\n// \tif (i < N) {\n// \t\tdouble sum = 0;\n// \t\tfor (size_t j = 0; j < Nx; j++) {\n// \t\t\tif (x[j].index == i) {\n// \t\t\t\tsum += x[j].value;\n// \t\t\t}\n// \t\t}\n// \t\tfor (size_t j = 0; j < Ny; j++) {\n// \t\t\tif (y[j].index == i) {\n// \t\t\t\tsum += y[j].value;\n// \t\t\t}\n// \t\t}\n// \t\tz[i] = alpha * sum;\n// \t}\n// }\n\n// Kokkos implementation of sparseAxpy\n#include <Kokkos_Core.hpp>\n\nstruct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, Kokkos::View<const Element*> &x, Kokkos::View<const Element*> &y, Kokkos::View<double*> &z) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "struct Element {\n\tsize_t index;\n  double value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors of size Nx and Ny. Store the result in z.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x or y.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\n__global__ void sparseAxpy(double alpha, const Element *x, const Element *y, double *z, size_t Nx, size_t Ny, size_t N) {\nsize_t i = blockIdx.x * blockDim.x + threadIdx.x;\n\tif (i < N) {\n\t\tdouble sum = 0;\n\t\tfor (size_t j = 0; j < Nx; j++) {\n\t\t\tif (x[j].index == i) {\n\t\t\t\tsum += x[j].value;\n\t\t\t}\n\t\t}\n\t\tfor (size_t j = 0; j < Ny; j++) {\n\t\t\tif (y[j].index == i) {\n\t\t\t\tsum += y[j].value;\n\t\t\t}\n\t\t}\n\t\tz[i] = alpha * sum;\n\t}\n}",
        "translation_function_name": "sparseAxpy",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n    double sum = 0;\n    for (size_t j = 0; j < x.extent(0); j++) {\n      if (x(j).index == i) {\n        sum += x(j).value;\n      }\n    }\n    for (size_t j = 0; j < y.extent(0); j++) {\n      if (y(j).index == i) {\n        sum += y(j).value;\n      }\n    }\n    z(i) = alpha * sum;\n  });\n  Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "23_histogram_first_letter_counts",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(Kokkos::View<const char**> const& s, Kokkos::View<size_t[26]> &bins) {",
        "translation_prompt": "// CUDA implementation of firstLetterCounts\n// /* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n//    Assume all strings are in lower case. Store the output in `bins` array.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n//    output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n// */\n// __global__ void firstLetterCounts(const char **s, size_t N, size_t bins[26]) {\n// int tid = threadIdx.x;\n//     int bid = blockIdx.x;\n//     int stride = blockDim.x;\n//     int i = bid * stride + tid;\n//     if (i < N) {\n//         char c = s[i][0];\n//         if (c >= 'a' && c <= 'z') {\n//             atomicAdd(&bins[c - 'a'], 1);\n//         }\n//     }\n// }\n\n// Kokkos implementation of firstLetterCounts\n#include <Kokkos_Core.hpp>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(Kokkos::View<const char**> const& s, Kokkos::View<size_t[26]> &bins) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\n__global__ void firstLetterCounts(const char **s, size_t N, size_t bins[26]) {\nint tid = threadIdx.x;\n    int bid = blockIdx.x;\n    int stride = blockDim.x;\n    int i = bid * stride + tid;\n    if (i < N) {\n        char c = s[i][0];\n        if (c >= 'a' && c <= 'z') {\n            atomicAdd(&bins[c - 'a'], 1);\n        }\n    }\n}",
        "translation_function_name": "firstLetterCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(const int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(s.extent(0), KOKKOS_LAMBDA(int i) {\n        char c = s(i)[0];\n        if (c >= 'a' && c <= 'z') {\n            Kokkos::atomic_fetch_add(&bins(c - 'a'), 1);\n        }\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "21_histogram_bin_0-100",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(Kokkos::View<const double*> const& x, Kokkos::View<size_t[10]> &bins) {",
        "translation_prompt": "// CUDA implementation of binsBy10Count\n// /* Vector x contains values between 0 and 100, inclusive. Count the number of\n//    values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n//    Use CUDA to compute in parallel. The kernel is initialized with at least as many threads as values in x.\n//    Example:\n// \n//    input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n//    output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n// */\n// __global__ void binsBy10Count(const double *x, size_t N, size_t bins[10]) {\n// size_t tid = threadIdx.x;\n//     size_t gid = blockIdx.x * blockDim.x + threadIdx.x;\n//     size_t stride = blockDim.x * gridDim.x;\n// \n//     for (size_t i = gid; i < N; i += stride) {\n//         size_t bin = (size_t) (x[i] / 10);\n//         atomicAdd(&bins[bin], 1);\n//     }\n// }\n\n// Kokkos implementation of binsBy10Count\n#include <Kokkos_Core.hpp>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(Kokkos::View<const double*> const& x, Kokkos::View<size_t[10]> &bins) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Use CUDA to compute in parallel. The kernel is initialized with at least as many threads as values in x.\n   Example:\n\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\n__global__ void binsBy10Count(const double *x, size_t N, size_t bins[10]) {\nsize_t tid = threadIdx.x;\n    size_t gid = blockIdx.x * blockDim.x + threadIdx.x;\n    size_t stride = blockDim.x * gridDim.x;\n\n    for (size_t i = gid; i < N; i += stride) {\n        size_t bin = (size_t) (x[i] / 10);\n        atomicAdd(&bins[bin], 1);\n    }\n}",
        "translation_function_name": "binsBy10Count",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = (size_t) (x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = (size_t) (x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n      size_t bin = static_cast<size_t>(x(i) / 10);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = (size_t) (x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = static_cast<size_t>(x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        size_t bin = (size_t) (x(i) / 10);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use Kokkos to count in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(Kokkos::View<const Point*> const& points, Kokkos::View<size_t[4]> &bins) {",
        "translation_prompt": "// CUDA implementation of countQuadrants\n// struct Point {\n//    double x, y;\n// };\n// \n// /* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n//    Store the counts in `bins`.\n//    Use CUDA to count in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n//    output: [3, 1, 0, 2]\n// */\n// __global__ void countQuadrants(const Point *points, size_t N, size_t bins[4]) {\n// int i = threadIdx.x;\n//     if (i < N) {\n//         double x = points[i].x;\n//         double y = points[i].y;\n//         if (x >= 0 && y >= 0) {\n//             atomicAdd(&bins[0], 1);\n//         } else if (x < 0 && y >= 0) {\n//             atomicAdd(&bins[1], 1);\n//         } else if (x < 0 && y < 0) {\n//             atomicAdd(&bins[2], 1);\n//         } else if (x >= 0 && y < 0) {\n//             atomicAdd(&bins[3], 1);\n//         }\n//     }\n// }\n\n// Kokkos implementation of countQuadrants\n#include <Kokkos_Core.hpp>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use Kokkos to count in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(Kokkos::View<const Point*> const& points, Kokkos::View<size_t[4]> &bins) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Use CUDA to count in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\n__global__ void countQuadrants(const Point *points, size_t N, size_t bins[4]) {\nint i = threadIdx.x;\n    if (i < N) {\n        double x = points[i].x;\n        double y = points[i].y;\n        if (x >= 0 && y >= 0) {\n            atomicAdd(&bins[0], 1);\n        } else if (x < 0 && y >= 0) {\n            atomicAdd(&bins[1], 1);\n        } else if (x < 0 && y < 0) {\n            atomicAdd(&bins[2], 1);\n        } else if (x >= 0 && y < 0) {\n            atomicAdd(&bins[3], 1);\n        }\n    }\n}",
        "translation_function_name": "countQuadrants",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(const int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(points.extent(0), KOKKOS_LAMBDA(int i) {\n        double x = points(i).x;\n        double y = points(i).y;\n        if (x >= 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        } else if (x < 0 && y >= 0) {\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        } else if (x < 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        } else if (x >= 0 && y < 0) {\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n        }\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "24_histogram_count_quartile",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use Kokkos to compute in parallel. Assume that Kokkos has already been initialized.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(Kokkos::View<const double*> const& x, Kokkos::View<size_t[4]> &bins) {",
        "translation_prompt": "// CUDA implementation of countQuartiles\n// /* Count the number of doubles in the vector x that have a fractional part \n//    in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Examples:\n// \n//    input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n//    output: [2, 1, 2, 2]\n// \n//    input: [1.9, 0.2, 0.6, 10.1, 7.4]\n//    output: [2, 1, 1, 1]\n// */\n// __global__ void countQuartiles(const double *x, size_t N, size_t bins[4]) {\n// size_t i = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (i < N) {\n//         double frac = fmod(x[i], 1.0);\n//         if (frac < 0.25)\n//             atomicAdd(&bins[0], 1);\n//         else if (frac < 0.5)\n//             atomicAdd(&bins[1], 1);\n//         else if (frac < 0.75)\n//             atomicAdd(&bins[2], 1);\n//         else\n//             atomicAdd(&bins[3], 1);\n//     }\n// }\n\n// Kokkos implementation of countQuartiles\n#include <Kokkos_Core.hpp>\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use Kokkos to compute in parallel. Assume that Kokkos has already been initialized.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\nvoid countQuartiles(Kokkos::View<const double*> const& x, Kokkos::View<size_t[4]> &bins) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n\n   input: [1.9, 0.2, 0.6, 10.1, 7.4]\n   output: [2, 1, 1, 1]\n*/\n__global__ void countQuartiles(const double *x, size_t N, size_t bins[4]) {\nsize_t i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        double frac = fmod(x[i], 1.0);\n        if (frac < 0.25)\n            atomicAdd(&bins[0], 1);\n        else if (frac < 0.5)\n            atomicAdd(&bins[1], 1);\n        else if (frac < 0.75)\n            atomicAdd(&bins[2], 1);\n        else\n            atomicAdd(&bins[3], 1);\n    }\n}",
        "translation_function_name": "countQuartiles",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n      double frac = fmod(x(i), 1.0);\n      if (frac < 0.25)\n          Kokkos::atomic_fetch_add(&bins(0), 1);\n      else if (frac < 0.5)\n          Kokkos::atomic_fetch_add(&bins(1), 1);\n      else if (frac < 0.75)\n          Kokkos::atomic_fetch_add(&bins(2), 1);\n      else\n          Kokkos::atomic_fetch_add(&bins(3), 1);\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t i) {\n        double frac = fmod(x(i), 1.0);\n        if (frac < 0.25)\n            Kokkos::atomic_fetch_add(&bins(0), 1);\n        else if (frac < 0.5)\n            Kokkos::atomic_fetch_add(&bins(1), 1);\n        else if (frac < 0.75)\n            Kokkos::atomic_fetch_add(&bins(2), 1);\n        else\n            Kokkos::atomic_fetch_add(&bins(3), 1);\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "20_histogram_pixel_histogram",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use Kokkos to count in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(Kokkos::View<const int*> const& image, Kokkos::View<size_t[256]> &bins) {",
        "translation_prompt": "// CUDA implementation of pixelCounts\n// /* Count the number of pixels in image with each grayscale intensity.\n//    The vector `image` is a grayscale image with values 0-255.\n//    Store the results in `bins`.\n//    Use CUDA to count in parallel. The kernel is launched with at least N threads.\n//    Example:\n//    \n//    input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n//    output: [0, 0, 2, 0, 1, ...]\n// */\n// __global__ void pixelCounts(const int *image, size_t N, size_t bins[256]) {\n// int tid = threadIdx.x;\n//     int gid = blockIdx.x * blockDim.x + threadIdx.x;\n//     int bin = 0;\n//     for (int i = gid; i < N; i += blockDim.x * gridDim.x) {\n//         bin = image[i];\n//         atomicAdd(&bins[bin], 1);\n//     }\n// }\n\n// Kokkos implementation of pixelCounts\n#include <Kokkos_Core.hpp>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use Kokkos to count in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n void pixelCounts(Kokkos::View<const int*> const& image, Kokkos::View<size_t[256]> &bins) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Use CUDA to count in parallel. The kernel is launched with at least N threads.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\n__global__ void pixelCounts(const int *image, size_t N, size_t bins[256]) {\nint tid = threadIdx.x;\n    int gid = blockIdx.x * blockDim.x + threadIdx.x;\n    int bin = 0;\n    for (int i = gid; i < N; i += blockDim.x * gridDim.x) {\n        bin = image[i];\n        atomicAdd(&bins[bin], 1);\n    }\n}",
        "translation_function_name": "pixelCounts",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n      int bin = image(i);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n      int bin = image(i);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.size(), KOKKOS_LAMBDA(const int i) {\n        int bin = 0;\n        bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n      int bin = image(i);\n      Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n      int bin = image(i);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.size(), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n      int bin = image(i);\n      Kokkos::atomic_fetch_add(&bins(bin), 1);\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(\"pixelCounts\", image.size(), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(image.extent(0), KOKKOS_LAMBDA(const int i) {\n        int bin = image(i);\n        Kokkos::atomic_fetch_add(&bins(0, bin), 1);\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<const int*> const& x, int target) {",
        "translation_prompt": "// CUDA implementation of contains\n// /* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n//    Use CUDA to search in parallel. The kernel is launched with at least N threads.\n//    Examples:\n// \n//    input: x=[1, 8, 2, 6, 4, 6], target=3\n//    output: false\n//    \n//    input: x=[1, 8, 2, 6, 4, 6], target=8\n//    output: true\n// */\n// __global__ void contains(const int *x, size_t N, int target, bool *found) {\n// // TODO: implement the kernel\n// }\n\n// Kokkos implementation of contains\n#include <Kokkos_Core.hpp>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(Kokkos::View<const int*> const& x, int target) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Set `found` to true if the vector x contains the value `target`. Set it to false otherwise.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\n__global__ void contains(const int *x, size_t N, int target, bool *found) {\n// TODO: implement the kernel\n}",
        "translation_function_name": "contains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n    bool found = false;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n        if (x(i) == target) {\n            local_found = true;\n        }\n    }, found);\n    return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n    bool found = false;\n    Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n        if (x(i) == target) {\n            lfound = true;\n        }\n    }, found);\n    return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& lfound) {\n    if (x(i) == target) {\n      lfound = true;\n    }\n  }, found);\n  return found;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "39_search_xor_contains",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, Kokkos::View<const int*> const& y, int val) {",
        "translation_prompt": "// CUDA implementation of xorContains\n// /* Set `found` to true if `val` is only in one of vectors x or y.\n//    Set it to false if it is in both or neither.\n//    Use CUDA to search in parallel. The kernel is launched with at least N threads.\n//    Examples:\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n//    output: true\n// \n//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n//    output: false\n// */\n// __global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {\n// int tid = threadIdx.x;\n//   int i = blockIdx.x * blockDim.x + tid;\n//   int found_local = 0;\n//   while (i < N) {\n//     found_local ^= (x[i] == val) | (y[i] == val);\n//     i += blockDim.x * gridDim.x;\n//   }\n//   __syncthreads();\n//   if (tid == 0) {\n//     *found = found_local;\n//   }\n// }\n\n// Kokkos implementation of xorContains\n#include <Kokkos_Core.hpp>\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Use Kokkos to search in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(Kokkos::View<const int*> const& x, Kokkos::View<const int*> const& y, int val) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Set `found` to true if `val` is only in one of vectors x or y.\n   Set it to false if it is in both or neither.\n   Use CUDA to search in parallel. The kernel is launched with at least N threads.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\n__global__ void xorContains(const int *x, const int *y, size_t N, int val, bool *found) {\nint tid = threadIdx.x;\n  int i = blockIdx.x * blockDim.x + tid;\n  int found_local = 0;\n  while (i < N) {\n    found_local ^= (x[i] == val) | (y[i] == val);\n    i += blockDim.x * gridDim.x;\n  }\n  __syncthreads();\n  if (tid == 0) {\n    *found = found_local;\n  }\n}",
        "translation_function_name": "xorContains",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, Kokkos::Min<bool>(found));\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, Kokkos::Min<bool>(found));\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, found);\n  return found;\n}\n",
            "\n  bool found = false;\n  Kokkos::parallel_reduce(x.size(), KOKKOS_LAMBDA(int i, bool& local_found) {\n    local_found ^= (x(i) == val) | (y(i) == val);\n  }, Kokkos::Min<bool>(found));\n  return found;\n}\n"
        ]
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "35_search_search_for_last_struct_by_key",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {",
        "translation_prompt": "// CUDA implementation of findLastShortBook\n// struct Book {\n//    const char* title;\n//    int pages;\n// };\n// \n// /* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n//    Store the result in lastShortBookIndex.\n//    Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n// \t Example:\n// \n//    input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n//    output: 2\n// */\n// __global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {\n// \n// // Thread index\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n// \n// // Check if the thread index is within the bounds of the books array\n// if (i < N) {\n//     // Check if the book has less than 100 pages\n//     if (books[i].pages < 100) {\n//         // Use atomicMax to safely find the largest index among all threads\n//         atomicMax((int*)lastShortBookIndex, i);\n//     }\n// }\n// }\n\n// Kokkos implementation of findLastShortBook\n#include <Kokkos_Core.hpp>\n\nstruct Book {\n   const char *title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Use Kokkos to search in parallel. Assume Kokkos is already initialized.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(Kokkos::View<const Book*> const& books) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "struct Book {\n   const char* title;\n   int pages;\n};\n\n/* Find the index of the last Book item in the vector books where Book.pages is less than 100.\n   Store the result in lastShortBookIndex.\n   Use CUDA to search in parallel. The kernel is launched with one thread for every book element.\n\t Example:\n\n   input: [{title=\"Green Eggs and Ham\", pages=72}, {title=\"gulliver's travels\", pages=362}, {title=\"Stories of Your Life\", pages=54}, {title=\"Hamilton\", pages=818}]\n   output: 2\n*/\n__global__ void findLastShortBook(const Book *books, size_t N, size_t *lastShortBookIndex) {\n\n// Thread index\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n\n// Check if the thread index is within the bounds of the books array\nif (i < N) {\n    // Check if the book has less than 100 pages\n    if (books[i].pages < 100) {\n        // Use atomicMax to safely find the largest index among all threads\n        atomicMax((int*)lastShortBookIndex, i);\n    }\n}\n}",
        "translation_function_name": "findLastShortBook",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\n\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\n  size_t lastShortBookIndex = 0;\n  Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n      lsb = i;\n    }\n  }, lastShortBookIndex);\n  return lastShortBookIndex;\n}\n",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\nsize_t lastShortBookIndex = 0;\nKokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n    if (books(i).pages < 100) {\n        lsb = i;\n    }\n}, lastShortBookIndex);\nreturn lastShortBookIndex;\n}",
            "\n    size_t lastShortBookIndex = 0;\n    Kokkos::parallel_reduce(books.size(), KOKKOS_LAMBDA(int i, size_t& lsb) {\n        if (books(i).pages < 100) {\n            lsb = i;\n        }\n    }, lastShortBookIndex);\n    return lastShortBookIndex;\n}\n"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "06_fft_dft",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(Kokkos::View<const double*> &x, Kokkos::View<Kokkos::complex<double>*> &output) {",
        "translation_prompt": "// CUDA implementation of dft\n// /* Compute the discrete fourier transform of x. Store the result in output.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [1, 4, 9, 16]\n//    output: [30+0i, -8-12i, -10-0i, -8+12i]\n// */\n// __global__ void dft(const double *x, cuDoubleComplex *output, size_t N) {\n// int tid = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (tid >= N) return;\n// \n//     cuDoubleComplex sum = {0, 0};\n//     for (size_t k = 0; k < N; ++k) {\n//         double angle = -2 * M_PI * tid * k / N;\n//         cuDoubleComplex exp_part = {cos(angle), sin(angle)};\n//         cuDoubleComplex term = cuCmul(exp_part, make_cuDoubleComplex(x[k], 0));\n//         sum = cuCadd(sum, term);\n//     }\n//     output[tid] = sum;\n// }\n\n// Kokkos implementation of dft\n#include <Kokkos_Core.hpp>\n\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(Kokkos::View<const double*> &x, Kokkos::View<Kokkos::complex<double>*> &output) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the discrete fourier transform of x. Store the result in output.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\n__global__ void dft(const double *x, cuDoubleComplex *output, size_t N) {\nint tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid >= N) return;\n\n    cuDoubleComplex sum = {0, 0};\n    for (size_t k = 0; k < N; ++k) {\n        double angle = -2 * M_PI * tid * k / N;\n        cuDoubleComplex exp_part = {cos(angle), sin(angle)};\n        cuDoubleComplex term = cuCmul(exp_part, make_cuDoubleComplex(x[k], 0));\n        sum = cuCadd(sum, term);\n    }\n    output[tid] = sum;\n}",
        "translation_function_name": "dft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (size_t k = 0; k < x.extent(0); ++k) {\n          double angle = -2 * M_PI * tid * k / x.extent(0);\n          Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n          Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n          sum += term;\n      }\n      output(tid) = sum;\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (size_t k = 0; k < x.extent(0); ++k) {\n        double angle = -2 * M_PI * tid * k / x.extent(0);\n        Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n        Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n        sum += term;\n    }\n    output(tid) = sum;\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int tid) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (size_t k = 0; k < x.extent(0); ++k) {\n            double angle = -2 * M_PI * tid * k / x.extent(0);\n            Kokkos::complex<double> exp_part = {cos(angle), sin(angle)};\n            Kokkos::complex<double> term = exp_part * Kokkos::complex<double>(x(k), 0);\n            sum += term;\n        }\n        output(tid) = sum;\n    });\n    Kokkos::fence();\n}"
        ]
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(Kokkos::View<const Kokkos::complex<double>*> &x, Kokkos::View<Kokkos::complex<double>*> &output) {",
        "translation_prompt": "// CUDA implementation of fft\n// /* Compute the fourier transform of x. Store the result in output.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n//    output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n// */\n// __global__ void fft(const cuDoubleComplex *x, cuDoubleComplex *output, size_t N) {\n// int idx = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (idx < N) {\n//         cuDoubleComplex sum = {0, 0};\n//         for (int k = 0; k < N; k++) {\n//             cuDoubleComplex a = x[k];\n//             cuDoubleComplex b = cuCmul(make_cuDoubleComplex(cos(2 * M_PI * idx * k / N), -sin(2 * M_PI * idx * k / N)), a);\n//             sum = cuCadd(sum, b);\n//         }\n//         output[idx] = sum;\n//     }\n// }\n\n// Kokkos implementation of fft\n#include <Kokkos_Core.hpp>\n\n/* Compute the fourier transform of x. Store the result in output.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(Kokkos::View<const Kokkos::complex<double>*> &x, Kokkos::View<Kokkos::complex<double>*> &output) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute the fourier transform of x. Store the result in output.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\n__global__ void fft(const cuDoubleComplex *x, cuDoubleComplex *output, size_t N) {\nint idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        cuDoubleComplex sum = {0, 0};\n        for (int k = 0; k < N; k++) {\n            cuDoubleComplex a = x[k];\n            cuDoubleComplex b = cuCmul(make_cuDoubleComplex(cos(2 * M_PI * idx * k / N), -sin(2 * M_PI * idx * k / N)), a);\n            sum = cuCadd(sum, b);\n        }\n        output[idx] = sum;\n    }\n}",
        "translation_function_name": "fft",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (int k = 0; k < x.extent(0); k++) {\n          Kokkos::complex<double> a = x(k);\n          Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n          sum += b;\n      }\n      output(idx) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = std::polar(1.0, -2 * M_PI * idx * k / x.extent(0)) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (int k = 0; k < x.extent(0); k++) {\n          Kokkos::complex<double> a = x(k);\n          Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n          sum += b;\n      }\n      output(idx) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (int k = 0; k < x.extent(0); k++) {\n          Kokkos::complex<double> a = x(k);\n          Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n          sum += b;\n      }\n      output(idx) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\n}",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (int k = 0; k < x.extent(0); k++) {\n          Kokkos::complex<double> a = x(k);\n          Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n          sum += b;\n      }\n      output(idx) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n    Kokkos::complex<double> sum = {0, 0};\n    for (int k = 0; k < x.extent(0); k++) {\n        Kokkos::complex<double> a = x(k);\n        Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n        sum += b;\n    }\n    output(idx) = sum;\n});\n}",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      Kokkos::complex<double> sum = {0, 0};\n      for (int k = 0; k < x.extent(0); k++) {\n          Kokkos::complex<double> a = x(k);\n          Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n          sum += b;\n      }\n      output(idx) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        Kokkos::complex<double> sum = {0, 0};\n        for (int k = 0; k < x.extent(0); k++) {\n            Kokkos::complex<double> a = x(k);\n            Kokkos::complex<double> b = Kokkos::complex<double>(cos(2 * M_PI * idx * k / x.extent(0)), -sin(2 * M_PI * idx * k / x.extent(0))) * a;\n            sum += b;\n        }\n        output(idx) = sum;\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "03_dense_la_axpy",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, Kokkos::View<const double*> &x, Kokkos::View<const double*> &y, Kokkos::View<double*> &z) {",
        "translation_prompt": "// CUDA implementation of axpy\n// /* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n//    Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n//    Example:\n//    \n//    input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n//    output: z=[2, -6, 5, 17]\n// */\n// __global__ void axpy(double alpha, const double *x, const double *y, double *z, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (i < N) {\n//         z[i] = alpha * x[i] + y[i];\n//     }\n// }\n\n// Kokkos implementation of axpy\n#include <Kokkos_Core.hpp>\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, Kokkos::View<const double*> &x, Kokkos::View<const double*> &y, Kokkos::View<double*> &z) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Use CUDA to compute in parallel. The kernel is launched with at least as many threads as values in x.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\n__global__ void axpy(double alpha, const double *x, const double *y, double *z, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}",
        "translation_function_name": "axpy",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA (const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int i) {\n        z(i) = alpha * x(i) + y(i);\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "02_dense_la_gemm",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(Kokkos::View<const double**> &A, Kokkos::View<const double**> &B, Kokkos::View<double**> &C, size_t M, size_t K, size_t N) {",
        "translation_prompt": "// CUDA implementation of gemm\n// /* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n//    A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched on an MxN grid of threads.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n//    output: C=[[9, 5], [4, 2]]\n// */\n// __global__ void gemm(const double *A, const double *B, double *C, size_t M, size_t K, size_t N) {\n// int row = blockIdx.x * blockDim.x + threadIdx.x;\n//     int col = blockIdx.y * blockDim.y + threadIdx.y;\n//     double sum = 0;\n//     for (int k = 0; k < K; k++) {\n//         sum += A[row * K + k] * B[k * N + col];\n//     }\n//     C[row * N + col] = sum;\n// }\n\n// Kokkos implementation of gemm\n#include <Kokkos_Core.hpp>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(Kokkos::View<const double**> &A, Kokkos::View<const double**> &B, Kokkos::View<double**> &C, size_t M, size_t K, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Use CUDA to compute in parallel. The kernel is launched on an MxN grid of threads.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\n__global__ void gemm(const double *A, const double *B, double *C, size_t M, size_t K, size_t N) {\nint row = blockIdx.x * blockDim.x + threadIdx.x;\n    int col = blockIdx.y * blockDim.y + threadIdx.y;\n    double sum = 0;\n    for (int k = 0; k < K; k++) {\n        sum += A[row * K + k] * B[k * N + col];\n    }\n    C[row * N + col] = sum;\n}",
        "translation_function_name": "gemm",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nKokkos::parallel_for(\"gemm\", M, KOKKOS_LAMBDA(const int row) {\n    for (int col = 0; col < N; col++) {\n        double sum = 0;\n        for (int k = 0; k < K; k++) {\n            sum += A(row, k) * B(k, col);\n        }\n        C(row, col) = sum;\n    }\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"gemm\", M, KOKKOS_LAMBDA(const int row) {\n    for (int col = 0; col < N; col++) {\n        double sum = 0;\n        for (int k = 0; k < K; k++) {\n            sum += A(row, k) * B(k, col);\n        }\n        C(row, col) = sum;\n    }\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n    double sum = 0;\n    for (int k = 0; k < K; k++) {\n        sum += A(row, k) * B(k, col);\n    }\n    C(row, col) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n    double sum = 0;\n    for (int k = 0; k < K; k++) {\n        sum += A(row, k) * B(k, col);\n    }\n    C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n    double sum = 0;\n    for (int k = 0; k < K; k++) {\n        sum += A(row, k) * B(k, col);\n    }\n    C(row, col) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"gemm\", M, KOKKOS_LAMBDA(const int row) {\n    for (size_t col = 0; col < N; col++) {\n        double sum = 0;\n        for (size_t k = 0; k < K; k++) {\n            sum += A(row, k) * B(k, col);\n        }\n        C(row, col) = sum;\n    }\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n    double sum = 0;\n    for (int k = 0; k < K; k++) {\n        sum += A(row, k) * B(k, col);\n    }\n    C(row, col) = sum;\n});\nKokkos::fence();\n}",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int& row, const int& col) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(row, k) * B(k, col);\n      }\n      C(row, col) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gemm\", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0,0}, {M,N}), KOKKOS_LAMBDA (const int i, const int j) {\n      double sum = 0;\n      for (int k = 0; k < K; k++) {\n          sum += A(i, k) * B(k, j);\n      }\n      C(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "04_dense_la_gemv",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix, x has N elements, and y has M elements.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(Kokkos::View<const double**> &A, Kokkos::View<const double*> &x, Kokkos::View<double*> &y, size_t M, size_t N) {",
        "translation_prompt": "// CUDA implementation of gemv\n// /* Multiply the matrix A by the vector x. Store the results in the vector y.\n//    A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n//    Use CUDA to compute in parallel. The kernel is launched with at least M threads.\n//    Example:\n// \n//    input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n//    output: y=[1, -3]\n// */\n// __global__ void gemv(const double *A, const double *x, double *y, size_t M, size_t N) {\n// int row = blockIdx.x * blockDim.x + threadIdx.x;\n//   if (row < M) {\n//     double sum = 0.0;\n//     for (int col = 0; col < N; ++col) {\n//       sum += A[row * N + col] * x[col];\n//     }\n//     y[row] = sum;\n//   }\n// }\n\n// Kokkos implementation of gemv\n#include <Kokkos_Core.hpp>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix, x has N elements, and y has M elements.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(Kokkos::View<const double**> &A, Kokkos::View<const double*> &x, Kokkos::View<double*> &y, size_t M, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Use CUDA to compute in parallel. The kernel is launched with at least M threads.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\n__global__ void gemv(const double *A, const double *x, double *y, size_t M, size_t N) {\nint row = blockIdx.x * blockDim.x + threadIdx.x;\n  if (row < M) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A[row * N + col] * x[col];\n    }\n    y[row] = sum;\n  }\n}",
        "translation_function_name": "gemv",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA (const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA (const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA (const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(M, KOKKOS_LAMBDA(const int row) {\n    double sum = 0.0;\n    for (int col = 0; col < N; ++col) {\n      sum += A(row, col) * x(col);\n    }\n    y(row) = sum;\n  });\n  Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "42_sort_sorted_ranks",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* For each value in the array x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(Kokkos::View<const float*> const& x, Kokkos::View<size_t*> &ranks) {",
        "translation_prompt": "// CUDA implementation of ranks\n// /* For each value in the vector x compute its index in the sorted vector.\n//    Store the results in `ranks`.\n//    Use CUDA to compute in parallel. The kernel will be launched with at least as many threads as elements in x.\n//    Examples:\n// \n//    input: [3.1, 2.8, 9.1, 0.4, 3.14]\n//    output: [2, 1, 4, 0, 3]\n//  \n//    input: [100, 7.6, 16.1, 18, 7.6]\n//    output: [4, 0, 1, 2, 3]\n// */\n// __global__ void ranks(const float *x, size_t *ranks, size_t N) {\n// size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (idx < N) {\n//         float val = x[idx];\n//         size_t rank = 0;\n//         for (size_t i = 0; i < N; ++i) {\n//             if (x[i] <= val) {\n//                 ++rank;\n//             }\n//         }\n//         ranks[idx] = rank - 1;\n//     }\n// }\n\n// Kokkos implementation of ranks\n#include <Kokkos_Core.hpp>\n\n/* For each value in the array x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(Kokkos::View<const float*> const& x, Kokkos::View<size_t*> &ranks) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Use CUDA to compute in parallel. The kernel will be launched with at least as many threads as elements in x.\n   Examples:\n\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n \n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\n__global__ void ranks(const float *x, size_t *ranks, size_t N) {\nsize_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        float val = x[idx];\n        size_t rank = 0;\n        for (size_t i = 0; i < N; ++i) {\n            if (x[i] <= val) {\n                ++rank;\n            }\n        }\n        ranks[idx] = rank - 1;\n    }\n}",
        "translation_function_name": "ranks",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      float val = x(idx);\n      size_t rank = 0;\n      for (size_t i = 0; i < x.extent(0); ++i) {\n          if (x(i) <= val) {\n              ++rank;\n          }\n      }\n      ranks(idx) = rank - 1;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      float val = x(idx);\n      size_t rank = 0;\n      for (size_t i = 0; i < x.extent(0); ++i) {\n          if (x(i) <= val) {\n              ++rank;\n          }\n      }\n      ranks(idx) = rank - 1;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      float val = x(idx);\n      size_t rank = 0;\n      for (size_t i = 0; i < x.extent(0); ++i) {\n          if (x(i) <= val) {\n              ++rank;\n          }\n      }\n      ranks(idx) = rank - 1;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      float val = x(idx);\n      size_t rank = 0;\n      for (size_t i = 0; i < x.extent(0); ++i) {\n          if (x(i) <= val) {\n              ++rank;\n          }\n      }\n      ranks(idx) = rank - 1;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n      float val = x(idx);\n      size_t rank = 0;\n      for (size_t i = 0; i < x.extent(0); ++i) {\n          if (x(i) <= val) {\n              ++rank;\n          }\n      }\n      ranks(idx) = rank - 1;\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const size_t idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(x.extent(0), KOKKOS_LAMBDA(const int idx) {\n        float val = x(idx);\n        size_t rank = 0;\n        for (size_t i = 0; i < x.extent(0); ++i) {\n            if (x(i) <= val) {\n                ++rank;\n            }\n        }\n        ranks(idx) = rank - 1;\n    });\n    Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(Kokkos::View<const int**> &input, Kokkos::View<int**> &output, size_t N) {",
        "translation_prompt": "// CUDA implementation of cellsXOR\n// /* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n//    Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n//    input and output are NxN grids of ints in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n//    Example:\n// \n//    input: [[0, 1, 1, 0],\n//            [1, 0, 0, 0],\n//            [0, 0, 0, 0],\n//            [0, 1, 0, 0]\n//    output: [[0, 0, 1, 1],\n//             [1, 0, 0, 1],\n//             [0, 0, 1, 0],\n//             [1, 0, 1, 0]]\n// */\n// __global__ void cellsXOR(const int *input, int *output, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     int j = blockIdx.y * blockDim.y + threadIdx.y;\n// \n//     if (i < N && j < N) {\n//         int num_neighbors = 0;\n//         if (i > 0 && input[i - 1 + N * j] == 1) {\n//             num_neighbors++;\n//         }\n//         if (i < N - 1 && input[i + 1 + N * j] == 1) {\n//             num_neighbors++;\n//         }\n//         if (j > 0 && input[i + N * (j - 1)] == 1) {\n//             num_neighbors++;\n//         }\n//         if (j < N - 1 && input[i + N * (j + 1)] == 1) {\n//             num_neighbors++;\n//         }\n//         if (num_neighbors == 1) {\n//             output[i + N * j] = 1;\n//         } else {\n//             output[i + N * j] = 0;\n//         }\n//     }\n// }\n\n// Kokkos implementation of cellsXOR\n#include <Kokkos_Core.hpp>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(Kokkos::View<const int**> &input, Kokkos::View<int**> &output, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\n__global__ void cellsXOR(const int *input, int *output, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    int j = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (i < N && j < N) {\n        int num_neighbors = 0;\n        if (i > 0 && input[i - 1 + N * j] == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input[i + 1 + N * j] == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input[i + N * (j - 1)] == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input[i + N * (j + 1)] == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output[i + N * j] = 1;\n        } else {\n            output[i + N * j] = 0;\n        }\n    }\n}",
        "translation_function_name": "cellsXOR",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\n    Kokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n        for (size_t j = 0; j < N; j++) {\n            int num_neighbors = 0;\n            if (i > 0 && input(i - 1, j) == 1) {\n                num_neighbors++;\n            }\n            if (i < N - 1 && input(i + 1, j) == 1) {\n                num_neighbors++;\n            }\n            if (j > 0 && input(i, j - 1) == 1) {\n                num_neighbors++;\n            }\n            if (j < N - 1 && input(i, j + 1) == 1) {\n                num_neighbors++;\n            }\n            if (num_neighbors == 1) {\n                output(i, j) = 1;\n            } else {\n                output(i, j) = 0;\n            }\n        }\n    });\n}\n",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}",
            "\nKokkos::parallel_for(\"cellsXOR\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n        int num_neighbors = 0;\n        if (i > 0 && input(i - 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (i < N - 1 && input(i + 1, j) == 1) {\n            num_neighbors++;\n        }\n        if (j > 0 && input(i, j - 1) == 1) {\n            num_neighbors++;\n        }\n        if (j < N - 1 && input(i, j + 1) == 1) {\n            num_neighbors++;\n        }\n        if (num_neighbors == 1) {\n            output(i, j) = 1;\n        } else {\n            output(i, j) = 0;\n        }\n    });\n});\nKokkos::fence();\n}"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "54_stencil_game_of_life",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(Kokkos::View<const int**> &input, Kokkos::View<int**> &output, size_t N) {",
        "translation_prompt": "// CUDA implementation of gameOfLife\n// /* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n//    A cell is 1 if it is alive and 0 if it is dead.\n//    If a live cell has fewer than 2 live neighbors then it dies.\n//    If a live cell has 2 or 3 live neighbors then it lives on.\n//    If a live cell has more than 3 live neighbords then it dies.\n//    If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n//    Example:\n// \n//    input:  [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 0, 0, 0],\n//             [0, 1, 1, 0, 0],\n//             [0, 0, 1, 1, 0],\n//             [0, 1, 0, 0, 0]]\n//    output: [[0, 0, 0, 0, 0],\n// \t\t\t\t\t  [0, 1, 1, 0, 0],\n//             [0, 1, 0, 1, 0],\n//             [0, 0, 0, 1, 0],\n//             [0, 0, 1, 0, 0]]\n// */\n// __global__ void gameOfLife(const int *input, int *output, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//   int j = blockIdx.y * blockDim.y + threadIdx.y;\n// \n//   if (i < N && j < N) {\n//     int neighbors = 0;\n//     for (int x = -1; x <= 1; x++) {\n//       for (int y = -1; y <= 1; y++) {\n//         if (x == 0 && y == 0) {\n//           continue;\n//         }\n//         int neighbor_i = i + x;\n//         int neighbor_j = j + y;\n//         if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n//           continue;\n//         }\n//         neighbors += input[neighbor_i * N + neighbor_j];\n//       }\n//     }\n//     output[i * N + j] = input[i * N + j];\n//     if (input[i * N + j] == 1) {\n//       if (neighbors < 2 || neighbors > 3) {\n//         output[i * N + j] = 0;\n//       }\n//     } else {\n//       if (neighbors == 3) {\n//         output[i * N + j] = 1;\n//       }\n//     }\n//   }\n// }\n\n// Kokkos implementation of gameOfLife\n#include <Kokkos_Core.hpp>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids.\n   Use Kokkos to compute in parallel. Assume Kokkos is already initialized.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(Kokkos::View<const int**> &input, Kokkos::View<int**> &output, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\n__global__ void gameOfLife(const int *input, int *output, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n  int j = blockIdx.y * blockDim.y + threadIdx.y;\n\n  if (i < N && j < N) {\n    int neighbors = 0;\n    for (int x = -1; x <= 1; x++) {\n      for (int y = -1; y <= 1; y++) {\n        if (x == 0 && y == 0) {\n          continue;\n        }\n        int neighbor_i = i + x;\n        int neighbor_j = j + y;\n        if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n          continue;\n        }\n        neighbors += input[neighbor_i * N + neighbor_j];\n      }\n    }\n    output[i * N + j] = input[i * N + j];\n    if (input[i * N + j] == 1) {\n      if (neighbors < 2 || neighbors > 3) {\n        output[i * N + j] = 0;\n      }\n    } else {\n      if (neighbors == 3) {\n        output[i * N + j] = 1;\n      }\n    }\n  }\n}",
        "translation_function_name": "gameOfLife",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"game_of_life\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int j) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    });\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"gameOfLife\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int neighbors = 0;\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          if (x == 0 && y == 0) {\n            continue;\n          }\n          int neighbor_i = i + x;\n          int neighbor_j = j + y;\n          if (neighbor_i < 0 || neighbor_i >= N || neighbor_j < 0 || neighbor_j >= N) {\n            continue;\n          }\n          neighbors += input(neighbor_i, neighbor_j);\n        }\n      }\n      output(i, j) = input(i, j);\n      if (input(i, j) == 1) {\n        if (neighbors < 2 || neighbors > 3) {\n          output(i, j) = 0;\n        }\n      } else {\n        if (neighbors == 3) {\n          output(i, j) = 1;\n        }\n      }\n    }\n  });\n  Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "52_stencil_1d_jacobi_3-point_stencil",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(Kokkos::View<const double*> &input, Kokkos::View<double*> &output) {",
        "translation_prompt": "// CUDA implementation of jacobi1D\n// /* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n//    i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n//    Replace with 0 when reading past the boundaries of `input`.\n//    Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n//    Example:\n// \n//    input: [9, -6, -1, 2, 3]\n//    output: [1, 2/3, -5/3, 4/3, 5/3]\n// */\n// __global__ void jacobi1D(const double *input, double *output, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     if (i < N) {\n//         if (i == 0) {\n//             output[i] = (input[i] + input[i + 1]) / 2;\n//         } else if (i == N - 1) {\n//             output[i] = (input[i - 1] + input[i]) / 2;\n//         } else {\n//             output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n//         }\n//     }\n// }\n\n// Kokkos implementation of jacobi1D\n#include <Kokkos_Core.hpp>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(Kokkos::View<const double*> &input, Kokkos::View<double*> &output) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Use CUDA to compute in parallel. The kernel is launched with at least N threads.\n   Example:\n\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\n__global__ void jacobi1D(const double *input, double *output, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i < N) {\n        if (i == 0) {\n            output[i] = (input[i] + input[i + 1]) / 2;\n        } else if (i == N - 1) {\n            output[i] = (input[i - 1] + input[i]) / 2;\n        } else {\n            output[i] = (input[i - 1] + input[i] + input[i + 1]) / 3;\n        }\n    }\n}",
        "translation_function_name": "jacobi1D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA(const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n    Kokkos::fence();\n}",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n}\n",
            "\n    Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n        if (i == 0) {\n            output(i) = (input(i) + input(i + 1)) / 2;\n        } else if (i == input.extent(0) - 1) {\n            output(i) = (input(i - 1) + input(i)) / 2;\n        } else {\n            output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n        }\n    });\n}\n",
            "\n  Kokkos::parallel_for(input.extent(0), KOKKOS_LAMBDA (const int i) {\n      if (i == 0) {\n          output(i) = (input(i) + input(i + 1)) / 2;\n      } else if (i == input.extent(0) - 1) {\n          output(i) = (input(i - 1) + input(i)) / 2;\n      } else {\n          output(i) = (input(i - 1) + input(i) + input(i + 1)) / 3;\n      }\n  });\n  Kokkos::fence();\n}"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "51_stencil_edge_kernel",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images.\n   Store the output of the computation in imageOut.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(Kokkos::View<const int**> &imageIn, Kokkos::View<int**> &imageOut, size_t N) {",
        "translation_prompt": "// CUDA implementation of convolveKernel\n// __constant__ int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n// \n// /* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n//    the dot product of itself and its neighbors with the edge kernel.\n//    Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n//    imageIn and imageOut are NxN grayscale images stored in row-major.\n//    Store the output of the computation in imageOut.\n//    Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n//    Example:\n// \n//    input: [[112, 118, 141, 152],\n//            [93, 101, 119, 203],\n//            [45, 17, 16, 232],\n//            [82, 31, 49, 101]]\n//    output: [[255, 255, 255, 255],\n//             [255, 147, 0, 255],\n//             [36, 0, 0, 255],\n//             [255, 39, 0, 255]]\n// */\n// __global__ void convolveKernel(const int *imageIn, int *imageOut, size_t N) {\n// // TODO: implement the kernel\n// }\n\n// Kokkos implementation of convolveKernel\n#include <Kokkos_Core.hpp>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images.\n   Store the output of the computation in imageOut.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\nvoid convolveKernel(Kokkos::View<const int**> &imageIn, Kokkos::View<int**> &imageOut, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "__constant__ int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n   Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n   Example:\n\n   input: [[112, 118, 141, 152],\n           [93, 101, 119, 203],\n           [45, 17, 16, 232],\n           [82, 31, 49, 101]]\n   output: [[255, 255, 255, 255],\n            [255, 147, 0, 255],\n            [36, 0, 0, 255],\n            [255, 39, 0, 255]]\n*/\n__global__ void convolveKernel(const int *imageIn, int *imageOut, size_t N) {\n// TODO: implement the kernel\n}",
        "translation_function_name": "convolveKernel",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; ++j) {\n      int sum = 0;\n      for (int k = -1; k <= 1; ++k) {\n        for (int l = -1; l <= 1; ++l) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n}",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(N, KOKKOS_LAMBDA(const int i) {\n    for (int j = 0; j < N; ++j) {\n      int sum = 0;\n      for (int k = -1; k <= 1; ++k) {\n        for (int l = -1; l <= 1; ++l) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int x = i + k;\n          int y = j + l;\n          if (x >= 0 && x < N && y >= 0 && y < N) {\n            sum += imageIn(x, y) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolveKernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"convolve_kernel\", N, KOKKOS_LAMBDA(const int i) {\n    for (size_t j = 0; j < N; j++) {\n      int sum = 0;\n      for (int k = -1; k <= 1; k++) {\n        for (int l = -1; l <= 1; l++) {\n          int row = i + k;\n          int col = j + l;\n          if (row >= 0 && row < N && col >= 0 && col < N) {\n            sum += imageIn(row, col) * edgeKernel[k + 1][l + 1];\n          }\n        }\n      }\n      imageOut(i, j) = sum < 0 ? 0 : (sum > 255 ? 255 : sum);\n    }\n  });\n  Kokkos::fence();\n}\n"
        ]
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "53_stencil_2d_jacobi_5-point_stencil",
        "parallelism_model": "kokkos",
        "prompt": "#include <Kokkos_Core.hpp>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(Kokkos::View<const double**> &input, Kokkos::View<double**> &output, size_t N) {",
        "translation_prompt": "// CUDA implementation of jacobi2D\n// /* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n//    Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n//    i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n//    Replace with 0 when reading past the boundaries of `input`.\n//    `input` and `output` are NxN grids stored in row-major.\n//    Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n//    Example:\n// \n//    input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n//    output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n// */\n// __global__ void jacobi2D(const double *input, double *output, size_t N) {\n// int i = blockIdx.x * blockDim.x + threadIdx.x;\n//     int j = blockIdx.y * blockDim.y + threadIdx.y;\n//     if (i >= N || j >= N) {\n//         return;\n//     }\n//     int idx = i + j * N;\n//     double sum = 0;\n//     if (i > 0) {\n//         sum += input[idx - 1];\n//     }\n//     if (i < N - 1) {\n//         sum += input[idx + 1];\n//     }\n//     if (j > 0) {\n//         sum += input[idx - N];\n//     }\n//     if (j < N - 1) {\n//         sum += input[idx + N];\n//     }\n//     sum += input[idx];\n//     sum /= 5;\n//     output[idx] = sum;\n// }\n\n// Kokkos implementation of jacobi2D\n#include <Kokkos_Core.hpp>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids.\n   Use Kokkos to compute in parallel. Assume Kokkos has already been initialized.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(Kokkos::View<const double**> &input, Kokkos::View<double**> &output, size_t N) {\n",
        "translation_src_model": "cuda",
        "translation_dst_model": "kokkos",
        "translation_src_example": "/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Use CUDA to compute in parallel. The kernel is launched on an NxN grid of threads.\n   Example:\n\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\n__global__ void jacobi2D(const double *input, double *output, size_t N) {\nint i = blockIdx.x * blockDim.x + threadIdx.x;\n    int j = blockIdx.y * blockDim.y + threadIdx.y;\n    if (i >= N || j >= N) {\n        return;\n    }\n    int idx = i + j * N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input[idx - 1];\n    }\n    if (i < N - 1) {\n        sum += input[idx + 1];\n    }\n    if (j > 0) {\n        sum += input[idx - N];\n    }\n    if (j < N - 1) {\n        sum += input[idx + N];\n    }\n    sum += input[idx];\n    sum /= 5;\n    output[idx] = sum;\n}",
        "translation_function_name": "jacobi2D",
        "temperature": 0.2,
        "top_p": 0.95,
        "do_sample": true,
        "max_new_tokens": 1024,
        "outputs": [
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i - 1, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 2, j);\n      }\n      if (j > 0) {\n          sum += input(i + 1, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i + 1, j + 1);\n      }\n      sum += input(i + 1, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    if (i >= N || j >= N) {\n        return;\n    }\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j - 1);\n    }\n    if (i < N - 1) {\n        sum += input(i, j + 1);\n    }\n    if (j > 0) {\n        sum += input(i - 1, j);\n    }\n    if (j < N - 1) {\n        sum += input(i + 1, j);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 1, j);\n      }\n      if (j > 0) {\n          sum += input(i, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i, j + 1);\n      }\n      sum += input(i, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n      int i = idx % N;\n      int j = idx / N;\n      double sum = 0;\n      if (i > 0) {\n          sum += input(i - 1, j);\n      }\n      if (i < N - 1) {\n          sum += input(i + 1, j);\n      }\n      if (j > 0) {\n          sum += input(i, j - 1);\n      }\n      if (j < N - 1) {\n          sum += input(i, j + 1);\n      }\n      sum += input(i, j);\n      sum /= 5;\n      output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\n  Kokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int idx) {\n    int i = idx % N;\n    int j = idx / N;\n    double sum = 0;\n    if (i > 0) {\n        sum += input(i, j);\n    }\n    if (i < N - 1) {\n        sum += input(i + 1, j);\n    }\n    if (j > 0) {\n        sum += input(i, j - 1);\n    }\n    if (j < N - 1) {\n        sum += input(i, j + 1);\n    }\n    sum += input(i, j);\n    sum /= 5;\n    output(i, j) = sum;\n  });\n  Kokkos::fence();\n}\n",
            "\nKokkos::parallel_for(\"jacobi2D\", N, KOKKOS_LAMBDA(const int i) {\n    for (int j = 0; j < N; j++) {\n        double sum = 0;\n        if (i > 0) {\n            sum += input(i - 1, j);\n        }\n        if (i < N - 1) {\n            sum += input(i + 1, j);\n        }\n        if (j > 0) {\n            sum += input(i, j - 1);\n        }\n        if (j < N - 1) {\n            sum += input(i, j + 1);\n        }\n        sum += input(i, j);\n        sum /= 5;\n        output(i, j) = sum;\n    }\n});\nKokkos::fence();\n}"
        ]
    }
]